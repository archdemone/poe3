import{bo as A,b as c,E as d,L as h,_ as E,bq as C,ag as b}from"./main-e8601b72.js";let l=null;async function x(){var f;const e=((f=d.LastCreatedEngine)==null?void 0:f.createCanvas(100,100))??new OffscreenCanvas(100,100);e instanceof OffscreenCanvas&&h.Warn("DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.");const{ThinEngine:s}=await E(()=>import("./main-e8601b72.js").then(t=>t.dM),["assets/main-e8601b72.js","assets/index-ad665221.css"]);if(!s.IsSupported){if(!e.getContext("bitmaprenderer"))throw new Error("DumpData: No WebGL or bitmap rendering context available. Cannot dump data.");return{canvas:e}}const r={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1},a=new s(e,!1,r);d.Instances.pop(),d.OnEnginesDisposedObservable.add(t=>{a&&t!==a&&!a.isDisposed&&d.Instances.length===0&&y()}),a.getCaps().parallelShaderCompile=void 0;const p=new C(a),{passPixelShader:i}=await E(()=>import("./pass.fragment-52eaea35.js"),["assets/pass.fragment-52eaea35.js","assets/main-e8601b72.js","assets/index-ad665221.css"]),u=new b({engine:a,name:i.name,fragmentShader:i.shader,samplerNames:["textureSampler"]});return{canvas:e,dumpEngine:{engine:a,renderer:p,wrapper:u}}}async function I(){return l||(l=x()),await l}async function v(e,s,r,a,p="image/png",i,u){const f=await r.readPixels(0,0,e,s),t=new Uint8Array(f.buffer);D(e,s,t,a,p,i,!0,void 0,u)}async function w(e,s,r,a="image/png",p,i=!1,u=!1,f){if(r instanceof Float32Array){const m=new Uint8Array(r.length);let n=r.length;for(;n--;){const o=r[n];m[n]=Math.round(A(o)*255)}r=m}const t=await I();return await new Promise(async m=>{if(t.dumpEngine){const n=t.dumpEngine;n.engine.setSize(e,s,!0);const o=n.engine.createRawTexture(r,e,s,5,!1,!i,1);n.renderer.setViewport(),n.renderer.applyEffectWrapper(n.wrapper),n.wrapper.effect._bindTexture("textureSampler",o),n.renderer.draw(),o.dispose()}else{const n=t.canvas.getContext("bitmaprenderer");t.canvas.width=e,t.canvas.height=s;const o=new ImageData(e,s);o.data.set(r);const g=await createImageBitmap(o,{premultiplyAlpha:"none",imageOrientation:i?"flipY":"from-image"});n.transferFromImageBitmap(g)}c.ToBlob(t.canvas,n=>{if(!n)throw new Error("DumpData: Failed to convert canvas to blob.");p!==void 0&&c.DownloadBlob(n,p);const o=new FileReader;o.onload=g=>{const _=g.target.result;m(_)},u?o.readAsArrayBuffer(n):o.readAsDataURL(n)},a,f)})}function D(e,s,r,a,p="image/png",i,u=!1,f=!1,t){i===void 0&&!a&&(i=""),w(e,s,r,p,i,u,f,t).then(m=>{a&&a(m)})}function y(){l&&(l==null||l.then(e=>{e.canvas instanceof HTMLCanvasElement&&e.canvas.remove(),e.dumpEngine&&(e.dumpEngine.engine.dispose(),e.dumpEngine.renderer.dispose(),e.dumpEngine.wrapper.dispose())}),l=null)}const L={DumpData:D,DumpDataAsync:w,DumpFramebuffer:v,Dispose:y},T=()=>{c.DumpData=D,c.DumpDataAsync=w,c.DumpFramebuffer=v};T();export{y as Dispose,D as DumpData,w as DumpDataAsync,v as DumpFramebuffer,L as DumpTools};
