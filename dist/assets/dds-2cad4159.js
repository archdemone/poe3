import{al as ye,e as x,P as J,bo as P,_ as H,x as N,bh as he,cV as be,am as Ce,aU as Fe,L as D}from"./main-e8601b72.js";import{P as ge,C as we}from"./passPostProcess-99298d86.js";function Re(n,e,t,r=!0){const o=n.getScene(),c=o.getEngine(),i=new ye("resized"+n.name,{width:e,height:t},o,!n.noMipmap,!0,n._texture.type,!1,n.samplingMode,!1);i.wrapU=n.wrapU,i.wrapV=n.wrapV,i.uOffset=n.uOffset,i.vOffset=n.vOffset,i.uScale=n.uScale,i.vScale=n.vScale,i.uAng=n.uAng,i.vAng=n.vAng,i.wAng=n.wAng,i.coordinatesIndex=n.coordinatesIndex,i.level=n.level,i.anisotropicFilteringLevel=n.anisotropicFilteringLevel,i._texture.isReady=!1,n.wrapU=x.CLAMP_ADDRESSMODE,n.wrapV=x.CLAMP_ADDRESSMODE;const a=new ge("pass",1,null,r?x.BILINEAR_SAMPLINGMODE:x.NEAREST_SAMPLINGMODE,c,!1,0);return a.externalTextureSamplerBinding=!0,a.onEffectCreatedObservable.addOnce(l=>{l.executeWhenCompiled(()=>{a.onApply=function(f){f.setTexture("textureSampler",n)};const s=i.renderTarget;s&&(o.postProcessManager.directRender([a],s),c.unBindFramebuffer(s),i.disposeFramebufferObjects(),a.dispose(),i.getInternalTexture().isReady=!0)})}),i}function Ge(n,e,t,r,o,c,i,a){const l=e.getEngine();return e.isReady=!1,o=o??e.samplingMode,r=r??e.type,c=c??e.format,i=i??e.width,a=a??e.height,r===-1&&(r=0),new Promise(s=>{const f=new J("postprocess",n,null,null,1,null,o,l,!1,void 0,r,void 0,null,!1,c);f.externalTextureSamplerBinding=!0;const d=l.createRenderTargetTexture({width:i,height:a},{generateDepthBuffer:!1,generateMipMaps:!1,generateStencilBuffer:!1,samplingMode:o,type:r,format:c});f.onEffectCreatedObservable.addOnce(u=>{u.executeWhenCompiled(()=>{f.onApply=h=>{h._bindTexture("textureSampler",e),h.setFloat2("scale",1,1)},t.postProcessManager.directRender([f],d,!0),l.restoreDefaultFramebuffer(),l._releaseTexture(e),f&&f.dispose(),d._swapAndDie(e),e.type=r,e.format=5,e.isReady=!0,s(e)})})})}let W,Q;function T(n){W||(W=new Float32Array(1),Q=new Int32Array(W.buffer)),W[0]=n;const e=Q[0];let t=e>>16&32768,r=e>>12&2047;const o=e>>23&255;return o<103?t:o>142?(t|=31744,t|=(o==255?0:1)&&e&8388607,t):o<113?(r|=2048,t|=(r>>114-o)+(r>>113-o&1),t):(t|=o-112<<10|r>>1,t+=r&1,t)}function E(n){const e=(n&32768)>>15,t=(n&31744)>>10,r=n&1023;return t===0?(e?-1:1)*Math.pow(2,-14)*(r/Math.pow(2,10)):t==31?r?NaN:(e?-1:1)*(1/0):(e?-1:1)*Math.pow(2,t-15)*(1+r/Math.pow(2,10))}function Oe(n){switch(n){case 36492:case 36493:case 36495:case 36494:case 33779:case 35919:case 33778:case 35918:case 33777:case 33776:case 35917:case 35916:case 37808:case 37840:case 36196:case 37492:case 37493:case 37494:case 37495:case 37496:case 37497:return!0;default:return!1}}async function Pe(n){var r,o;if(n.isReady())return;if(n.loadingError)throw new Error(((r=n.errorObject)==null?void 0:r.message)||`Texture ${n.name} errored while loading.`);const e=n.onLoadObservable;if(e)return await new Promise(c=>e.addOnce(()=>c()));const t=(o=n._texture)==null?void 0:o.onLoadedObservable;if(t)return await new Promise(c=>t.addOnce(()=>c()));throw new Error(`Cannot determine readiness of texture ${n.name}.`)}async function Ee(n,e,t,r,o){const c=n.getScene(),i=c.getEngine();i.isWebGPU?n.isCube?await H(()=>import("./lodCube.fragment-ff6abf8b.js"),["assets/lodCube.fragment-ff6abf8b.js","assets/main-e8601b72.js","assets/index-ad665221.css"]):await H(()=>import("./lod.fragment-b72be3c3.js"),["assets/lod.fragment-b72be3c3.js","assets/main-e8601b72.js","assets/index-ad665221.css"]):n.isCube?await H(()=>import("./lodCube.fragment-d6605fcd.js"),["assets/lodCube.fragment-d6605fcd.js","assets/main-e8601b72.js","assets/index-ad665221.css"]):await H(()=>import("./lod.fragment-2724b926.js"),["assets/lod.fragment-2724b926.js","assets/main-e8601b72.js","assets/index-ad665221.css"]);let a;if(!n.isCube)a=new J("lod","lod",{uniforms:["lod","gamma"],samplingMode:x.NEAREST_NEAREST_MIPNEAREST,engine:i,shaderLanguage:i.isWebGPU?1:0});else{const f=["#define POSITIVEX","#define NEGATIVEX","#define POSITIVEY","#define NEGATIVEY","#define POSITIVEZ","#define NEGATIVEZ"];a=new J("lodCube","lodCube",{uniforms:["lod","gamma"],samplingMode:x.NEAREST_NEAREST_MIPNEAREST,engine:i,defines:f[r],shaderLanguage:i.isWebGPU?1:0})}await new Promise(f=>{a.onEffectCreatedObservable.addOnce(d=>{d.executeWhenCompiled(()=>{f(0)})})});const l=new ye("temp",{width:e,height:t},c,!1);a.onApply=function(f){f.setTexture("textureSampler",n),f.setFloat("lod",o),f.setInt("gamma",n.gammaSpace?1:0)};const s=n.getInternalTexture();try{if(l.renderTarget&&s){const f=s.samplingMode;o!==0?n.updateSamplingMode(x.NEAREST_NEAREST_MIPNEAREST):n.updateSamplingMode(x.NEAREST_NEAREST),c.postProcessManager.directRender([a],l.renderTarget,!0),n.updateSamplingMode(f);const d=await i.readPixels(0,0,e,t),u=new Uint8Array(d.buffer,0,d.byteLength);return i.unBindFramebuffer(l.renderTarget),u}else throw Error("Render to texture failed.")}finally{l.dispose(),a.dispose()}}async function Be(n,e,t,r=0,o=0){await Pe(n);const{width:c,height:i}=n.getSize(),a=e??c,l=t??i;if(Oe(n.textureFormat)||a!==c||l!==i)return await Ee(n,a,l,r,o);let s=await n.readPixels(r,o);if(!s)throw new Error(`Failed to read pixels from texture ${n.name}.`);if(s instanceof Float32Array){const f=new Uint8Array(s.length);let d=s.length;for(;d--;){const u=s[d];f[d]=Math.round(P(u)*255)}s=f}return s}const ze={CreateResizedCopy:Re,ApplyPostProcess:Ge,ToHalfFloat:T,FromHalfFloat:E,GetTextureDataAsync:Be};function xe(n){const e=n.split("?")[0],t=e.lastIndexOf(".");return t>-1?e.substring(t).toLowerCase():""}N.prototype._partialLoadFile=function(n,e,t,r,o=null){const c=a=>{t[e]=a,t._internalCount++,t._internalCount===6&&r(t)},i=(a,l)=>{o&&a&&o(a.status+" "+a.statusText,l)};this._loadFile(n,c,void 0,void 0,!0,i)};N.prototype._cascadeLoadFiles=function(n,e,t,r=null){const o=[];o._internalCount=0;for(let c=0;c<6;c++)this._partialLoadFile(t[c],c,o,e,r)};N.prototype._cascadeLoadImgs=function(n,e,t,r,o=null,c){const i=[];i._internalCount=0;for(let a=0;a<6;a++)this._partialLoadImg(r[a],a,i,n,e,t,o,c)};N.prototype._partialLoadImg=function(n,e,t,r,o,c,i=null,a){const l=he();be(n,d=>{t[e]=d,t._internalCount++,r&&r.removePendingData(l),t._internalCount===6&&c&&c(o,t)},(d,u)=>{r&&r.removePendingData(l),i&&i(d,u)},r?r.offlineProvider:null,a),r&&r.addPendingData(l)};N.prototype.createCubeTextureBase=function(n,e,t,r,o=null,c=null,i,a=null,l=!1,s=0,f=0,d=null,u=null,h=null,p=!1,_=null){const A=d||new Ce(this,7);A.isCube=!0,A.url=n,A.generateMipMaps=!r,A._lodGenerationScale=s,A._lodGenerationOffset=f,A._useSRGBBuffer=!!p&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!r),A!==d&&(A.label=n.substring(0,60)),this._doNotHandleContextLost||(A._extension=a,A._files=t,A._buffer=_);const b=n;this._transformTextureUrl&&!d&&(n=this._transformTextureUrl(n));const G=a??xe(n),M=Fe(G),g=(C,m)=>{A.dispose(),c?c(C,m):C&&D.Warn(C)},I=(C,m)=>{n===b?C&&g(C.status+" "+C.statusText,m):(D.Warn(`Failed to load ${n}, falling back to the ${b}`),this.createCubeTextureBase(b,e,t,!!r,o,g,i,a,l,s,f,A,u,h,p,_))};if(M)M.then(C=>{const m=w=>{u&&u(A,w),C.loadCubeData(w,A,l,o,(U,k)=>{g(U,k)})};_?m(_):t&&t.length===6?C.supportCascades?this._cascadeLoadFiles(e,w=>m(w.map(U=>new Uint8Array(U))),t,g):g("Textures type does not support cascades."):this._loadFile(n,w=>m(new Uint8Array(w)),void 0,e?e.offlineProvider||null:void 0,!0,I)});else{if(!t||t.length===0)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(e,A,(C,m)=>{h&&h(C,m)},t,g)}return this._internalTexturesCache.push(A),A};const Ie=542327876,q=131072,ee=512,te=4,re=64,ae=131072;function V(n){return n.charCodeAt(0)+(n.charCodeAt(1)<<8)+(n.charCodeAt(2)<<16)+(n.charCodeAt(3)<<24)}function Le(n){return String.fromCharCode(n&255,n>>8&255,n>>16&255,n>>24&255)}const ne=V("DXT1"),se=V("DXT3"),oe=V("DXT5"),$=V("DX10"),fe=113,ie=116,ce=2,le=10,Te=88,j=31,Me=0,Ue=1,ue=2,de=3,Y=4,Ae=7,Z=20,pe=21,Se=22,De=23,Ne=24,ke=25,ve=26,He=28,We=32;class y{static GetDDSInfo(e){const t=new Int32Array(e.buffer,e.byteOffset,j),r=new Int32Array(e.buffer,e.byteOffset,j+4);let o=1;t[ue]&q&&(o=Math.max(1,t[Ae]));const c=t[pe],i=c===$?r[We]:0;let a=0;switch(c){case fe:a=2;break;case ie:a=1;break;case $:if(i===le){a=2;break}if(i===ce){a=1;break}}return{width:t[Y],height:t[de],mipmapCount:o,isFourCC:(t[Z]&te)===te,isRGB:(t[Z]&re)===re,isLuminance:(t[Z]&ae)===ae,isCube:(t[He]&ee)===ee,isCompressed:c===ne||c===se||c===oe,dxgiFormat:i,textureType:a}}static _GetHalfFloatAsFloatRGBAArrayBuffer(e,t,r,o,c,i){const a=new Float32Array(o),l=new Uint16Array(c,r);let s=0;for(let f=0;f<t;f++)for(let d=0;d<e;d++){const u=(d+f*e)*4;a[s]=E(l[u]),a[s+1]=E(l[u+1]),a[s+2]=E(l[u+2]),y.StoreLODInAlphaChannel?a[s+3]=i:a[s+3]=E(l[u+3]),s+=4}return a}static _GetHalfFloatRGBAArrayBuffer(e,t,r,o,c,i){if(y.StoreLODInAlphaChannel){const a=new Uint16Array(o),l=new Uint16Array(c,r);let s=0;for(let f=0;f<t;f++)for(let d=0;d<e;d++){const u=(d+f*e)*4;a[s]=l[u],a[s+1]=l[u+1],a[s+2]=l[u+2],a[s+3]=T(i),s+=4}return a}return new Uint16Array(c,r,o)}static _GetFloatRGBAArrayBuffer(e,t,r,o,c,i){if(y.StoreLODInAlphaChannel){const a=new Float32Array(o),l=new Float32Array(c,r);let s=0;for(let f=0;f<t;f++)for(let d=0;d<e;d++){const u=(d+f*e)*4;a[s]=l[u],a[s+1]=l[u+1],a[s+2]=l[u+2],a[s+3]=i,s+=4}return a}return new Float32Array(c,r,o)}static _GetFloatAsHalfFloatRGBAArrayBuffer(e,t,r,o,c,i){const a=new Uint16Array(o),l=new Float32Array(c,r);let s=0;for(let f=0;f<t;f++)for(let d=0;d<e;d++)a[s]=T(l[s]),a[s+1]=T(l[s+1]),a[s+2]=T(l[s+2]),y.StoreLODInAlphaChannel?a[s+3]=T(i):a[s+3]=T(l[s+3]),s+=4;return a}static _GetFloatAsUIntRGBAArrayBuffer(e,t,r,o,c,i){const a=new Uint8Array(o),l=new Float32Array(c,r);let s=0;for(let f=0;f<t;f++)for(let d=0;d<e;d++){const u=(d+f*e)*4;a[s]=P(l[u])*255,a[s+1]=P(l[u+1])*255,a[s+2]=P(l[u+2])*255,y.StoreLODInAlphaChannel?a[s+3]=i:a[s+3]=P(l[u+3])*255,s+=4}return a}static _GetHalfFloatAsUIntRGBAArrayBuffer(e,t,r,o,c,i){const a=new Uint8Array(o),l=new Uint16Array(c,r);let s=0;for(let f=0;f<t;f++)for(let d=0;d<e;d++){const u=(d+f*e)*4;a[s]=P(E(l[u]))*255,a[s+1]=P(E(l[u+1]))*255,a[s+2]=P(E(l[u+2]))*255,y.StoreLODInAlphaChannel?a[s+3]=i:a[s+3]=P(E(l[u+3]))*255,s+=4}return a}static _GetRGBAArrayBuffer(e,t,r,o,c,i,a,l,s){const f=new Uint8Array(o),d=new Uint8Array(c,r);let u=0;for(let h=0;h<t;h++)for(let p=0;p<e;p++){const _=(p+h*e)*4;f[u]=d[_+i],f[u+1]=d[_+a],f[u+2]=d[_+l],f[u+3]=d[_+s],u+=4}return f}static _ExtractLongWordOrder(e){return e===0||e===255||e===-16777216?0:1+y._ExtractLongWordOrder(e>>8)}static _GetRGBArrayBuffer(e,t,r,o,c,i,a,l){const s=new Uint8Array(o),f=new Uint8Array(c,r);let d=0;for(let u=0;u<t;u++)for(let h=0;h<e;h++){const p=(h+u*e)*3;s[d]=f[p+i],s[d+1]=f[p+a],s[d+2]=f[p+l],d+=3}return s}static _GetLuminanceArrayBuffer(e,t,r,o,c){const i=new Uint8Array(o),a=new Uint8Array(c,r);let l=0;for(let s=0;s<t;s++)for(let f=0;f<e;f++){const d=f+s*e;i[l]=a[d],l++}return i}static UploadDDSLevels(e,t,r,o,c,i,a=-1,l,s=!0){let f=null;o.sphericalPolynomial&&(f=[]);const d=!!e.getCaps().s3tc;t.generateMipMaps=c;const u=new Int32Array(r.buffer,r.byteOffset,j);let h,p,_,A=0,b,G,M,g,I=0,C=1;if(u[Me]!==Ie){D.Error("Invalid magic number in DDS header");return}if(!o.isFourCC&&!o.isRGB&&!o.isLuminance){D.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");return}if(o.isCompressed&&!d){D.Error("Compressed textures are not supported on this platform.");return}let m=u[Se];b=u[Ue]+4;let w=!1;if(o.isFourCC)switch(h=u[pe],h){case ne:C=8,I=33777;break;case se:C=16,I=33778;break;case oe:C=16,I=33779;break;case fe:w=!0,m=64;break;case ie:w=!0,m=128;break;case $:{b+=5*4;let R=!1;switch(o.dxgiFormat){case le:w=!0,m=64,R=!0;break;case ce:w=!0,m=128,R=!0;break;case Te:o.isRGB=!0,o.isFourCC=!1,m=32,R=!0;break}if(R)break}default:D.Error(["Unsupported FourCC code:",Le(h)]);return}const U=y._ExtractLongWordOrder(u[De]),k=y._ExtractLongWordOrder(u[Ne]),K=y._ExtractLongWordOrder(u[ke]),_e=y._ExtractLongWordOrder(u[ve]);w&&(I=e._getRGBABufferInternalSizedFormat(o.textureType)),M=1,u[ue]&q&&c!==!1&&(M=Math.max(1,u[Ae]));const me=l||0,S=e.getCaps();for(let R=me;R<i;R++){for(p=u[Y],_=u[de],g=0;g<M;++g){if(a===-1||a===g){const F=a===-1?g:0;if(!o.isCompressed&&o.isFourCC){t.format=5,A=p*_*4;let O=null;if(e._badOS||e._badDesktopOS||!S.textureHalfFloat&&!S.textureFloat)m===128?(O=y._GetFloatAsUIntRGBAArrayBuffer(p,_,r.byteOffset+b,A,r.buffer,F),f&&F==0&&f.push(y._GetFloatRGBAArrayBuffer(p,_,r.byteOffset+b,A,r.buffer,F))):m===64&&(O=y._GetHalfFloatAsUIntRGBAArrayBuffer(p,_,r.byteOffset+b,A,r.buffer,F),f&&F==0&&f.push(y._GetHalfFloatAsFloatRGBAArrayBuffer(p,_,r.byteOffset+b,A,r.buffer,F))),t.type=0;else{const v=S.textureFloat&&(s&&S.textureFloatLinearFiltering||!s),X=S.textureHalfFloat&&(s&&S.textureHalfFloatLinearFiltering||!s),z=(m===128||m===64&&!X)&&v?1:(m===64||m===128&&!v)&&X?2:0;let L,B=null;switch(m){case 128:{switch(z){case 1:L=y._GetFloatRGBAArrayBuffer,B=null;break;case 2:L=y._GetFloatAsHalfFloatRGBAArrayBuffer,B=y._GetFloatRGBAArrayBuffer;break;case 0:L=y._GetFloatAsUIntRGBAArrayBuffer,B=y._GetFloatRGBAArrayBuffer;break}break}default:{switch(z){case 1:L=y._GetHalfFloatAsFloatRGBAArrayBuffer,B=null;break;case 2:L=y._GetHalfFloatRGBAArrayBuffer,B=y._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:L=y._GetHalfFloatAsUIntRGBAArrayBuffer,B=y._GetHalfFloatAsFloatRGBAArrayBuffer;break}break}}t.type=z,O=L(p,_,r.byteOffset+b,A,r.buffer,F),f&&F==0&&f.push(B?B(p,_,r.byteOffset+b,A,r.buffer,F):O)}O&&e._uploadDataToTextureDirectly(t,O,R,F)}else if(o.isRGB)t.type=0,m===24?(t.format=4,A=p*_*3,G=y._GetRGBArrayBuffer(p,_,r.byteOffset+b,A,r.buffer,U,k,K),e._uploadDataToTextureDirectly(t,G,R,F)):(t.format=5,A=p*_*4,G=y._GetRGBAArrayBuffer(p,_,r.byteOffset+b,A,r.buffer,U,k,K,_e),e._uploadDataToTextureDirectly(t,G,R,F));else if(o.isLuminance){const O=e._getUnpackAlignement(),v=p;A=Math.floor((p+O-1)/O)*O*(_-1)+v,G=y._GetLuminanceArrayBuffer(p,_,r.byteOffset+b,A,r.buffer),t.format=1,t.type=0,e._uploadDataToTextureDirectly(t,G,R,F)}else A=Math.max(4,p)/4*Math.max(4,_)/4*C,G=new Uint8Array(r.buffer,r.byteOffset+b,A),t.type=0,e._uploadCompressedDataToTextureDirectly(t,I,p,_,G,R,F)}b+=m?p*_*(m/8):A,p*=.5,_*=.5,p=Math.max(1,p),_=Math.max(1,_)}if(l!==void 0)break}f&&f.length>0?o.sphericalPolynomial=we.ConvertCubeMapToSphericalPolynomial({size:u[Y],right:f[0],left:f[1],up:f[2],down:f[3],front:f[4],back:f[5],format:5,type:1,gammaSpace:!1}):o.sphericalPolynomial=void 0}}y.StoreLODInAlphaChannel=!1;const $e=Object.freeze(Object.defineProperty({__proto__:null,DDSTools:y},Symbol.toStringTag,{value:"Module"}));export{Ge as A,y as D,E as F,T,ze as a,$e as d};
