import{bT as v,L as U,V as f,am as E,b as B,aW as z,_ as C,P as G,bf as V}from"./main-e8601b72.js";import{C as k}from"./passPostProcess-99298d86.js";import"./dumpTools-d9c3a51e.js";v.prototype.forceSphericalPolynomialsRecompute=function(){this._texture&&(this._texture._sphericalPolynomial=null,this._texture._sphericalPolynomialPromise=null,this._texture._sphericalPolynomialComputed=!1)};Object.defineProperty(v.prototype,"sphericalPolynomial",{get:function(){if(this._texture){if(this._texture._sphericalPolynomial||this._texture._sphericalPolynomialComputed)return this._texture._sphericalPolynomial;if(this._texture.isReady)return this._texture._sphericalPolynomialPromise||(this._texture._sphericalPolynomialPromise=k.ConvertCubeMapTextureToSphericalPolynomial(this),this._texture._sphericalPolynomialPromise===null?this._texture._sphericalPolynomialComputed=!0:this._texture._sphericalPolynomialPromise.then(e=>{this._texture._sphericalPolynomial=e,this._texture._sphericalPolynomialComputed=!0})),null}return null},set:function(e){this._texture&&(this._texture._sphericalPolynomial=e)},enumerable:!0,configurable:!0});const P="image/png",F=2,D=[134,22,135,150,246,214,150,54];function q(e){const i=new DataView(e.buffer,e.byteOffset,e.byteLength);let t=0;for(let n=0;n<D.length;n++)if(i.getUint8(t++)!==D[n])return U.Error("Not a babylon environment map"),null;let a="",o=0;for(;o=i.getUint8(t++);)a+=String.fromCharCode(o);let r=JSON.parse(a);return r=I(r),r.binaryDataPosition=t,r.specular&&(r.specular.lodGenerationScale=r.specular.lodGenerationScale||.8),r}function I(e){if(e.version>F)throw new Error(`Unsupported babylon environment map version "${e.version}". Latest supported version is "${F}".`);return e.version===2||(e={...e,version:2,imageType:P}),e}function H(e,i){i=I(i);const t=i.specular;let a=Math.log2(i.width);if(a=Math.round(a)+1,t.mipmaps.length!==6*a)throw new Error(`Unsupported specular mipmaps number "${t.mipmaps.length}"`);const o=new Array(a);for(let r=0;r<a;r++){o[r]=new Array(6);for(let n=0;n<6;n++){const s=t.mipmaps[r*6+n];o[r][n]=new Uint8Array(e.buffer,e.byteOffset+i.binaryDataPosition+s.position,s.length)}}return o}function $(e,i){var o;i=I(i);const t=new Array(6),a=(o=i.irradiance)==null?void 0:o.irradianceTexture;if(a){if(a.faces.length!==6)throw new Error(`Incorrect irradiance texture faces number "${a.faces.length}"`);for(let r=0;r<6;r++){const n=a.faces[r];t[r]=new Uint8Array(e.buffer,e.byteOffset+i.binaryDataPosition+n.position,n.length)}}return t}function K(e,i,t){var s,d,u;t=I(t);const a=t.specular;if(!a)return Promise.resolve([]);e._lodGenerationScale=a.lodGenerationScale;const o=[],r=H(i,t);o.push(N(e,r,t.imageType));const n=(s=t.irradiance)==null?void 0:s.irradianceTexture;if(n){const h=$(i,t);let p=null;(u=(d=t.irradiance)==null?void 0:d.irradianceTexture)!=null&&u.dominantDirection&&(p=f.FromArray(t.irradiance.irradianceTexture.dominantDirection)),o.push(W(e,h,n.size,t.imageType,p))}return Promise.all(o)}async function S(e,i,t,a,o,r,n,s,d,u,h){return await new Promise((p,L)=>{if(t){const _=i.createTexture(null,!0,!0,null,1,null,l=>{L(l)},e);a==null||a.onEffectCreatedObservable.addOnce(l=>{l.executeWhenCompiled(()=>{a.externalTextureSamplerBinding=!0,a.onApply=c=>{c._bindTexture("textureSampler",_),c.setFloat2("scale",1,i._features.needsInvertingBitmap&&e instanceof ImageBitmap?-1:1)},i.scenes.length&&(i.scenes[0].postProcessManager.directRender([a],u,!0,r,n),i.restoreDefaultFramebuffer(),_.dispose(),URL.revokeObjectURL(o),p())})})}else{if(i._uploadImageToTexture(h,e,r,n),s){const _=d[n];_&&i._uploadImageToTexture(_._texture,e,r,0)}p()}})}async function N(e,i,t=P){const a=e.getEngine();e.format=5,e.type=0,e.generateMipMaps=!0,e._cachedAnisotropicFilteringLevel=null,a.updateTextureSamplingMode(3,e),await O(e,i,!0,t),e.isReady=!0}async function W(e,i,t,a=P,o=null){const r=e.getEngine(),n=new E(r,5),s=new v(r,n);e._irradianceTexture=s,s._dominantDirection=o,n.isCube=!0,n.format=5,n.type=0,n.generateMipMaps=!0,n._cachedAnisotropicFilteringLevel=null,n.generateMipMaps=!0,n.width=t,n.height=t,r.updateTextureSamplingMode(3,n),await O(n,[i],!1,a),r.generateMipMapsForCubemap(n),n.isReady=!0}async function O(e,i,t,a=P){if(!B.IsExponentOfTwo(e.width))throw new Error("Texture size must be a power of two");const o=z(e.width)+1,r=e.getEngine();let n=!1,s=!1,d=null,u=null,h=null;const p=r.getCaps();p.textureLOD?r._features.supportRenderAndCopyToLodForFloatTextures?p.textureHalfFloatRender&&p.textureHalfFloatLinearFiltering?(n=!0,e.type=2):p.textureFloatRender&&p.textureFloatLinearFiltering&&(n=!0,e.type=1):n=!1:(n=!1,s=t);let L=0;if(n)r.isWebGPU?(L=1,await C(()=>import("./rgbdDecode.fragment-4419b975.js"),["assets/rgbdDecode.fragment-4419b975.js","assets/main-e8601b72.js","assets/index-ad665221.css","assets/helperFunctions-60ac609f.js"])):await C(()=>import("./rgbdDecode.fragment-d8a067f2.js"),["assets/rgbdDecode.fragment-d8a067f2.js","assets/main-e8601b72.js","assets/index-ad665221.css"]),d=new G("rgbdDecode","rgbdDecode",null,null,1,null,3,r,!1,void 0,e.type,void 0,null,!1,void 0,L),e._isRGBD=!1,e.invertY=!1,u=r.createRenderTargetCubeTexture(e.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:e.type,format:5});else if(e._isRGBD=!0,e.invertY=!0,s){h={};const c=e._lodGenerationScale,T=e._lodGenerationOffset;for(let m=0;m<3;m++){const w=1-m/2,y=T,M=(o-1)*c+T,R=y+(M-y)*w,b=Math.round(Math.min(Math.max(R,0),M)),A=new E(r,2);A.isCube=!0,A.invertY=!0,A.generateMipMaps=!1,r.updateTextureSamplingMode(2,A);const x=new v(null);switch(x._isCube=!0,x._texture=A,h[b]=x,m){case 0:e._lodTextureLow=x;break;case 1:e._lodTextureMid=x;break;case 2:e._lodTextureHigh=x;break}}}const _=[];for(let l=0;l<i.length;l++)for(let c=0;c<6;c++){const T=i[l][c],m=new Blob([T],{type:a}),g=URL.createObjectURL(m);let w;if(r._features.forceBitmapOverHTMLImageElement)w=r.createImageBitmap(m,{premultiplyAlpha:"none"}).then(async y=>await S(y,r,n,d,g,c,l,s,h,u,e));else{const y=new Image;y.src=g,w=new Promise((M,R)=>{y.onload=()=>{S(y,r,n,d,g,c,l,s,h,u,e).then(()=>M()).catch(b=>{R(b)})},y.onerror=b=>{R(b)}})}_.push(w)}if(await Promise.all(_),i.length<o){let l;const c=Math.pow(2,o-1-i.length),T=c*c*4;switch(e.type){case 0:{l=new Uint8Array(T);break}case 2:{l=new Uint16Array(T);break}case 1:{l=new Float32Array(T);break}}for(let m=i.length;m<o;m++)for(let g=0;g<6;g++)r._uploadArrayBufferViewToTexture((u==null?void 0:u.texture)||e,l,g,m)}if(u){const l=e._irradianceTexture;e._irradianceTexture=null,r._releaseTexture(e),u._swapAndDie(e),e._irradianceTexture=l}d&&d.dispose(),s&&(e._lodTextureHigh&&e._lodTextureHigh._texture&&(e._lodTextureHigh._texture.isReady=!0),e._lodTextureMid&&e._lodTextureMid._texture&&(e._lodTextureMid._texture.isReady=!0),e._lodTextureLow&&e._lodTextureLow._texture&&(e._lodTextureLow._texture.isReady=!0))}function Q(e,i){i=I(i);const t=i.irradiance;if(!t)return;const a=new V;f.FromArrayToRef(t.x,0,a.x),f.FromArrayToRef(t.y,0,a.y),f.FromArrayToRef(t.z,0,a.z),f.FromArrayToRef(t.xx,0,a.xx),f.FromArrayToRef(t.yy,0,a.yy),f.FromArrayToRef(t.zz,0,a.zz),f.FromArrayToRef(t.yz,0,a.yz),f.FromArrayToRef(t.zx,0,a.zx),f.FromArrayToRef(t.xy,0,a.xy),e._sphericalPolynomial=a}export{H as C,q as G,Q as U,K as a};
