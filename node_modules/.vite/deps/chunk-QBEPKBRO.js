import {
  BackEase,
  EasingFunction,
  ExponentialEase
} from "./chunk-BBSZIY7X.js";
import {
  Animation
} from "./chunk-YBFJGP6R.js";
import {
  Mesh
} from "./chunk-KOU6SRWY.js";
import {
  EventConstants,
  KeyboardEventTypes
} from "./chunk-LQSBVTTC.js";
import {
  Camera
} from "./chunk-H2VNCWVE.js";
import {
  PointerEventTypes
} from "./chunk-U7FMMWAO.js";
import {
  Plane
} from "./chunk-TTVPVSK7.js";
import {
  Node
} from "./chunk-SQHPNIL3.js";
import {
  Tools
} from "./chunk-A25D3L3D.js";
import {
  Axis
} from "./chunk-IYYCNDOA.js";
import {
  SerializationHelper
} from "./chunk-RKGZOZHN.js";
import {
  __decorate,
  serialize,
  serializeAsMeshReference,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-PVEEDNYT.js";
import {
  PrecisionDate
} from "./chunk-AZNEH5GV.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import {
  Matrix,
  Quaternion,
  TmpVectors,
  Vector2,
  Vector3
} from "./chunk-MBRMNX5M.js";
import {
  Observable
} from "./chunk-2YUEJ7I2.js";
import {
  Epsilon
} from "./chunk-KA4NMM3C.js";
import {
  RegisterClass
} from "./chunk-S7NDMBDF.js";
import {
  Clamp
} from "./chunk-427EVWOG.js";

// node_modules/@babylonjs/core/Behaviors/Cameras/autoRotationBehavior.js
var AutoRotationBehavior = class {
  constructor() {
    this._zoomStopsAnimation = false;
    this._idleRotationSpeed = 0.05;
    this._idleRotationWaitTime = 2e3;
    this._idleRotationSpinupTime = 2e3;
    this.targetAlpha = null;
    this._isPointerDown = false;
    this._lastFrameTime = null;
    this._lastInteractionTime = -Infinity;
    this._cameraRotationSpeed = 0;
    this._lastFrameRadius = 0;
  }
  /**
   * Gets the name of the behavior.
   */
  get name() {
    return "AutoRotation";
  }
  /**
   * Sets the flag that indicates if user zooming should stop animation.
   */
  set zoomStopsAnimation(flag) {
    this._zoomStopsAnimation = flag;
  }
  /**
   * Gets the flag that indicates if user zooming should stop animation.
   */
  get zoomStopsAnimation() {
    return this._zoomStopsAnimation;
  }
  /**
   * Sets the default speed at which the camera rotates around the model.
   */
  set idleRotationSpeed(speed) {
    this._idleRotationSpeed = speed;
  }
  /**
   * Gets the default speed at which the camera rotates around the model.
   */
  get idleRotationSpeed() {
    return this._idleRotationSpeed;
  }
  /**
   * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.
   */
  set idleRotationWaitTime(time) {
    this._idleRotationWaitTime = time;
  }
  /**
   * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.
   */
  get idleRotationWaitTime() {
    return this._idleRotationWaitTime;
  }
  /**
   * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.
   */
  set idleRotationSpinupTime(time) {
    this._idleRotationSpinupTime = time;
  }
  /**
   * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.
   */
  get idleRotationSpinupTime() {
    return this._idleRotationSpinupTime;
  }
  /**
   * Gets a value indicating if the camera is currently rotating because of this behavior
   */
  get rotationInProgress() {
    return Math.abs(this._cameraRotationSpeed) > 0;
  }
  /**
   * Initializes the behavior.
   */
  init() {
  }
  /**
   * Attaches the behavior to its arc rotate camera.
   * @param camera Defines the camera to attach the behavior to
   */
  attach(camera) {
    this._attachedCamera = camera;
    const scene = this._attachedCamera.getScene();
    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {
      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {
        this._isPointerDown = true;
        return;
      }
      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {
        this._isPointerDown = false;
      }
    });
    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {
      if (this._reachTargetAlpha()) {
        return;
      }
      const now = PrecisionDate.Now;
      let dt = 0;
      if (this._lastFrameTime != null) {
        dt = now - this._lastFrameTime;
      }
      this._lastFrameTime = now;
      this._applyUserInteraction();
      const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;
      const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);
      this._cameraRotationSpeed = this._idleRotationSpeed * scale;
      if (this._attachedCamera) {
        this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1e3);
      }
    });
  }
  /**
   * Detaches the behavior from its current arc rotate camera.
   */
  detach() {
    if (!this._attachedCamera) {
      return;
    }
    const scene = this._attachedCamera.getScene();
    if (this._onPrePointerObservableObserver) {
      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);
    }
    this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
    this._attachedCamera = null;
    this._lastFrameTime = null;
  }
  /**
   * Force-reset the last interaction time
   * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`
   */
  resetLastInteractionTime(customTime) {
    this._lastInteractionTime = customTime ?? PrecisionDate.Now;
  }
  /**
   * Returns true if camera alpha reaches the target alpha
   * @returns true if camera alpha reaches the target alpha
   */
  _reachTargetAlpha() {
    if (this._attachedCamera && this.targetAlpha) {
      return Math.abs(this._attachedCamera.alpha - this.targetAlpha) < Epsilon;
    }
    return false;
  }
  /**
   * Returns true if user is scrolling.
   * @returns true if user is scrolling.
   */
  _userIsZooming() {
    if (!this._attachedCamera) {
      return false;
    }
    return this._attachedCamera.inertialRadiusOffset !== 0;
  }
  _shouldAnimationStopForInteraction() {
    if (!this._attachedCamera) {
      return false;
    }
    let zoomHasHitLimit = false;
    if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {
      zoomHasHitLimit = true;
    }
    this._lastFrameRadius = this._attachedCamera.radius;
    return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();
  }
  /**
   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
   */
  _applyUserInteraction() {
    if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {
      this._lastInteractionTime = PrecisionDate.Now;
    }
  }
  // Tools
  _userIsMoving() {
    if (!this._attachedCamera) {
      return false;
    }
    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;
  }
};

// node_modules/@babylonjs/core/Behaviors/Cameras/bouncingBehavior.js
var BouncingBehavior = class _BouncingBehavior {
  constructor() {
    this.transitionDuration = 450;
    this.lowerRadiusTransitionRange = 2;
    this.upperRadiusTransitionRange = -2;
    this._autoTransitionRange = false;
    this._radiusIsAnimating = false;
    this._radiusBounceTransition = null;
    this._animatables = new Array();
  }
  /**
   * Gets the name of the behavior.
   */
  get name() {
    return "Bouncing";
  }
  /**
   * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
   */
  get autoTransitionRange() {
    return this._autoTransitionRange;
  }
  /**
   * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
   * Transition ranges will be set to 5% of the bounding box diagonal in world space
   */
  set autoTransitionRange(value) {
    if (this._autoTransitionRange === value) {
      return;
    }
    this._autoTransitionRange = value;
    const camera = this._attachedCamera;
    if (!camera) {
      return;
    }
    if (value) {
      this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((transformNode) => {
        if (!transformNode) {
          return;
        }
        transformNode.computeWorldMatrix(true);
        if (transformNode.getBoundingInfo) {
          const diagonal = transformNode.getBoundingInfo().diagonalLength;
          this.lowerRadiusTransitionRange = diagonal * 0.05;
          this.upperRadiusTransitionRange = diagonal * 0.05;
        }
      });
    } else if (this._onMeshTargetChangedObserver) {
      camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
    }
  }
  /**
   * Initializes the behavior.
   */
  init() {
  }
  /**
   * Attaches the behavior to its arc rotate camera.
   * @param camera Defines the camera to attach the behavior to
   */
  attach(camera) {
    this._attachedCamera = camera;
    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {
      if (!this._attachedCamera) {
        return;
      }
      if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {
        this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);
      }
      if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {
        this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);
      }
    });
  }
  /**
   * Detaches the behavior from its current arc rotate camera.
   */
  detach() {
    if (!this._attachedCamera) {
      return;
    }
    if (this._onAfterCheckInputsObserver) {
      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
    }
    if (this._onMeshTargetChangedObserver) {
      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
    }
    this._attachedCamera = null;
  }
  /**
   * Checks if the camera radius is at the specified limit. Takes into account animation locks.
   * @param radiusLimit The limit to check against.
   * @returns Bool to indicate if at limit.
   */
  _isRadiusAtLimit(radiusLimit) {
    if (!this._attachedCamera) {
      return false;
    }
    if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {
      return true;
    }
    return false;
  }
  /**
   * Applies an animation to the radius of the camera, extending by the radiusDelta.
   * @param radiusDelta The delta by which to animate to. Can be negative.
   */
  _applyBoundRadiusAnimation(radiusDelta) {
    if (!this._attachedCamera) {
      return;
    }
    if (!this._radiusBounceTransition) {
      _BouncingBehavior.EasingFunction.setEasingMode(_BouncingBehavior.EasingMode);
      this._radiusBounceTransition = Animation.CreateAnimation("radius", Animation.ANIMATIONTYPE_FLOAT, 60, _BouncingBehavior.EasingFunction);
    }
    this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;
    this._attachedCamera.wheelPrecision = Infinity;
    this._attachedCamera.inertialRadiusOffset = 0;
    this.stopAllAnimations();
    this._radiusIsAnimating = true;
    const animatable = Animation.TransitionTo("radius", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, () => this._clearAnimationLocks());
    if (animatable) {
      this._animatables.push(animatable);
    }
  }
  /**
   * Removes all animation locks. Allows new animations to be added to any of the camera properties.
   */
  _clearAnimationLocks() {
    this._radiusIsAnimating = false;
    if (this._attachedCamera) {
      this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;
    }
  }
  /**
   * Stops and removes all animations that have been applied to the camera
   */
  stopAllAnimations() {
    if (this._attachedCamera) {
      this._attachedCamera.animations = [];
    }
    while (this._animatables.length) {
      this._animatables[0].onAnimationEnd = null;
      this._animatables[0].stop();
      this._animatables.shift();
    }
  }
};
BouncingBehavior.EasingFunction = new BackEase(0.3);
BouncingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEOUT;

// node_modules/@babylonjs/core/Behaviors/Cameras/framingBehavior.js
var FramingBehavior = class _FramingBehavior {
  constructor() {
    this.onTargetFramingAnimationEndObservable = new Observable();
    this._mode = _FramingBehavior.FitFrustumSidesMode;
    this._radiusScale = 1;
    this._positionScale = 0.5;
    this._defaultElevation = 0.3;
    this._elevationReturnTime = 1500;
    this._elevationReturnWaitTime = 1e3;
    this._zoomStopsAnimation = false;
    this._framingTime = 1500;
    this.autoCorrectCameraLimitsAndSensibility = true;
    this._isPointerDown = false;
    this._lastInteractionTime = -Infinity;
    this._animatables = new Array();
    this._betaIsAnimating = false;
  }
  /**
   * Gets the name of the behavior.
   */
  get name() {
    return "Framing";
  }
  /**
   * Sets the current mode used by the behavior
   */
  set mode(mode) {
    this._mode = mode;
  }
  /**
   * Gets current mode used by the behavior.
   */
  get mode() {
    return this._mode;
  }
  /**
   * Sets the scale applied to the radius (1 by default)
   */
  set radiusScale(radius) {
    this._radiusScale = radius;
  }
  /**
   * Gets the scale applied to the radius
   */
  get radiusScale() {
    return this._radiusScale;
  }
  /**
   * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
   */
  set positionScale(scale) {
    this._positionScale = scale;
  }
  /**
   * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
   */
  get positionScale() {
    return this._positionScale;
  }
  /**
   * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle
   * behaviour is triggered, in radians.
   */
  set defaultElevation(elevation) {
    this._defaultElevation = elevation;
  }
  /**
   * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle
   * behaviour is triggered, in radians.
   */
  get defaultElevation() {
    return this._defaultElevation;
  }
  /**
   * Sets the time (in milliseconds) taken to return to the default beta position.
   * Negative value indicates camera should not return to default.
   */
  set elevationReturnTime(speed) {
    this._elevationReturnTime = speed;
  }
  /**
   * Gets the time (in milliseconds) taken to return to the default beta position.
   * Negative value indicates camera should not return to default.
   */
  get elevationReturnTime() {
    return this._elevationReturnTime;
  }
  /**
   * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.
   */
  set elevationReturnWaitTime(time) {
    this._elevationReturnWaitTime = time;
  }
  /**
   * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.
   */
  get elevationReturnWaitTime() {
    return this._elevationReturnWaitTime;
  }
  /**
   * Sets the flag that indicates if user zooming should stop animation.
   */
  set zoomStopsAnimation(flag) {
    this._zoomStopsAnimation = flag;
  }
  /**
   * Gets the flag that indicates if user zooming should stop animation.
   */
  get zoomStopsAnimation() {
    return this._zoomStopsAnimation;
  }
  /**
   * Sets the transition time when framing the mesh, in milliseconds
   */
  set framingTime(time) {
    this._framingTime = time;
  }
  /**
   * Gets the transition time when framing the mesh, in milliseconds
   */
  get framingTime() {
    return this._framingTime;
  }
  /**
   * Initializes the behavior.
   */
  init() {
  }
  /**
   * Attaches the behavior to its arc rotate camera.
   * @param camera Defines the camera to attach the behavior to
   */
  attach(camera) {
    this._attachedCamera = camera;
    const scene = this._attachedCamera.getScene();
    _FramingBehavior.EasingFunction.setEasingMode(_FramingBehavior.EasingMode);
    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {
      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {
        this._isPointerDown = true;
        return;
      }
      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {
        this._isPointerDown = false;
      }
    });
    this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((transformNode) => {
      if (transformNode && transformNode.getBoundingInfo) {
        this.zoomOnMesh(transformNode, void 0, () => {
          this.onTargetFramingAnimationEndObservable.notifyObservers();
        });
      }
    });
    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {
      this._applyUserInteraction();
      this._maintainCameraAboveGround();
    });
  }
  /**
   * Detaches the behavior from its current arc rotate camera.
   */
  detach() {
    if (!this._attachedCamera) {
      return;
    }
    const scene = this._attachedCamera.getScene();
    if (this._onPrePointerObservableObserver) {
      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);
    }
    if (this._onAfterCheckInputsObserver) {
      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
    }
    if (this._onMeshTargetChangedObserver) {
      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
    }
    this._attachedCamera = null;
  }
  /**
   * Targets the given mesh and updates zoom level accordingly.
   * @param mesh  The mesh to target.
   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
   * @param onAnimationEnd Callback triggered at the end of the framing animation
   */
  zoomOnMesh(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {
    mesh.computeWorldMatrix(true);
    const boundingBox = mesh.getBoundingInfo().boundingBox;
    this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);
  }
  /**
   * Targets the given mesh with its children and updates zoom level accordingly.
   * @param mesh The mesh to target.
   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
   * @param onAnimationEnd Callback triggered at the end of the framing animation
   */
  zoomOnMeshHierarchy(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {
    mesh.computeWorldMatrix(true);
    const boundingBox = mesh.getHierarchyBoundingVectors(true);
    this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);
  }
  /**
   * Targets the given meshes with their children and updates zoom level accordingly.
   * @param meshes  The mesh to target.
   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
   * @param onAnimationEnd Callback triggered at the end of the framing animation
   */
  zoomOnMeshesHierarchy(meshes, focusOnOriginXZ = false, onAnimationEnd = null) {
    const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (let i = 0; i < meshes.length; i++) {
      const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);
      Vector3.CheckExtends(boundingInfo.min, min, max);
      Vector3.CheckExtends(boundingInfo.max, min, max);
    }
    this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);
  }
  /**
   * Targets the bounding box info defined by its extends and updates zoom level accordingly.
   * @param minimumWorld Determines the smaller position of the bounding box extend
   * @param maximumWorld Determines the bigger position of the bounding box extend
   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
   * @param onAnimationEnd Callback triggered at the end of the framing animation
   * @returns true if the zoom was done
   */
  zoomOnBoundingInfo(minimumWorld, maximumWorld, focusOnOriginXZ = false, onAnimationEnd = null) {
    let zoomTarget;
    if (!this._attachedCamera) {
      return false;
    }
    const bottom = minimumWorld.y;
    const top = maximumWorld.y;
    const zoomTargetY = bottom + (top - bottom) * this._positionScale;
    const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);
    if (!isFinite(zoomTargetY)) {
      return false;
    }
    if (focusOnOriginXZ) {
      zoomTarget = new Vector3(0, zoomTargetY, 0);
    } else {
      const centerWorld = minimumWorld.add(radiusWorld);
      zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);
    }
    if (!this._vectorTransition) {
      this._vectorTransition = Animation.CreateAnimation("target", Animation.ANIMATIONTYPE_VECTOR3, 60, _FramingBehavior.EasingFunction);
    }
    this._betaIsAnimating = true;
    let animatable = Animation.TransitionTo("target", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);
    if (animatable) {
      this._animatables.push(animatable);
    }
    let radius = 0;
    if (this._mode === _FramingBehavior.FitFrustumSidesMode) {
      const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);
      if (this.autoCorrectCameraLimitsAndSensibility) {
        this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;
      }
      radius = position;
    } else if (this._mode === _FramingBehavior.IgnoreBoundsSizeMode) {
      radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);
      if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {
        this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;
      }
    }
    if (this.autoCorrectCameraLimitsAndSensibility) {
      const extend = maximumWorld.subtract(minimumWorld).length();
      this._attachedCamera.panningSensibility = 5e3 / extend;
      this._attachedCamera.wheelPrecision = 100 / radius;
    }
    if (!this._radiusTransition) {
      this._radiusTransition = Animation.CreateAnimation("radius", Animation.ANIMATIONTYPE_FLOAT, 60, _FramingBehavior.EasingFunction);
    }
    animatable = Animation.TransitionTo("radius", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {
      this.stopAllAnimations();
      if (onAnimationEnd) {
        onAnimationEnd();
      }
      if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {
        this._attachedCamera.storeState();
      }
    });
    if (animatable) {
      this._animatables.push(animatable);
    }
    return true;
  }
  /**
   * Calculates the lowest radius for the camera based on the bounding box of the mesh.
   * @param minimumWorld
   * @param maximumWorld
   * @returns The minimum distance from the primary mesh's center point at which the camera must be kept in order
   *		 to fully enclose the mesh in the viewing frustum.
   */
  _calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld) {
    const camera = this._attachedCamera;
    if (!camera) {
      return 0;
    }
    let distance = camera._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld, this._radiusScale);
    if (camera.lowerRadiusLimit && this._mode === _FramingBehavior.IgnoreBoundsSizeMode) {
      distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;
    }
    if (camera.upperRadiusLimit) {
      distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;
    }
    return distance;
  }
  /**
   * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera
   * is automatically returned to its default position (expected to be above ground plane).
   */
  _maintainCameraAboveGround() {
    if (this._elevationReturnTime < 0) {
      return;
    }
    const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;
    const defaultBeta = Math.PI * 0.5 - this._defaultElevation;
    const limitBeta = Math.PI * 0.5;
    if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {
      this._betaIsAnimating = true;
      this.stopAllAnimations();
      if (!this._betaTransition) {
        this._betaTransition = Animation.CreateAnimation("beta", Animation.ANIMATIONTYPE_FLOAT, 60, _FramingBehavior.EasingFunction);
      }
      const animatable = Animation.TransitionTo("beta", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, () => {
        this._clearAnimationLocks();
        this.stopAllAnimations();
      });
      if (animatable) {
        this._animatables.push(animatable);
      }
    }
  }
  /**
   * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.
   */
  _clearAnimationLocks() {
    this._betaIsAnimating = false;
  }
  /**
   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
   */
  _applyUserInteraction() {
    if (this.isUserIsMoving) {
      this._lastInteractionTime = PrecisionDate.Now;
      this.stopAllAnimations();
      this._clearAnimationLocks();
    }
  }
  /**
   * Stops and removes all animations that have been applied to the camera
   */
  stopAllAnimations() {
    if (this._attachedCamera) {
      this._attachedCamera.animations = [];
    }
    while (this._animatables.length) {
      if (this._animatables[0]) {
        this._animatables[0].onAnimationEnd = null;
        this._animatables[0].stop();
      }
      this._animatables.shift();
    }
  }
  /**
   * Gets a value indicating if the user is moving the camera
   */
  get isUserIsMoving() {
    if (!this._attachedCamera) {
      return false;
    }
    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;
  }
};
FramingBehavior.EasingFunction = new ExponentialEase();
FramingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEINOUT;
FramingBehavior.IgnoreBoundsSizeMode = 0;
FramingBehavior.FitFrustumSidesMode = 1;

// node_modules/@babylonjs/core/Cameras/targetCamera.js
Node.AddNodeConstructor("TargetCamera", (name, scene) => {
  return () => new TargetCamera(name, Vector3.Zero(), scene);
});
var TmpMatrix = Matrix.Zero();
var TmpQuaternion = Quaternion.Identity();
var TargetCamera = class _TargetCamera extends Camera {
  /**
   * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.
   * This is the base of the follow, arc rotate cameras and Free camera
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras
   * @param name Defines the name of the camera in the scene
   * @param position Defines the start position of the camera in the scene
   * @param scene Defines the scene the camera belongs to
   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined
   */
  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {
    super(name, position, scene, setActiveOnSceneIfNoneActive);
    this.cameraDirection = new Vector3(0, 0, 0);
    this.cameraRotation = new Vector2(0, 0);
    this.updateUpVectorFromRotation = false;
    this.speed = 2;
    this.noRotationConstraint = false;
    this.invertRotation = false;
    this.inverseRotationSpeed = 0.2;
    this._panningEpsilon = Epsilon;
    this._rotationEpsilon = Epsilon;
    this.lockedTarget = null;
    this._currentTarget = Vector3.Zero();
    this._initialFocalDistance = 1;
    this._viewMatrix = Matrix.Zero();
    this._cameraTransformMatrix = Matrix.Zero();
    this._cameraRotationMatrix = Matrix.Zero();
    this._transformedReferencePoint = Vector3.Zero();
    this._deferredPositionUpdate = new Vector3();
    this._deferredRotationQuaternionUpdate = new Quaternion();
    this._deferredRotationUpdate = new Vector3();
    this._deferredUpdated = false;
    this._deferOnly = false;
    this._cachedRotationZ = 0;
    this._cachedQuaternionRotationZ = 0;
    this._referencePoint = Vector3.Forward(this.getScene().useRightHandedSystem);
    this.rotation = new Vector3(0, this.getScene().useRightHandedSystem ? Math.PI : 0, 0);
  }
  /**
   * Gets the position in front of the camera at a given distance.
   * @param distance The distance from the camera we want the position to be
   * @returns the position
   */
  getFrontPosition(distance) {
    this.getWorldMatrix();
    const worldForward = TmpVectors.Vector3[0];
    const localForward = TmpVectors.Vector3[1];
    localForward.set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
    this.getDirectionToRef(localForward, worldForward);
    worldForward.scaleInPlace(distance);
    return this.globalPosition.add(worldForward);
  }
  /** @internal */
  _getLockedTargetPosition() {
    if (!this.lockedTarget) {
      return null;
    }
    if (this.lockedTarget.absolutePosition) {
      const lockedTarget = this.lockedTarget;
      const m = lockedTarget.computeWorldMatrix();
      m.getTranslationToRef(lockedTarget.absolutePosition);
    }
    return this.lockedTarget.absolutePosition || this.lockedTarget;
  }
  /**
   * Store current camera state of the camera (fov, position, rotation, etc..)
   * @returns the camera
   */
  storeState() {
    this._storedPosition = this.position.clone();
    this._storedRotation = this.rotation.clone();
    if (this.rotationQuaternion) {
      this._storedRotationQuaternion = this.rotationQuaternion.clone();
    }
    return super.storeState();
  }
  /**
   * Restored camera state. You must call storeState() first
   * @returns whether it was successful or not
   * @internal
   */
  _restoreStateValues() {
    if (!super._restoreStateValues()) {
      return false;
    }
    this.position = this._storedPosition.clone();
    this.rotation = this._storedRotation.clone();
    if (this.rotationQuaternion) {
      this.rotationQuaternion = this._storedRotationQuaternion.clone();
    }
    this.cameraDirection.copyFromFloats(0, 0, 0);
    this.cameraRotation.copyFromFloats(0, 0);
    return true;
  }
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  }
  /**
   * @internal
   */
  _updateCache(ignoreParentClass) {
    if (!ignoreParentClass) {
      super._updateCache();
    }
    const lockedTargetPosition = this._getLockedTargetPosition();
    if (!lockedTargetPosition) {
      this._cache.lockedTarget = null;
    } else {
      if (!this._cache.lockedTarget) {
        this._cache.lockedTarget = lockedTargetPosition.clone();
      } else {
        this._cache.lockedTarget.copyFrom(lockedTargetPosition);
      }
    }
    this._cache.rotation.copyFrom(this.rotation);
    if (this.rotationQuaternion) {
      this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);
    }
  }
  // Synchronized
  /** @internal */
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronizedViewMatrix()) {
      return false;
    }
    const lockedTargetPosition = this._getLockedTargetPosition();
    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));
  }
  // Methods
  /** @internal */
  _computeLocalCameraSpeed() {
    const engine = this.getEngine();
    return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100));
  }
  // Target
  /**
   * Defines the target the camera should look at.
   * @param target Defines the new target as a Vector
   */
  setTarget(target) {
    this.upVector.normalize();
    this._initialFocalDistance = target.subtract(this.position).length();
    if (this.position.z === target.z) {
      this.position.z += Epsilon;
    }
    this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);
    if (this.getScene().useRightHandedSystem) {
      Matrix.LookAtRHToRef(this.position, target, Vector3.UpReadOnly, TmpMatrix);
    } else {
      Matrix.LookAtLHToRef(this.position, target, Vector3.UpReadOnly, TmpMatrix);
    }
    TmpMatrix.invert();
    const rotationQuaternion = this.rotationQuaternion || TmpQuaternion;
    Quaternion.FromRotationMatrixToRef(TmpMatrix, rotationQuaternion);
    rotationQuaternion.toEulerAnglesToRef(this.rotation);
    this.rotation.z = 0;
  }
  /**
   * Defines the target point of the camera.
   * The camera looks towards it form the radius distance.
   */
  get target() {
    return this.getTarget();
  }
  set target(value) {
    this.setTarget(value);
  }
  /**
   * Return the current target position of the camera. This value is expressed in local space.
   * @returns the target position
   */
  getTarget() {
    return this._currentTarget;
  }
  /** @internal */
  _decideIfNeedsToMove() {
    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  }
  /** @internal */
  _updatePosition() {
    if (this.parent) {
      this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);
      Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);
      this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);
      if (!this._deferOnly) {
        this.position.copyFrom(this._deferredPositionUpdate);
      } else {
        this._deferredUpdated = true;
      }
      return;
    }
    this._deferredPositionUpdate.addInPlace(this.cameraDirection);
    if (!this._deferOnly) {
      this.position.copyFrom(this._deferredPositionUpdate);
    } else {
      this._deferredUpdated = true;
    }
  }
  /** @internal */
  _checkInputs() {
    const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1;
    const needToMove = this._decideIfNeedsToMove();
    const needToRotate = this.cameraRotation.x || this.cameraRotation.y;
    this._deferredUpdated = false;
    this._deferredRotationUpdate.copyFrom(this.rotation);
    this._deferredPositionUpdate.copyFrom(this.position);
    if (this.rotationQuaternion) {
      this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);
    }
    if (needToMove) {
      this._updatePosition();
    }
    if (needToRotate) {
      if (this.rotationQuaternion) {
        this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);
      }
      this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;
      this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;
      if (!this.noRotationConstraint) {
        const limit = 1.570796;
        if (this._deferredRotationUpdate.x > limit) {
          this._deferredRotationUpdate.x = limit;
        }
        if (this._deferredRotationUpdate.x < -limit) {
          this._deferredRotationUpdate.x = -limit;
        }
      }
      if (!this._deferOnly) {
        this.rotation.copyFrom(this._deferredRotationUpdate);
      } else {
        this._deferredUpdated = true;
      }
      if (this.rotationQuaternion) {
        const len = this._deferredRotationUpdate.lengthSquared();
        if (len) {
          Quaternion.RotationYawPitchRollToRef(this._deferredRotationUpdate.y, this._deferredRotationUpdate.x, this._deferredRotationUpdate.z, this._deferredRotationQuaternionUpdate);
          if (!this._deferOnly) {
            this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);
          } else {
            this._deferredUpdated = true;
          }
        }
      }
    }
    const inertialPanningLimit = this.speed * this._panningEpsilon;
    const inertialRotationLimit = this.speed * this._rotationEpsilon;
    if (needToMove) {
      if (Math.abs(this.cameraDirection.x) < inertialPanningLimit) {
        this.cameraDirection.x = 0;
      }
      if (Math.abs(this.cameraDirection.y) < inertialPanningLimit) {
        this.cameraDirection.y = 0;
      }
      if (Math.abs(this.cameraDirection.z) < inertialPanningLimit) {
        this.cameraDirection.z = 0;
      }
      this.cameraDirection.scaleInPlace(this.inertia);
    }
    if (needToRotate) {
      if (Math.abs(this.cameraRotation.x) < inertialRotationLimit) {
        this.cameraRotation.x = 0;
      }
      if (Math.abs(this.cameraRotation.y) < inertialRotationLimit) {
        this.cameraRotation.y = 0;
      }
      this.cameraRotation.scaleInPlace(this.inertia);
    }
    super._checkInputs();
  }
  _updateCameraRotationMatrix() {
    if (this.rotationQuaternion) {
      this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);
    } else {
      Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
    }
  }
  /**
   * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)
   * @returns the current camera
   */
  _rotateUpVectorWithCameraRotationMatrix() {
    Vector3.TransformNormalToRef(Vector3.UpReadOnly, this._cameraRotationMatrix, this.upVector);
    return this;
  }
  /** @internal */
  _getViewMatrix() {
    if (this.lockedTarget) {
      this.setTarget(this._getLockedTargetPosition());
    }
    this._updateCameraRotationMatrix();
    if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {
      this._rotateUpVectorWithCameraRotationMatrix();
      this._cachedQuaternionRotationZ = this.rotationQuaternion.z;
    } else if (this._cachedRotationZ !== this.rotation.z) {
      this._rotateUpVectorWithCameraRotationMatrix();
      this._cachedRotationZ = this.rotation.z;
    }
    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);
    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
    if (this.updateUpVectorFromRotation) {
      if (this.rotationQuaternion) {
        Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);
      } else {
        Quaternion.FromEulerVectorToRef(this.rotation, TmpQuaternion);
        Axis.Y.rotateByQuaternionToRef(TmpQuaternion, this.upVector);
      }
    }
    this._computeViewMatrix(this.position, this._currentTarget, this.upVector);
    return this._viewMatrix;
  }
  _computeViewMatrix(position, target, up) {
    if (this.getScene().useRightHandedSystem) {
      Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);
    } else {
      Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);
    }
    if (this.parent) {
      const parentWorldMatrix = this.parent.getWorldMatrix();
      this._viewMatrix.invert();
      this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);
      this._viewMatrix.getTranslationToRef(this._globalPosition);
      this._viewMatrix.invert();
      this._markSyncedWithParent();
    } else {
      this._globalPosition.copyFrom(position);
    }
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createRigCamera(name, cameraIndex) {
    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
      const rigCamera = new _TargetCamera(name, this.position.clone(), this.getScene());
      rigCamera.isRigCamera = true;
      rigCamera.rigParent = this;
      if (this.cameraRigMode === Camera.RIG_MODE_VR) {
        if (!this.rotationQuaternion) {
          this.rotationQuaternion = new Quaternion();
        }
        rigCamera._cameraRigParams = {};
        rigCamera.rotationQuaternion = new Quaternion();
      }
      rigCamera.mode = this.mode;
      rigCamera.orthoLeft = this.orthoLeft;
      rigCamera.orthoRight = this.orthoRight;
      rigCamera.orthoTop = this.orthoTop;
      rigCamera.orthoBottom = this.orthoBottom;
      return rigCamera;
    }
    return null;
  }
  /**
   * @internal
   */
  _updateRigCameras() {
    const camLeft = this._rigCameras[0];
    const camRight = this._rigCameras[1];
    this.computeWorldMatrix();
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {
        const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;
        const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);
        break;
      }
      case Camera.RIG_MODE_VR:
        if (camLeft.rotationQuaternion) {
          camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);
          camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);
        } else {
          camLeft.rotation.copyFrom(this.rotation);
          camRight.rotation.copyFrom(this.rotation);
        }
        camLeft.position.copyFrom(this.position);
        camRight.position.copyFrom(this.position);
        break;
    }
    super._updateRigCameras();
  }
  _getRigCamPositionAndTarget(halfSpace, rigCamera) {
    const target = this.getTarget();
    target.subtractToRef(this.position, _TargetCamera._TargetFocalPoint);
    _TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
    const newFocalTarget = _TargetCamera._TargetFocalPoint.addInPlace(this.position);
    Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, _TargetCamera._TargetTransformMatrix);
    _TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), _TargetCamera._RigCamTransformMatrix);
    Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, _TargetCamera._TargetTransformMatrix);
    _TargetCamera._RigCamTransformMatrix.multiplyToRef(_TargetCamera._TargetTransformMatrix, _TargetCamera._RigCamTransformMatrix);
    Vector3.TransformCoordinatesToRef(this.position, _TargetCamera._RigCamTransformMatrix, rigCamera.position);
    rigCamera.setTarget(newFocalTarget);
  }
  /**
   * Gets the current object class name.
   * @returns the class name
   */
  getClassName() {
    return "TargetCamera";
  }
};
TargetCamera._RigCamTransformMatrix = new Matrix();
TargetCamera._TargetTransformMatrix = new Matrix();
TargetCamera._TargetFocalPoint = new Vector3();
__decorate([
  serialize()
], TargetCamera.prototype, "updateUpVectorFromRotation", void 0);
__decorate([
  serializeAsVector3()
], TargetCamera.prototype, "rotation", void 0);
__decorate([
  serialize()
], TargetCamera.prototype, "speed", void 0);
__decorate([
  serializeAsMeshReference("lockedTargetId")
], TargetCamera.prototype, "lockedTarget", void 0);

// node_modules/@babylonjs/core/Cameras/cameraInputsManager.js
var CameraInputTypes = {};
var CameraInputsManager = class {
  /**
   * Instantiate a new Camera Input Manager.
   * @param camera Defines the camera the input manager belongs to
   */
  constructor(camera) {
    this.attachedToElement = false;
    this.attached = {};
    this.camera = camera;
    this.checkInputs = () => {
    };
  }
  /**
   * Add an input method to a camera
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs
   * @param input Camera input method
   */
  add(input) {
    const type = input.getSimpleName();
    if (this.attached[type]) {
      Logger.Warn("camera input of type " + type + " already exists on camera");
      return;
    }
    this.attached[type] = input;
    input.camera = this.camera;
    if (input.checkInputs) {
      this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
    }
    if (this.attachedToElement) {
      input.attachControl(this.noPreventDefault);
    }
  }
  /**
   * Remove a specific input method from a camera
   * example: camera.inputs.remove(camera.inputs.attached.mouse);
   * @param inputToRemove camera input method
   */
  remove(inputToRemove) {
    for (const cam in this.attached) {
      const input = this.attached[cam];
      if (input === inputToRemove) {
        input.detachControl();
        input.camera = null;
        delete this.attached[cam];
        this.rebuildInputCheck();
        return;
      }
    }
  }
  /**
   * Remove a specific input type from a camera
   * example: camera.inputs.remove("ArcRotateCameraGamepadInput");
   * @param inputType the type of the input to remove
   */
  removeByType(inputType) {
    for (const cam in this.attached) {
      const input = this.attached[cam];
      if (input.getClassName() === inputType) {
        input.detachControl();
        input.camera = null;
        delete this.attached[cam];
        this.rebuildInputCheck();
      }
    }
  }
  _addCheckInputs(fn) {
    const current = this.checkInputs;
    return () => {
      current();
      fn();
    };
  }
  /**
   * Attach the input controls to the currently attached dom element to listen the events from.
   * @param input Defines the input to attach
   */
  attachInput(input) {
    if (this.attachedToElement) {
      input.attachControl(this.noPreventDefault);
    }
  }
  /**
   * Attach the current manager inputs controls to a specific dom element to listen the events from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachElement(noPreventDefault = false) {
    if (this.attachedToElement) {
      return;
    }
    noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;
    this.attachedToElement = true;
    this.noPreventDefault = noPreventDefault;
    for (const cam in this.attached) {
      this.attached[cam].attachControl(noPreventDefault);
    }
  }
  /**
   * Detach the current manager inputs controls from a specific dom element.
   * @param disconnect Defines whether the input should be removed from the current list of attached inputs
   */
  detachElement(disconnect = false) {
    for (const cam in this.attached) {
      this.attached[cam].detachControl();
      if (disconnect) {
        this.attached[cam].camera = null;
      }
    }
    this.attachedToElement = false;
  }
  /**
   * Rebuild the dynamic inputCheck function from the current list of
   * defined inputs in the manager.
   */
  rebuildInputCheck() {
    this.checkInputs = () => {
    };
    for (const cam in this.attached) {
      const input = this.attached[cam];
      if (input.checkInputs) {
        this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
      }
    }
  }
  /**
   * Remove all attached input methods from a camera
   */
  clear() {
    if (this.attachedToElement) {
      this.detachElement(true);
    }
    this.attached = {};
    this.attachedToElement = false;
    this.checkInputs = () => {
    };
  }
  /**
   * Serialize the current input manager attached to a camera.
   * This ensures than once parsed,
   * the input associated to the camera will be identical to the current ones
   * @param serializedCamera Defines the camera serialization JSON the input serialization should write to
   */
  serialize(serializedCamera) {
    const inputs = {};
    for (const cam in this.attached) {
      const input = this.attached[cam];
      const res = SerializationHelper.Serialize(input);
      inputs[input.getClassName()] = res;
    }
    serializedCamera.inputsmgr = inputs;
  }
  /**
   * Parses an input manager serialized JSON to restore the previous list of inputs
   * and states associated to a camera.
   * @param parsedCamera Defines the JSON to parse
   */
  parse(parsedCamera) {
    const parsedInputs = parsedCamera.inputsmgr;
    if (parsedInputs) {
      this.clear();
      for (const n in parsedInputs) {
        const construct = CameraInputTypes[n];
        if (construct) {
          const parsedinput = parsedInputs[n];
          const input = SerializationHelper.Parse(() => {
            return new construct();
          }, parsedinput, null);
          this.add(input);
        }
      }
    } else {
      for (const n in this.attached) {
        const construct = CameraInputTypes[this.attached[n].getClassName()];
        if (construct) {
          const input = SerializationHelper.Parse(() => {
            return new construct();
          }, parsedCamera, null);
          this.remove(this.attached[n]);
          this.add(input);
        }
      }
    }
  }
};

// node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraPointersInput.js
var BaseCameraPointersInput = class {
  constructor() {
    this._currentMousePointerIdDown = -1;
    this.buttons = [0, 1, 2];
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    const engine = this.camera.getEngine();
    const element = engine.getInputElement();
    let previousPinchSquaredDistance = 0;
    let previousMultiTouchPanPosition = null;
    this._pointA = null;
    this._pointB = null;
    this._altKey = false;
    this._ctrlKey = false;
    this._metaKey = false;
    this._shiftKey = false;
    this._buttonsPressed = 0;
    this._pointerInput = (p) => {
      var _a, _b;
      const evt = p.event;
      const isTouch = evt.pointerType === "touch";
      if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {
        return;
      }
      const srcElement = evt.target;
      this._altKey = evt.altKey;
      this._ctrlKey = evt.ctrlKey;
      this._metaKey = evt.metaKey;
      this._shiftKey = evt.shiftKey;
      this._buttonsPressed = evt.buttons;
      if (engine.isPointerLock) {
        const offsetX = evt.movementX;
        const offsetY = evt.movementY;
        this.onTouch(null, offsetX, offsetY);
        this._pointA = null;
        this._pointB = null;
      } else if (p.type !== PointerEventTypes.POINTERDOWN && p.type !== PointerEventTypes.POINTERDOUBLETAP && isTouch && ((_a = this._pointA) == null ? void 0 : _a.pointerId) !== evt.pointerId && ((_b = this._pointB) == null ? void 0 : _b.pointerId) !== evt.pointerId) {
        return;
      } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentMousePointerIdDown === -1 || isTouch)) {
        try {
          srcElement == null ? void 0 : srcElement.setPointerCapture(evt.pointerId);
        } catch (e) {
        }
        if (this._pointA === null) {
          this._pointA = {
            x: evt.clientX,
            y: evt.clientY,
            pointerId: evt.pointerId,
            type: evt.pointerType,
            button: evt.button
          };
        } else if (this._pointB === null) {
          this._pointB = {
            x: evt.clientX,
            y: evt.clientY,
            pointerId: evt.pointerId,
            type: evt.pointerType,
            button: evt.button
          };
        } else {
          return;
        }
        if (this._currentMousePointerIdDown === -1 && !isTouch) {
          this._currentMousePointerIdDown = evt.pointerId;
        }
        this.onButtonDown(evt);
        if (!noPreventDefault) {
          evt.preventDefault();
          if (element) {
            element.focus();
          }
        }
      } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {
        this.onDoubleTap(evt.pointerType);
      } else if (p.type === PointerEventTypes.POINTERUP && (this._currentMousePointerIdDown === evt.pointerId || isTouch)) {
        try {
          srcElement == null ? void 0 : srcElement.releasePointerCapture(evt.pointerId);
        } catch (e) {
        }
        if (!isTouch) {
          this._pointB = null;
        }
        if (engine._badOS) {
          this._pointA = this._pointB = null;
        } else {
          if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {
            this._pointA = this._pointB;
            this._pointB = null;
          } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {
            this._pointB = null;
          } else {
            this._pointA = this._pointB = null;
          }
        }
        if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {
          this.onMultiTouch(
            this._pointA,
            this._pointB,
            previousPinchSquaredDistance,
            0,
            // pinchSquaredDistance
            previousMultiTouchPanPosition,
            null
            // multiTouchPanPosition
          );
          previousPinchSquaredDistance = 0;
          previousMultiTouchPanPosition = null;
        }
        this._currentMousePointerIdDown = -1;
        this.onButtonUp(evt);
        if (!noPreventDefault) {
          evt.preventDefault();
        }
      } else if (p.type === PointerEventTypes.POINTERMOVE) {
        if (!noPreventDefault) {
          evt.preventDefault();
        }
        if (this._pointA && this._pointB === null) {
          const offsetX = evt.clientX - this._pointA.x;
          const offsetY = evt.clientY - this._pointA.y;
          this._pointA.x = evt.clientX;
          this._pointA.y = evt.clientY;
          this.onTouch(this._pointA, offsetX, offsetY);
        } else if (this._pointA && this._pointB) {
          const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;
          ed.x = evt.clientX;
          ed.y = evt.clientY;
          const distX = this._pointA.x - this._pointB.x;
          const distY = this._pointA.y - this._pointB.y;
          const pinchSquaredDistance = distX * distX + distY * distY;
          const multiTouchPanPosition = {
            x: (this._pointA.x + this._pointB.x) / 2,
            y: (this._pointA.y + this._pointB.y) / 2,
            pointerId: evt.pointerId,
            type: p.type
          };
          this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);
          previousMultiTouchPanPosition = multiTouchPanPosition;
          previousPinchSquaredDistance = pinchSquaredDistance;
        }
      }
    };
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP);
    this._onLostFocus = () => {
      this._pointA = this._pointB = null;
      previousPinchSquaredDistance = 0;
      previousMultiTouchPanPosition = null;
      this.onLostFocus();
    };
    this._contextMenuBind = (evt) => this.onContextMenu(evt);
    if (element) {
      element.addEventListener("contextmenu", this._contextMenuBind, false);
    }
    const hostWindow = this.camera.getScene().getEngine().getHostWindow();
    if (hostWindow) {
      Tools.RegisterTopRootEvents(hostWindow, [{ name: "blur", handler: this._onLostFocus }]);
    }
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    if (this._onLostFocus) {
      const hostWindow = this.camera.getScene().getEngine().getHostWindow();
      if (hostWindow) {
        Tools.UnregisterTopRootEvents(hostWindow, [{ name: "blur", handler: this._onLostFocus }]);
      }
    }
    if (this._observer) {
      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
      this._observer = null;
      if (this._contextMenuBind) {
        const inputElement = this.camera.getScene().getEngine().getInputElement();
        if (inputElement) {
          inputElement.removeEventListener("contextmenu", this._contextMenuBind);
        }
      }
      this._onLostFocus = null;
    }
    this._altKey = false;
    this._ctrlKey = false;
    this._metaKey = false;
    this._shiftKey = false;
    this._buttonsPressed = 0;
    this._currentMousePointerIdDown = -1;
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "BaseCameraPointersInput";
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "pointers";
  }
  /**
   * Called on pointer POINTERDOUBLETAP event.
   * Override this method to provide functionality on POINTERDOUBLETAP event.
   * @param type type of event
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDoubleTap(type) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  /**
   * Called on pointer POINTERMOVE event if only a single touch is active.
   * Override this method to provide functionality.
   * @param point The current position of the pointer
   * @param offsetX The offsetX of the pointer when the event occurred
   * @param offsetY The offsetY of the pointer when the event occurred
   */
  onTouch(point, offsetX, offsetY) {
  }
  /**
   * Called on pointer POINTERMOVE event if multiple touches are active.
   * Override this method to provide functionality.
   * @param _pointA First point in the pair
   * @param _pointB Second point in the pair
   * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)
   * @param pinchSquaredDistance Sqr Distance between the points this time
   * @param previousMultiTouchPanPosition Previous center point between the points
   * @param multiTouchPanPosition Current center point between the points
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMultiTouch(_pointA, _pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
  }
  /**
   * Called on JS contextmenu event.
   * Override this method to provide functionality.
   * @param evt the event to be handled
   */
  onContextMenu(evt) {
    evt.preventDefault();
  }
  /**
   * Called each time a new POINTERDOWN event occurs. Ie, for each button
   * press.
   * Override this method to provide functionality.
   * @param _evt Defines the event to track
   */
  onButtonDown(_evt) {
  }
  /**
   * Called each time a new POINTERUP event occurs. Ie, for each button
   * release.
   * Override this method to provide functionality.
   * @param _evt Defines the event to track
   */
  onButtonUp(_evt) {
  }
  /**
   * Called when window becomes inactive.
   * Override this method to provide functionality.
   */
  onLostFocus() {
  }
};
__decorate([
  serialize()
], BaseCameraPointersInput.prototype, "buttons", void 0);

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraPointersInput.js
var ArcRotateCameraPointersInput = class _ArcRotateCameraPointersInput extends BaseCameraPointersInput {
  constructor() {
    super(...arguments);
    this.buttons = [0, 1, 2];
    this.angularSensibilityX = 1e3;
    this.angularSensibilityY = 1e3;
    this.pinchPrecision = 12;
    this.pinchDeltaPercentage = 0;
    this.useNaturalPinchZoom = false;
    this.pinchZoom = true;
    this.panningSensibility = 1e3;
    this.multiTouchPanning = true;
    this.multiTouchPanAndZoom = true;
    this.pinchInwards = true;
    this._isPanClick = false;
    this._twoFingerActivityCount = 0;
    this._isPinching = false;
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "ArcRotateCameraPointersInput";
  }
  /**
   * Move camera from multi touch panning positions.
   * @param previousMultiTouchPanPosition
   * @param multiTouchPanPosition
   */
  _computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition) {
    if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {
      const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;
      const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;
      this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;
      this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;
    }
  }
  /**
   * Move camera from pinch zoom distances.
   * @param previousPinchSquaredDistance
   * @param pinchSquaredDistance
   */
  _computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance) {
    const radius = this.camera.radius || _ArcRotateCameraPointersInput.MinimumRadiusForPinch;
    if (this.useNaturalPinchZoom) {
      this.camera.radius = radius * Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);
    } else if (this.pinchDeltaPercentage) {
      this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 1e-3 * radius * this.pinchDeltaPercentage;
    } else {
      this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY) / 2);
    }
  }
  /**
   * Called on pointer POINTERMOVE event if only a single touch is active.
   * @param point current touch point
   * @param offsetX offset on X
   * @param offsetY offset on Y
   */
  onTouch(point, offsetX, offsetY) {
    if (this.panningSensibility !== 0 && (this._ctrlKey && this.camera._useCtrlForPanning || this._isPanClick)) {
      this.camera.inertialPanningX += -offsetX / this.panningSensibility;
      this.camera.inertialPanningY += offsetY / this.panningSensibility;
    } else {
      this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;
      this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;
    }
  }
  /**
   * Called on pointer POINTERDOUBLETAP event.
   */
  onDoubleTap() {
    if (this.camera.useInputToRestoreState) {
      this.camera.restoreState();
    }
  }
  /**
   * Called on pointer POINTERMOVE event if multiple touches are active.
   * @param pointA point A
   * @param pointB point B
   * @param previousPinchSquaredDistance distance between points in previous pinch
   * @param pinchSquaredDistance distance between points in current pinch
   * @param previousMultiTouchPanPosition multi-touch position in previous step
   * @param multiTouchPanPosition multi-touch position in current step
   */
  onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
    if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {
      return;
    }
    if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {
      return;
    }
    if (this.multiTouchPanAndZoom) {
      this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
      this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
    } else if (this.multiTouchPanning && this.pinchZoom) {
      this._twoFingerActivityCount++;
      if (this._isPinching || this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance) {
        this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
        this._isPinching = true;
      } else {
        this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
      }
    } else if (this.multiTouchPanning) {
      this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
    } else if (this.pinchZoom) {
      this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
    }
  }
  /**
   * Called each time a new POINTERDOWN event occurs. Ie, for each button
   * press.
   * @param evt Defines the event to track
   */
  onButtonDown(evt) {
    this._isPanClick = evt.button === this.camera._panningMouseButton;
  }
  /**
   * Called each time a new POINTERUP event occurs. Ie, for each button
   * release.
   * @param _evt Defines the event to track
   */
  onButtonUp(_evt) {
    this._twoFingerActivityCount = 0;
    this._isPinching = false;
  }
  /**
   * Called when window becomes inactive.
   */
  onLostFocus() {
    this._isPanClick = false;
    this._twoFingerActivityCount = 0;
    this._isPinching = false;
  }
};
ArcRotateCameraPointersInput.MinimumRadiusForPinch = 1e-3;
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "buttons", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "angularSensibilityX", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "angularSensibilityY", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "pinchPrecision", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "pinchDeltaPercentage", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "useNaturalPinchZoom", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "pinchZoom", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "panningSensibility", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "multiTouchPanning", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "multiTouchPanAndZoom", void 0);
CameraInputTypes["ArcRotateCameraPointersInput"] = ArcRotateCameraPointersInput;

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.js
var ArcRotateCameraKeyboardMoveInput = class {
  constructor() {
    this.keysUp = [38];
    this.keysDown = [40];
    this.keysLeft = [37];
    this.keysRight = [39];
    this.keysReset = [220];
    this.panningSensibility = 50;
    this.zoomingSensibility = 25;
    this.useAltToZoom = true;
    this.angularSpeed = 0.01;
    this._keys = new Array();
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    if (this._onCanvasBlurObserver) {
      return;
    }
    this._scene = this.camera.getScene();
    this._engine = this._scene.getEngine();
    this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
      this._keys.length = 0;
    });
    this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
      const evt = info.event;
      if (!evt.metaKey) {
        if (info.type === KeyboardEventTypes.KEYDOWN) {
          this._ctrlPressed = evt.ctrlKey;
          this._altPressed = evt.altKey;
          if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysReset.indexOf(evt.keyCode) !== -1) {
            const index = this._keys.indexOf(evt.keyCode);
            if (index === -1) {
              this._keys.push(evt.keyCode);
            }
            if (evt.preventDefault) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            }
          }
        } else {
          if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysReset.indexOf(evt.keyCode) !== -1) {
            const index = this._keys.indexOf(evt.keyCode);
            if (index >= 0) {
              this._keys.splice(index, 1);
            }
            if (evt.preventDefault) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            }
          }
        }
      }
    });
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    if (this._scene) {
      if (this._onKeyboardObserver) {
        this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
      }
      if (this._onCanvasBlurObserver) {
        this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
      }
      this._onKeyboardObserver = null;
      this._onCanvasBlurObserver = null;
    }
    this._keys.length = 0;
  }
  /**
   * Update the current camera state depending on the inputs that have been used this frame.
   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
   */
  checkInputs() {
    if (this._onKeyboardObserver) {
      const camera = this.camera;
      for (let index = 0; index < this._keys.length; index++) {
        const keyCode = this._keys[index];
        if (this.keysLeft.indexOf(keyCode) !== -1) {
          if (this._ctrlPressed && this.camera._useCtrlForPanning) {
            camera.inertialPanningX -= 1 / this.panningSensibility;
          } else {
            camera.inertialAlphaOffset -= this.angularSpeed;
          }
        } else if (this.keysUp.indexOf(keyCode) !== -1) {
          if (this._ctrlPressed && this.camera._useCtrlForPanning) {
            camera.inertialPanningY += 1 / this.panningSensibility;
          } else if (this._altPressed && this.useAltToZoom) {
            camera.inertialRadiusOffset += 1 / this.zoomingSensibility;
          } else {
            camera.inertialBetaOffset -= this.angularSpeed;
          }
        } else if (this.keysRight.indexOf(keyCode) !== -1) {
          if (this._ctrlPressed && this.camera._useCtrlForPanning) {
            camera.inertialPanningX += 1 / this.panningSensibility;
          } else {
            camera.inertialAlphaOffset += this.angularSpeed;
          }
        } else if (this.keysDown.indexOf(keyCode) !== -1) {
          if (this._ctrlPressed && this.camera._useCtrlForPanning) {
            camera.inertialPanningY -= 1 / this.panningSensibility;
          } else if (this._altPressed && this.useAltToZoom) {
            camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;
          } else {
            camera.inertialBetaOffset += this.angularSpeed;
          }
        } else if (this.keysReset.indexOf(keyCode) !== -1) {
          if (camera.useInputToRestoreState) {
            camera.restoreState();
          }
        }
      }
    }
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "ArcRotateCameraKeyboardMoveInput";
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "keyboard";
  }
};
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "keysUp", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "keysDown", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "keysLeft", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "keysRight", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "keysReset", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "panningSensibility", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "zoomingSensibility", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "useAltToZoom", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "angularSpeed", void 0);
CameraInputTypes["ArcRotateCameraKeyboardMoveInput"] = ArcRotateCameraKeyboardMoveInput;

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraMouseWheelInput.js
var FfMultiplier = 40;
var ArcRotateCameraMouseWheelInput = class {
  constructor() {
    this.wheelPrecision = 3;
    this.zoomToMouseLocation = false;
    this.wheelDeltaPercentage = 0;
    this.customComputeDeltaFromMouseWheel = null;
    this._viewOffset = new Vector3(0, 0, 0);
    this._globalOffset = new Vector3(0, 0, 0);
    this._inertialPanning = Vector3.Zero();
  }
  _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta, radius) {
    let delta = 0;
    const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;
    if (mouseWheelDelta > 0) {
      delta = wheelDelta / (1 + this.wheelDeltaPercentage);
    } else {
      delta = wheelDelta * (1 + this.wheelDeltaPercentage);
    }
    return delta;
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this._wheel = (p) => {
      if (p.type !== PointerEventTypes.POINTERWHEEL) {
        return;
      }
      const event = p.event;
      let delta = 0;
      const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? FfMultiplier : 1;
      const wheelDelta = -(event.deltaY * platformScale);
      if (this.customComputeDeltaFromMouseWheel) {
        delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);
      } else {
        if (this.wheelDeltaPercentage) {
          delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);
          if (delta > 0) {
            let estimatedTargetRadius = this.camera.radius;
            let targetInertia = this.camera.inertialRadiusOffset + delta;
            for (let i = 0; i < 20; i++) {
              if (estimatedTargetRadius <= targetInertia) {
                break;
              }
              if (Math.abs(targetInertia * this.camera.inertia) < 1e-3) {
                break;
              }
              estimatedTargetRadius -= targetInertia;
              targetInertia *= this.camera.inertia;
            }
            estimatedTargetRadius = Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);
            delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);
          }
        } else {
          delta = wheelDelta / (this.wheelPrecision * 40);
        }
      }
      if (delta) {
        if (this.zoomToMouseLocation) {
          if (!this._hitPlane) {
            this._updateHitPlane();
          }
          this._zoomToMouse(delta);
        } else {
          this.camera.inertialRadiusOffset += delta;
        }
      }
      if (event.preventDefault) {
        if (!noPreventDefault) {
          event.preventDefault();
        }
      }
    };
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);
    if (this.zoomToMouseLocation) {
      this._inertialPanning.setAll(0);
    }
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    if (this._observer) {
      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
      this._observer = null;
      this._wheel = null;
    }
  }
  /**
   * Update the current camera state depending on the inputs that have been used this frame.
   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
   */
  checkInputs() {
    if (!this.zoomToMouseLocation) {
      return;
    }
    const camera = this.camera;
    const motion = 0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;
    if (motion) {
      this._updateHitPlane();
      camera.target.addInPlace(this._inertialPanning);
      this._inertialPanning.scaleInPlace(camera.inertia);
      this._zeroIfClose(this._inertialPanning);
    }
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "ArcRotateCameraMouseWheelInput";
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "mousewheel";
  }
  _updateHitPlane() {
    const camera = this.camera;
    const direction = camera.target.subtract(camera.position);
    this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);
  }
  // Get position on the hit plane
  _getPosition() {
    const camera = this.camera;
    const scene = camera.getScene();
    const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);
    if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {
      this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);
      camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
      this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);
      ray.origin.addInPlace(this._globalOffset);
    }
    let distance = 0;
    if (this._hitPlane) {
      distance = ray.intersectsPlane(this._hitPlane) ?? 0;
    }
    return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));
  }
  _zoomToMouse(delta) {
    const camera = this.camera;
    const inertiaComp = 1 - camera.inertia;
    if (camera.lowerRadiusLimit) {
      const lowerLimit = camera.lowerRadiusLimit ?? 0;
      if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {
        delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;
      }
    }
    if (camera.upperRadiusLimit) {
      const upperLimit = camera.upperRadiusLimit ?? 0;
      if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {
        delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;
      }
    }
    const zoomDistance = delta / inertiaComp;
    const ratio = zoomDistance / camera.radius;
    const vec = this._getPosition();
    const directionToZoomLocation = TmpVectors.Vector3[6];
    vec.subtractToRef(camera.target, directionToZoomLocation);
    directionToZoomLocation.scaleInPlace(ratio);
    directionToZoomLocation.scaleInPlace(inertiaComp);
    this._inertialPanning.addInPlace(directionToZoomLocation);
    camera.inertialRadiusOffset += delta;
  }
  // Sets x y or z of passed in vector to zero if less than Epsilon.
  _zeroIfClose(vec) {
    if (Math.abs(vec.x) < Epsilon) {
      vec.x = 0;
    }
    if (Math.abs(vec.y) < Epsilon) {
      vec.y = 0;
    }
    if (Math.abs(vec.z) < Epsilon) {
      vec.z = 0;
    }
  }
};
__decorate([
  serialize()
], ArcRotateCameraMouseWheelInput.prototype, "wheelPrecision", void 0);
__decorate([
  serialize()
], ArcRotateCameraMouseWheelInput.prototype, "zoomToMouseLocation", void 0);
__decorate([
  serialize()
], ArcRotateCameraMouseWheelInput.prototype, "wheelDeltaPercentage", void 0);
CameraInputTypes["ArcRotateCameraMouseWheelInput"] = ArcRotateCameraMouseWheelInput;

// node_modules/@babylonjs/core/Cameras/arcRotateCameraInputsManager.js
var ArcRotateCameraInputsManager = class extends CameraInputsManager {
  /**
   * Instantiates a new ArcRotateCameraInputsManager.
   * @param camera Defines the camera the inputs belong to
   */
  constructor(camera) {
    super(camera);
  }
  /**
   * Add mouse wheel input support to the input manager.
   * @returns the current input manager
   */
  addMouseWheel() {
    this.add(new ArcRotateCameraMouseWheelInput());
    return this;
  }
  /**
   * Add pointers input support to the input manager.
   * @returns the current input manager
   */
  addPointers() {
    this.add(new ArcRotateCameraPointersInput());
    return this;
  }
  /**
   * Add keyboard input support to the input manager.
   * @returns the current input manager
   */
  addKeyboard() {
    this.add(new ArcRotateCameraKeyboardMoveInput());
    return this;
  }
};

// node_modules/@babylonjs/core/Cameras/arcRotateCamera.js
Node.AddNodeConstructor("ArcRotateCamera", (name, scene) => {
  return () => new ArcRotateCamera(name, 0, 0, 1, Vector3.Zero(), scene);
});
function ComputeAlpha(offset) {
  let alpha = Math.PI / 2;
  if (!(offset.x === 0 && offset.z === 0)) {
    alpha = Math.acos(offset.x / Math.sqrt(Math.pow(offset.x, 2) + Math.pow(offset.z, 2)));
  }
  if (offset.z < 0) {
    alpha = 2 * Math.PI - alpha;
  }
  return alpha;
}
function ComputeBeta(verticalOffset, radius) {
  return Math.acos(verticalOffset / radius);
}
function CheckNaN(value, fallback) {
  return isNaN(value) ? fallback : value;
}
var ArcRotateCamera = class _ArcRotateCamera extends TargetCamera {
  /**
   * Defines the target point of the camera.
   * The camera looks towards it from the radius distance.
   */
  get target() {
    return this._target;
  }
  set target(value) {
    this.setTarget(value);
  }
  /**
   * Defines the target transform node of the camera.
   * The camera looks towards it from the radius distance.
   * Please note that setting a target host will disable panning.
   */
  get targetHost() {
    return this._targetHost;
  }
  set targetHost(value) {
    if (value) {
      this.setTarget(value);
    }
  }
  /**
   * Return the current target position of the camera. This value is expressed in local space.
   * @returns the target position
   */
  getTarget() {
    return this.target;
  }
  /**
   * Define the current local position of the camera in the scene
   */
  get position() {
    return this._position;
  }
  set position(newPosition) {
    this.setPosition(newPosition);
  }
  /**
   * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())
   * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.
   * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.
   */
  set upVector(vec) {
    if (!this._upToYMatrix) {
      this._yToUpMatrix = new Matrix();
      this._upToYMatrix = new Matrix();
      this._upVector = Vector3.Zero();
    }
    vec.normalize();
    this._upVector.copyFrom(vec);
    this.setMatUp();
  }
  get upVector() {
    return this._upVector;
  }
  /**
   * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.
   */
  setMatUp() {
    Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._yToUpMatrix);
    Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);
  }
  //-- begin properties for backward compatibility for inputs
  /**
   * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.
   */
  get angularSensibilityX() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.angularSensibilityX;
    }
    return 0;
  }
  set angularSensibilityX(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.angularSensibilityX = value;
    }
  }
  /**
   * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.
   */
  get angularSensibilityY() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.angularSensibilityY;
    }
    return 0;
  }
  set angularSensibilityY(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.angularSensibilityY = value;
    }
  }
  /**
   * Gets or Set the pointer pinch precision or how fast is the camera zooming.
   */
  get pinchPrecision() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.pinchPrecision;
    }
    return 0;
  }
  set pinchPrecision(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.pinchPrecision = value;
    }
  }
  /**
   * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.
   * It will be used instead of pinchPrecision if different from 0.
   * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
   */
  get pinchDeltaPercentage() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.pinchDeltaPercentage;
    }
    return 0;
  }
  set pinchDeltaPercentage(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.pinchDeltaPercentage = value;
    }
  }
  /**
   * Gets or Set the pointer use natural pinch zoom to override the pinch precision
   * and pinch delta percentage.
   * When useNaturalPinchZoom is true, multi touch zoom will zoom in such
   * that any object in the plane at the camera's target point will scale
   * perfectly with finger motion.
   */
  get useNaturalPinchZoom() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.useNaturalPinchZoom;
    }
    return false;
  }
  set useNaturalPinchZoom(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.useNaturalPinchZoom = value;
    }
  }
  /**
   * Gets or Set the pointer panning sensibility or how fast is the camera moving.
   */
  get panningSensibility() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.panningSensibility;
    }
    return 0;
  }
  set panningSensibility(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.panningSensibility = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.
   */
  get keysUp() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysUp;
    }
    return [];
  }
  set keysUp(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysUp = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.
   */
  get keysDown() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysDown;
    }
    return [];
  }
  set keysDown(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysDown = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.
   */
  get keysLeft() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysLeft;
    }
    return [];
  }
  set keysLeft(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysLeft = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.
   */
  get keysRight() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRight;
    }
    return [];
  }
  set keysRight(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRight = value;
    }
  }
  /**
   * Gets or Set the mouse wheel precision or how fast is the camera zooming.
   */
  get wheelPrecision() {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      return mousewheel.wheelPrecision;
    }
    return 0;
  }
  set wheelPrecision(value) {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      mousewheel.wheelPrecision = value;
    }
  }
  /**
   * Gets or Set the boolean value that controls whether or not the mouse wheel
   * zooms to the location of the mouse pointer or not.  The default is false.
   */
  get zoomToMouseLocation() {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      return mousewheel.zoomToMouseLocation;
    }
    return false;
  }
  set zoomToMouseLocation(value) {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      mousewheel.zoomToMouseLocation = value;
    }
  }
  /**
   * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.
   * It will be used instead of wheelPrecision if different from 0.
   * It defines the percentage of current camera.radius to use as delta when wheel zoom is used.
   */
  get wheelDeltaPercentage() {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      return mousewheel.wheelDeltaPercentage;
    }
    return 0;
  }
  set wheelDeltaPercentage(value) {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      mousewheel.wheelDeltaPercentage = value;
    }
  }
  /**
   * If true, indicates the camera is currently interpolating to a new pose.
   */
  get isInterpolating() {
    return this._isInterpolating;
  }
  /**
   * Gets the bouncing behavior of the camera if it has been enabled.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior
   */
  get bouncingBehavior() {
    return this._bouncingBehavior;
  }
  /**
   * Defines if the bouncing behavior of the camera is enabled on the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior
   */
  get useBouncingBehavior() {
    return this._bouncingBehavior != null;
  }
  set useBouncingBehavior(value) {
    if (value === this.useBouncingBehavior) {
      return;
    }
    if (value) {
      this._bouncingBehavior = new BouncingBehavior();
      this.addBehavior(this._bouncingBehavior);
    } else if (this._bouncingBehavior) {
      this.removeBehavior(this._bouncingBehavior);
      this._bouncingBehavior = null;
    }
  }
  /**
   * Gets the framing behavior of the camera if it has been enabled.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior
   */
  get framingBehavior() {
    return this._framingBehavior;
  }
  /**
   * Defines if the framing behavior of the camera is enabled on the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior
   */
  get useFramingBehavior() {
    return this._framingBehavior != null;
  }
  set useFramingBehavior(value) {
    if (value === this.useFramingBehavior) {
      return;
    }
    if (value) {
      this._framingBehavior = new FramingBehavior();
      this.addBehavior(this._framingBehavior);
    } else if (this._framingBehavior) {
      this.removeBehavior(this._framingBehavior);
      this._framingBehavior = null;
    }
  }
  /**
   * Gets the auto rotation behavior of the camera if it has been enabled.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior
   */
  get autoRotationBehavior() {
    return this._autoRotationBehavior;
  }
  /**
   * Defines if the auto rotation behavior of the camera is enabled on the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior
   */
  get useAutoRotationBehavior() {
    return this._autoRotationBehavior != null;
  }
  set useAutoRotationBehavior(value) {
    if (value === this.useAutoRotationBehavior) {
      return;
    }
    if (value) {
      this._autoRotationBehavior = new AutoRotationBehavior();
      this.addBehavior(this._autoRotationBehavior);
    } else if (this._autoRotationBehavior) {
      this.removeBehavior(this._autoRotationBehavior);
      this._autoRotationBehavior = null;
    }
  }
  /**
   * Instantiates a new ArcRotateCamera in a given scene
   * @param name Defines the name of the camera
   * @param alpha Defines the camera rotation along the longitudinal axis
   * @param beta Defines the camera rotation along the latitudinal axis
   * @param radius Defines the camera distance from its target
   * @param target Defines the camera target
   * @param scene Defines the scene the camera belongs to
   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined
   */
  constructor(name, alpha, beta, radius, target, scene, setActiveOnSceneIfNoneActive = true) {
    super(name, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive);
    this.inertialAlphaOffset = 0;
    this.inertialBetaOffset = 0;
    this.inertialRadiusOffset = 0;
    this.lowerAlphaLimit = null;
    this.upperAlphaLimit = null;
    this.lowerBetaLimit = 0.01;
    this.upperBetaLimit = Math.PI - 0.01;
    this.lowerRadiusLimit = null;
    this.upperRadiusLimit = null;
    this.lowerTargetYLimit = -Infinity;
    this.inertialPanningX = 0;
    this.inertialPanningY = 0;
    this.pinchToPanMaxDistance = 20;
    this.panningDistanceLimit = null;
    this.panningOriginTarget = Vector3.Zero();
    this.panningInertia = 0.9;
    this.zoomOnFactor = 1;
    this.targetScreenOffset = Vector2.Zero();
    this.allowUpsideDown = true;
    this.useInputToRestoreState = true;
    this.restoreStateInterpolationFactor = 0;
    this._currentInterpolationFactor = 0;
    this._viewMatrix = new Matrix();
    this.panningAxis = new Vector3(1, 1, 0);
    this._transformedDirection = new Vector3();
    this.mapPanning = false;
    this._isInterpolating = false;
    this.onMeshTargetChangedObservable = new Observable();
    this.checkCollisions = false;
    this.collisionRadius = new Vector3(0.5, 0.5, 0.5);
    this._previousPosition = Vector3.Zero();
    this._collisionVelocity = Vector3.Zero();
    this._newPosition = Vector3.Zero();
    this._computationVector = Vector3.Zero();
    this._goalAlpha = NaN;
    this._goalBeta = NaN;
    this._goalRadius = NaN;
    this._goalTarget = new Vector3(NaN, NaN, NaN);
    this._goalTargetScreenOffset = new Vector2(NaN, NaN);
    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
      if (!collidedMesh) {
        this._previousPosition.copyFrom(this._position);
      } else {
        this.setPosition(newPosition);
        if (this.onCollide) {
          this.onCollide(collidedMesh);
        }
      }
      const cosa = Math.cos(this.alpha);
      const sina = Math.sin(this.alpha);
      const cosb = Math.cos(this.beta);
      let sinb = Math.sin(this.beta);
      if (sinb === 0) {
        sinb = 1e-4;
      }
      const target2 = this._getTargetPosition();
      this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);
      target2.addToRef(this._computationVector, this._newPosition);
      this._position.copyFrom(this._newPosition);
      let up = this.upVector;
      if (this.allowUpsideDown && this.beta < 0) {
        up = up.clone();
        up = up.negate();
      }
      this._computeViewMatrix(this._position, target2, up);
      this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);
      this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);
      this._collisionTriggered = false;
    };
    this._target = Vector3.Zero();
    if (target) {
      this.setTarget(target);
    }
    this.alpha = alpha;
    this.beta = beta;
    this.radius = radius;
    this.getViewMatrix();
    this.inputs = new ArcRotateCameraInputsManager(this);
    this.inputs.addKeyboard().addMouseWheel().addPointers();
  }
  // Cache
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.alpha = void 0;
    this._cache.beta = void 0;
    this._cache.radius = void 0;
    this._cache.targetScreenOffset = Vector2.Zero();
  }
  /**
   * @internal
   */
  _updateCache(ignoreParentClass) {
    if (!ignoreParentClass) {
      super._updateCache();
    }
    this._cache._target.copyFrom(this._getTargetPosition());
    this._cache.alpha = this.alpha;
    this._cache.beta = this.beta;
    this._cache.radius = this.radius;
    this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);
  }
  _getTargetPosition() {
    if (this._targetHost && this._targetHost.getAbsolutePosition) {
      const pos = this._targetHost.getAbsolutePosition();
      if (this._targetBoundingCenter) {
        pos.addToRef(this._targetBoundingCenter, this._target);
      } else {
        this._target.copyFrom(pos);
      }
    }
    const lockedTargetPosition = this._getLockedTargetPosition();
    if (lockedTargetPosition) {
      return lockedTargetPosition;
    }
    return this._target;
  }
  /**
   * Stores the current state of the camera (alpha, beta, radius and target)
   * @returns the camera itself
   */
  storeState() {
    this._storedAlpha = this.alpha;
    this._storedBeta = this.beta;
    this._storedRadius = this.radius;
    this._storedTarget = this._getTargetPosition().clone();
    this._storedTargetScreenOffset = this.targetScreenOffset.clone();
    return super.storeState();
  }
  /**
   * @internal
   * Restored camera state. You must call storeState() first
   */
  _restoreStateValues() {
    if (this.hasStateStored() && this.restoreStateInterpolationFactor > Epsilon && this.restoreStateInterpolationFactor < 1) {
      this.interpolateTo(this._storedAlpha, this._storedBeta, this._storedRadius, this._storedTarget, this._storedTargetScreenOffset, this.restoreStateInterpolationFactor);
      return true;
    }
    if (!super._restoreStateValues()) {
      return false;
    }
    this.setTarget(this._storedTarget.clone());
    this.alpha = this._storedAlpha;
    this.beta = this._storedBeta;
    this.radius = this._storedRadius;
    this.targetScreenOffset = this._storedTargetScreenOffset.clone();
    this.inertialAlphaOffset = 0;
    this.inertialBetaOffset = 0;
    this.inertialRadiusOffset = 0;
    this.inertialPanningX = 0;
    this.inertialPanningY = 0;
    return true;
  }
  /**
   * Stops any in-progress interpolation.
   */
  stopInterpolation() {
    this._goalAlpha = NaN;
    this._goalBeta = NaN;
    this._goalRadius = NaN;
    this._goalTarget.set(NaN, NaN, NaN);
    this._goalTargetScreenOffset.set(NaN, NaN);
  }
  /**
   * Interpolates the camera to a goal state.
   * @param alpha Defines the goal alpha.
   * @param beta Defines the goal beta.
   * @param radius Defines the goal radius.
   * @param target Defines the goal target.
   * @param targetScreenOffset Defines the goal target screen offset.
   * @param interpolationFactor A value  between 0 and 1 that determines the speed of the interpolation.
   * @remarks Passing undefined for any of the parameters will use the current value (effectively stopping any in-progress interpolation for that parameter).
   *          Passing NaN will not start or stop any interpolation for that parameter (effectively allowing multiple interpolations of different parameters to overlap).
   */
  interpolateTo(alpha = this.alpha, beta = this.beta, radius = this.radius, target = this.target, targetScreenOffset = this.targetScreenOffset, interpolationFactor) {
    this.inertialAlphaOffset = 0;
    this.inertialBetaOffset = 0;
    this.inertialRadiusOffset = 0;
    this.inertialPanningX = 0;
    this.inertialPanningY = 0;
    if (interpolationFactor != null) {
      this._currentInterpolationFactor = interpolationFactor;
    } else if (this.restoreStateInterpolationFactor !== 0) {
      this._currentInterpolationFactor = this.restoreStateInterpolationFactor;
    } else {
      this._currentInterpolationFactor = 0.1;
    }
    this._goalAlpha = CheckNaN(alpha, this._goalAlpha);
    this._goalBeta = CheckNaN(beta, this._goalBeta);
    this._goalRadius = CheckNaN(radius, this._goalRadius);
    this._goalTarget.set(CheckNaN(target.x, this._goalTarget.x), CheckNaN(target.y, this._goalTarget.y), CheckNaN(target.z, this._goalTarget.z));
    this._goalTargetScreenOffset.set(CheckNaN(targetScreenOffset.x, this._goalTargetScreenOffset.x), CheckNaN(targetScreenOffset.y, this._goalTargetScreenOffset.y));
    this._goalAlpha = Clamp(this._goalAlpha, this.lowerAlphaLimit ?? -Infinity, this.upperAlphaLimit ?? Infinity);
    this._goalBeta = Clamp(this._goalBeta, this.lowerBetaLimit ?? -Infinity, this.upperBetaLimit ?? Infinity);
    this._goalRadius = Clamp(this._goalRadius, this.lowerRadiusLimit ?? -Infinity, this.upperRadiusLimit ?? Infinity);
    this._goalTarget.y = Clamp(this._goalTarget.y, this.lowerTargetYLimit ?? -Infinity, Infinity);
    this._isInterpolating = true;
  }
  // Synchronized
  /** @internal */
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronizedViewMatrix()) {
      return false;
    }
    return this._cache._target.equals(this._getTargetPosition()) && this._cache.alpha === this.alpha && this._cache.beta === this.beta && this._cache.radius === this.radius && this._cache.targetScreenOffset.equals(this.targetScreenOffset);
  }
  /**
   * Attached controls to the current camera.
   * @param ignored defines an ignored parameter kept for backward compatibility.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls
   * @param panningMouseButton Defines whether panning is allowed through mouse click button
   */
  attachControl(ignored, noPreventDefault, useCtrlForPanning = true, panningMouseButton = 2) {
    const args = arguments;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(args);
    this._useCtrlForPanning = useCtrlForPanning;
    this._panningMouseButton = panningMouseButton;
    if (typeof args[0] === "boolean") {
      if (args.length > 1) {
        this._useCtrlForPanning = args[1];
      }
      if (args.length > 2) {
        this._panningMouseButton = args[2];
      }
    }
    this.inputs.attachElement(noPreventDefault);
    this._reset = () => {
      this.inertialAlphaOffset = 0;
      this.inertialBetaOffset = 0;
      this.inertialRadiusOffset = 0;
      this.inertialPanningX = 0;
      this.inertialPanningY = 0;
    };
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    this.inputs.detachElement();
    if (this._reset) {
      this._reset();
    }
  }
  /** @internal */
  _checkInputs() {
    if (this._collisionTriggered) {
      return;
    }
    this.inputs.checkInputs();
    let hasUserInteractions = false;
    const inertialPanningLimit = this.speed * this._panningEpsilon;
    const inertialRotationLimit = this.speed * this._rotationEpsilon;
    if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {
      hasUserInteractions = true;
      const directionModifier = this.invertRotation ? -1 : 1;
      const handednessMultiplier = this._calculateHandednessMultiplier();
      let inertialAlphaOffset = this.inertialAlphaOffset * handednessMultiplier;
      if (this.beta < 0) {
        inertialAlphaOffset *= -1;
      }
      this.alpha += inertialAlphaOffset * directionModifier;
      this.beta += this.inertialBetaOffset * directionModifier;
      this.radius -= this.inertialRadiusOffset;
      this.inertialAlphaOffset *= this.inertia;
      this.inertialBetaOffset *= this.inertia;
      this.inertialRadiusOffset *= this.inertia;
      if (Math.abs(this.inertialAlphaOffset) < inertialRotationLimit) {
        this.inertialAlphaOffset = 0;
      }
      if (Math.abs(this.inertialBetaOffset) < inertialRotationLimit) {
        this.inertialBetaOffset = 0;
      }
      if (Math.abs(this.inertialRadiusOffset) < inertialRotationLimit) {
        this.inertialRadiusOffset = 0;
      }
    }
    if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {
      hasUserInteractions = true;
      const localDirection = new Vector3(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);
      this._viewMatrix.invertToRef(this._cameraTransformMatrix);
      localDirection.multiplyInPlace(this.panningAxis);
      Vector3.TransformNormalToRef(localDirection, this._cameraTransformMatrix, this._transformedDirection);
      if (this.mapPanning) {
        const up = this.upVector;
        const right = Vector3.CrossToRef(this._transformedDirection, up, this._transformedDirection);
        Vector3.CrossToRef(up, right, this._transformedDirection);
      } else if (!this.panningAxis.y) {
        this._transformedDirection.y = 0;
      }
      if (!this._targetHost) {
        if (this.panningDistanceLimit) {
          this._transformedDirection.addInPlace(this._target);
          const distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);
          if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {
            this._target.copyFrom(this._transformedDirection);
          }
        } else {
          if (this.parent) {
            const m = TmpVectors.Matrix[0];
            this.parent.getWorldMatrix().getRotationMatrixToRef(m);
            m.transposeToRef(m);
            Vector3.TransformCoordinatesToRef(this._transformedDirection, m, this._transformedDirection);
          }
          this._target.addInPlace(this._transformedDirection);
        }
      }
      this.inertialPanningX *= this.panningInertia;
      this.inertialPanningY *= this.panningInertia;
      if (Math.abs(this.inertialPanningX) < inertialPanningLimit) {
        this.inertialPanningX = 0;
      }
      if (Math.abs(this.inertialPanningY) < inertialPanningLimit) {
        this.inertialPanningY = 0;
      }
    }
    if (hasUserInteractions) {
      this.stopInterpolation();
    } else if (this._isInterpolating) {
      let isInterpolating = false;
      const dt = this._scene.getEngine().getDeltaTime() / 1e3;
      const t = 1 - Math.pow(2, -dt / this._currentInterpolationFactor);
      const goalRadius = CheckNaN(this._goalRadius, this.radius);
      if (!isNaN(this._goalTarget.x) || !isNaN(this._goalTarget.y) || !isNaN(this._goalTarget.z)) {
        const goalTarget = TmpVectors.Vector3[0].set(CheckNaN(this._goalTarget.x, this._target.x), CheckNaN(this._goalTarget.y, this._target.y), CheckNaN(this._goalTarget.z, this._target.z));
        Vector3.LerpToRef(this.target, goalTarget, t, this._target);
        if (Vector3.Distance(this.target, goalTarget) * 10 / goalRadius < Epsilon) {
          this._goalTarget.set(NaN, NaN, NaN);
          this.target.copyFrom(goalTarget);
          this.setTarget(this.target, false, true, true);
        } else {
          isInterpolating = true;
        }
      }
      if (!isNaN(this._goalAlpha) || !isNaN(this._goalBeta)) {
        const goalRotation = Quaternion.RotationAlphaBetaGammaToRef(CheckNaN(this._goalAlpha, this.alpha), CheckNaN(this._goalBeta, this.beta), 0, TmpVectors.Quaternion[0]);
        const currentRotation = Quaternion.RotationAlphaBetaGammaToRef(this.alpha, this.beta, 0, TmpVectors.Quaternion[1]);
        const newRotation = Quaternion.SlerpToRef(currentRotation, goalRotation, t, TmpVectors.Quaternion[2]);
        newRotation.normalize();
        const newAlphaBetaGamma = newRotation.toAlphaBetaGammaToRef(TmpVectors.Vector3[0]);
        this.alpha = newAlphaBetaGamma.x;
        this.beta = newAlphaBetaGamma.y;
        if (newRotation.isApprox(goalRotation, Epsilon / 5)) {
          this._goalAlpha = NaN;
          this._goalBeta = NaN;
          const goalAlphaBetaGamma = goalRotation.toAlphaBetaGammaToRef(TmpVectors.Vector3[0]);
          this.alpha = goalAlphaBetaGamma.x;
          this.beta = goalAlphaBetaGamma.y;
        } else {
          isInterpolating = true;
        }
      }
      if (!isNaN(this._goalRadius)) {
        this.radius += (goalRadius - this.radius) * t;
        if (Math.abs(goalRadius / this.radius - 1) < Epsilon) {
          this._goalRadius = NaN;
          this.radius = goalRadius;
        } else {
          isInterpolating = true;
        }
      }
      if (!isNaN(this._goalTargetScreenOffset.x) || !isNaN(this._goalTargetScreenOffset.y)) {
        const goalTargetScreenOffset = TmpVectors.Vector2[0].set(CheckNaN(this._goalTargetScreenOffset.x, this.targetScreenOffset.x), CheckNaN(this._goalTargetScreenOffset.y, this.targetScreenOffset.y));
        Vector2.LerpToRef(this.targetScreenOffset, goalTargetScreenOffset, t, this.targetScreenOffset);
        if (Vector2.Distance(this.targetScreenOffset, goalTargetScreenOffset) < Epsilon) {
          this._goalTargetScreenOffset.set(NaN, NaN);
          this.targetScreenOffset.copyFrom(goalTargetScreenOffset);
        } else {
          isInterpolating = true;
        }
      }
      this._isInterpolating = isInterpolating;
    }
    this._checkLimits();
    super._checkInputs();
  }
  _checkLimits() {
    if (this.lowerBetaLimit === null || this.lowerBetaLimit === void 0) {
      if (this.allowUpsideDown && this.beta > Math.PI) {
        this.beta = this.beta - 2 * Math.PI;
      }
    } else {
      if (this.beta < this.lowerBetaLimit) {
        this.beta = this.lowerBetaLimit;
      }
    }
    if (this.upperBetaLimit === null || this.upperBetaLimit === void 0) {
      if (this.allowUpsideDown && this.beta < -Math.PI) {
        this.beta = this.beta + 2 * Math.PI;
      }
    } else {
      if (this.beta > this.upperBetaLimit) {
        this.beta = this.upperBetaLimit;
      }
    }
    if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {
      this.alpha = this.lowerAlphaLimit;
    }
    if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {
      this.alpha = this.upperAlphaLimit;
    }
    if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {
      this.radius = this.lowerRadiusLimit;
      this.inertialRadiusOffset = 0;
    }
    if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {
      this.radius = this.upperRadiusLimit;
      this.inertialRadiusOffset = 0;
    }
    this.target.y = Math.max(this.target.y, this.lowerTargetYLimit);
  }
  /**
   * Rebuilds angles (alpha, beta) and radius from the give position and target
   */
  rebuildAnglesAndRadius() {
    this._position.subtractToRef(this._getTargetPosition(), this._computationVector);
    if (this._upVector.x !== 0 || this._upVector.y !== 1 || this._upVector.z !== 0) {
      Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);
    }
    this.radius = this._computationVector.length();
    if (this.radius === 0) {
      this.radius = 1e-4;
    }
    const previousAlpha = this.alpha;
    this.alpha = ComputeAlpha(this._computationVector);
    this.beta = ComputeBeta(this._computationVector.y, this.radius);
    const alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2 * Math.PI));
    this.alpha += alphaCorrectionTurns * 2 * Math.PI;
    this._checkLimits();
  }
  /**
   * Use a position to define the current camera related information like alpha, beta and radius
   * @param position Defines the position to set the camera at
   */
  setPosition(position) {
    if (this._position.equals(position)) {
      return;
    }
    this._position.copyFrom(position);
    this.rebuildAnglesAndRadius();
  }
  /**
   * Defines the target the camera should look at.
   * This will automatically adapt alpha beta and radius to fit within the new target.
   * Please note that setting a target as a mesh will disable panning.
   * @param target Defines the new target as a Vector or a transform node
   * @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center
   * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)
   * @param cloneAlphaBetaRadius If true, replicate the current setup (alpha, beta, radius) on the new target
   */
  setTarget(target, toBoundingCenter = false, allowSamePosition = false, cloneAlphaBetaRadius = false) {
    cloneAlphaBetaRadius = this.overrideCloneAlphaBetaRadius ?? cloneAlphaBetaRadius;
    if (target.computeWorldMatrix) {
      if (toBoundingCenter && target.getBoundingInfo) {
        this._targetBoundingCenter = target.getBoundingInfo().boundingBox.centerWorld.clone();
      } else {
        this._targetBoundingCenter = null;
      }
      target.computeWorldMatrix();
      this._targetHost = target;
      this._target = this._getTargetPosition();
      this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);
    } else {
      const newTarget = target;
      const currentTarget = this._getTargetPosition();
      if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {
        return;
      }
      this._targetHost = null;
      this._target = newTarget;
      this._targetBoundingCenter = null;
      this.onMeshTargetChangedObservable.notifyObservers(null);
    }
    if (!cloneAlphaBetaRadius) {
      this.rebuildAnglesAndRadius();
    }
  }
  /** @internal */
  _getViewMatrix() {
    const cosa = Math.cos(this.alpha);
    const sina = Math.sin(this.alpha);
    const cosb = Math.cos(this.beta);
    let sinb = Math.sin(this.beta);
    if (sinb === 0) {
      sinb = 1e-4;
    }
    if (this.radius === 0) {
      this.radius = 1e-4;
    }
    const target = this._getTargetPosition();
    this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);
    if (this._upVector.x !== 0 || this._upVector.y !== 1 || this._upVector.z !== 0) {
      Vector3.TransformCoordinatesToRef(this._computationVector, this._yToUpMatrix, this._computationVector);
    }
    target.addToRef(this._computationVector, this._newPosition);
    if (this.getScene().collisionsEnabled && this.checkCollisions) {
      const coordinator = this.getScene().collisionCoordinator;
      if (!this._collider) {
        this._collider = coordinator.createCollider();
      }
      this._collider._radius = this.collisionRadius;
      this._newPosition.subtractToRef(this._position, this._collisionVelocity);
      this._collisionTriggered = true;
      coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
    } else {
      this._position.copyFrom(this._newPosition);
      let up = this.upVector;
      if (this.allowUpsideDown && sinb < 0) {
        up = up.negate();
      }
      this._computeViewMatrix(this._position, target, up);
      this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);
      this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);
    }
    this._currentTarget.copyFrom(target);
    return this._viewMatrix;
  }
  /**
   * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.
   * @param meshes Defines the mesh to zoom on
   * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)
   */
  zoomOn(meshes, doNotUpdateMaxZ = false) {
    meshes = meshes || this.getScene().meshes;
    const minMaxVector = Mesh.MinMax(meshes);
    let distance = this._calculateLowerRadiusFromModelBoundingSphere(minMaxVector.min, minMaxVector.max);
    distance = Math.max(Math.min(distance, this.upperRadiusLimit || Number.MAX_VALUE), this.lowerRadiusLimit || 0);
    this.radius = distance * this.zoomOnFactor;
    if (this.mode === Camera.ORTHOGRAPHIC_CAMERA) {
      const aspectRatio = this.getScene().getEngine().getAspectRatio(this);
      const orthoExtent = distance * this.zoomOnFactor / 2;
      this.orthoLeft = -orthoExtent * aspectRatio;
      this.orthoRight = orthoExtent * aspectRatio;
      this.orthoBottom = -orthoExtent;
      this.orthoTop = orthoExtent;
    }
    this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance }, doNotUpdateMaxZ);
  }
  /**
   * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.
   * The target will be changed but the radius
   * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on
   * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)
   */
  focusOn(meshesOrMinMaxVectorAndDistance, doNotUpdateMaxZ = false) {
    let meshesOrMinMaxVector;
    let distance;
    if (meshesOrMinMaxVectorAndDistance.min === void 0) {
      const meshes = meshesOrMinMaxVectorAndDistance || this.getScene().meshes;
      meshesOrMinMaxVector = Mesh.MinMax(meshes);
      distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);
    } else {
      const minMaxVectorAndDistance = meshesOrMinMaxVectorAndDistance;
      meshesOrMinMaxVector = minMaxVectorAndDistance;
      distance = minMaxVectorAndDistance.distance;
    }
    this._target = Mesh.Center(meshesOrMinMaxVector);
    if (!doNotUpdateMaxZ) {
      this.maxZ = distance * 2;
    }
  }
  /**
   * @override
   * Override Camera.createRigCamera
   * @param name the name of the camera
   * @param cameraIndex the index of the camera in the rig cameras array
   */
  createRigCamera(name, cameraIndex) {
    let alphaShift = 0;
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:
      case Camera.RIG_MODE_VR:
        alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);
        break;
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
        alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);
        break;
    }
    const rigCam = new _ArcRotateCamera(name, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());
    rigCam._cameraRigParams = {};
    rigCam.isRigCamera = true;
    rigCam.rigParent = this;
    rigCam.upVector = this.upVector;
    rigCam.mode = this.mode;
    rigCam.orthoLeft = this.orthoLeft;
    rigCam.orthoRight = this.orthoRight;
    rigCam.orthoBottom = this.orthoBottom;
    rigCam.orthoTop = this.orthoTop;
    return rigCam;
  }
  /**
   * @internal
   * @override
   * Override Camera._updateRigCameras
   */
  _updateRigCameras() {
    const camLeft = this._rigCameras[0];
    const camRight = this._rigCameras[1];
    camLeft.beta = camRight.beta = this.beta;
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:
      case Camera.RIG_MODE_VR:
        camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;
        camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
        break;
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
        camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
        camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;
        break;
    }
    super._updateRigCameras();
  }
  /**
   * @internal
   */
  _calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld, radiusScale = 1) {
    const boxVectorGlobalDiagonal = Vector3.Distance(minimumWorld, maximumWorld);
    const engine = this.getScene().getEngine();
    const aspectRatio = engine.getAspectRatio(this);
    const frustumSlopeY = Math.tan(this.fov / 2);
    const frustumSlopeX = frustumSlopeY * aspectRatio;
    const radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;
    const radius = radiusWithoutFraming * radiusScale;
    const distanceForHorizontalFrustum = radius * Math.sqrt(1 + 1 / (frustumSlopeX * frustumSlopeX));
    const distanceForVerticalFrustum = radius * Math.sqrt(1 + 1 / (frustumSlopeY * frustumSlopeY));
    return Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);
  }
  /**
   * Destroy the camera and release the current resources hold by it.
   */
  dispose() {
    this.inputs.clear();
    super.dispose();
  }
  /**
   * Gets the current object class name.
   * @returns the class name
   */
  getClassName() {
    return "ArcRotateCamera";
  }
};
__decorate([
  serialize()
], ArcRotateCamera.prototype, "alpha", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "beta", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "radius", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "overrideCloneAlphaBetaRadius", void 0);
__decorate([
  serializeAsVector3("target")
], ArcRotateCamera.prototype, "_target", void 0);
__decorate([
  serializeAsMeshReference("targetHost")
], ArcRotateCamera.prototype, "_targetHost", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialAlphaOffset", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialBetaOffset", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialRadiusOffset", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "lowerAlphaLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "upperAlphaLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "lowerBetaLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "upperBetaLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "lowerRadiusLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "upperRadiusLimit", void 0);
__decorate([
  serialize()
  // eslint-disable-next-line @typescript-eslint/naming-convention
], ArcRotateCamera.prototype, "lowerTargetYLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialPanningX", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialPanningY", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "pinchToPanMaxDistance", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "panningDistanceLimit", void 0);
__decorate([
  serializeAsVector3()
], ArcRotateCamera.prototype, "panningOriginTarget", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "panningInertia", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "zoomToMouseLocation", null);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "zoomOnFactor", void 0);
__decorate([
  serializeAsVector2()
], ArcRotateCamera.prototype, "targetScreenOffset", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "allowUpsideDown", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "useInputToRestoreState", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "restoreStateInterpolationFactor", void 0);
RegisterClass("BABYLON.ArcRotateCamera", ArcRotateCamera);

export {
  AutoRotationBehavior,
  BouncingBehavior,
  FramingBehavior,
  BaseCameraPointersInput,
  CameraInputTypes,
  CameraInputsManager,
  ArcRotateCameraKeyboardMoveInput,
  ArcRotateCameraMouseWheelInput,
  ArcRotateCameraPointersInput,
  ArcRotateCameraInputsManager,
  TargetCamera,
  ComputeAlpha,
  ComputeBeta,
  ArcRotateCamera
};
//# sourceMappingURL=chunk-QBEPKBRO.js.map
