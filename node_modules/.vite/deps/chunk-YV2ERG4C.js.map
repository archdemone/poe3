{
  "version": 3,
  "sources": ["../../../dev/core/src/PostProcesses/postProcessManager.ts", "../../../dev/core/src/Rendering/renderingGroup.ts", "../../../dev/core/src/Rendering/renderingManager.ts", "../../../dev/core/src/Rendering/objectRenderer.ts", "../../../dev/core/src/Materials/Textures/renderTargetTexture.ts", "../../../dev/core/src/PostProcesses/postProcess.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { PostProcess } from \"./postProcess\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * PostProcessManager is used to manage one or more post processes or post process pipelines\r\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses\r\n */\r\nexport class PostProcessManager {\r\n    private _scene: Scene;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param scene The scene that the post process is associated with.\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n    }\r\n\r\n    private _prepareBuffers(): void {\r\n        if (this._vertexBuffers[VertexBuffer.PositionKind]) {\r\n            return;\r\n        }\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._buildIndexBuffer();\r\n    }\r\n\r\n    private _buildIndexBuffer(): void {\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\r\n    }\r\n\r\n    public onBeforeRenderObservable = new Observable<PostProcessManager>();\r\n\r\n    /**\r\n     * Rebuilds the vertex buffers of the manager.\r\n     * @internal\r\n     */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (!vb) {\r\n            return;\r\n        }\r\n        vb._rebuild();\r\n        this._buildIndexBuffer();\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Prepares a frame to be run through a post process.\r\n     * @param sourceTexture The input texture to the post processes. (default: null)\r\n     * @param postProcesses An array of post processes to be run. (default: null)\r\n     * @returns True if the post processes were able to be run.\r\n     * @internal\r\n     */\r\n    public _prepareFrame(sourceTexture: Nullable<InternalTexture> = null, postProcesses: Nullable<PostProcess[]> = null): boolean {\r\n        const camera = this._scene.activeCamera;\r\n        if (!camera) {\r\n            return false;\r\n        }\r\n\r\n        postProcesses = postProcesses || <Nullable<PostProcess[]>>camera._postProcesses.filter((pp) => {\r\n                return pp != null;\r\n            });\r\n\r\n        if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\r\n            return false;\r\n        }\r\n\r\n        postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== undefined);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Manually render a set of post processes to a texture.\r\n     * Please note, the frame buffer won't be unbound after the call in case you have more render to do.\r\n     * @param postProcesses An array of post processes to be run.\r\n     * @param targetTexture The render target wrapper to render to.\r\n     * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight\r\n     * @param faceIndex defines the face to render to if a cubemap is defined as the target\r\n     * @param lodLevel defines which lod of the texture to render to\r\n     * @param doNotBindFrambuffer If set to true, assumes that the framebuffer has been bound previously\r\n     * @param numPostsProcesses The number of post processes to render. Defaults to the length of the postProcesses array.\r\n     */\r\n    public directRender(\r\n        postProcesses: PostProcess[],\r\n        targetTexture: Nullable<RenderTargetWrapper> = null,\r\n        forceFullscreenViewport = false,\r\n        faceIndex = 0,\r\n        lodLevel = 0,\r\n        doNotBindFrambuffer = false,\r\n        numPostsProcesses = postProcesses.length\r\n    ): void {\r\n        const engine = this._scene.getEngine();\r\n\r\n        for (let index = 0; index < numPostsProcesses; index++) {\r\n            if (index < postProcesses.length - 1) {\r\n                postProcesses[index + 1].activate(this._scene.activeCamera || this._scene, targetTexture?.texture);\r\n            } else {\r\n                if (targetTexture) {\r\n                    engine.bindFramebuffer(targetTexture, faceIndex, undefined, undefined, forceFullscreenViewport, lodLevel);\r\n                } else if (!doNotBindFrambuffer) {\r\n                    engine.restoreDefaultFramebuffer();\r\n                }\r\n                engine._debugInsertMarker?.(`post process ${postProcesses[index].name} output`);\r\n            }\r\n\r\n            const pp = postProcesses[index];\r\n            const effect = pp.apply();\r\n\r\n            if (effect) {\r\n                pp.onBeforeRenderObservable.notifyObservers(effect);\r\n\r\n                // VBOs\r\n                this._prepareBuffers();\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, 6);\r\n\r\n                pp.onAfterRenderObservable.notifyObservers(effect);\r\n            }\r\n        }\r\n\r\n        // Restore depth buffer\r\n        engine.setDepthBuffer(true);\r\n        engine.setDepthWrite(true);\r\n    }\r\n\r\n    /**\r\n     * Finalize the result of the output of the postprocesses.\r\n     * @param doNotPresent If true the result will not be displayed to the screen.\r\n     * @param targetTexture The render target wrapper to render to.\r\n     * @param faceIndex The index of the face to bind the target texture to.\r\n     * @param postProcesses The array of post processes to render.\r\n     * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight (default: false)\r\n     * @internal\r\n     */\r\n    public _finalizeFrame(\r\n        doNotPresent?: boolean,\r\n        targetTexture?: RenderTargetWrapper,\r\n        faceIndex?: number,\r\n        postProcesses?: Array<PostProcess>,\r\n        forceFullscreenViewport = false\r\n    ): void {\r\n        const camera = this._scene.activeCamera;\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeRenderObservable.notifyObservers(this);\r\n\r\n        postProcesses =\r\n            postProcesses ||\r\n            camera._postProcesses.filter((pp) => {\r\n                return pp != null;\r\n            });\r\n        if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\r\n            return;\r\n        }\r\n        const engine = this._scene.getEngine();\r\n\r\n        for (let index = 0, len = postProcesses.length; index < len; index++) {\r\n            const pp = postProcesses[index];\r\n\r\n            if (index < len - 1) {\r\n                pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture?.texture);\r\n            } else {\r\n                if (targetTexture) {\r\n                    engine.bindFramebuffer(targetTexture, faceIndex, undefined, undefined, forceFullscreenViewport);\r\n                    pp._outputTexture = targetTexture;\r\n                } else {\r\n                    engine.restoreDefaultFramebuffer();\r\n                    pp._outputTexture = null;\r\n                }\r\n                engine._debugInsertMarker?.(`post process ${postProcesses[index].name} output`);\r\n            }\r\n\r\n            if (doNotPresent) {\r\n                break;\r\n            }\r\n\r\n            const effect = pp.apply();\r\n\r\n            if (effect) {\r\n                pp.onBeforeRenderObservable.notifyObservers(effect);\r\n\r\n                // VBOs\r\n                this._prepareBuffers();\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, 6);\r\n\r\n                pp.onAfterRenderObservable.notifyObservers(effect);\r\n            }\r\n        }\r\n\r\n        // Restore states\r\n        engine.setDepthBuffer(true);\r\n        engine.setDepthWrite(true);\r\n        engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the post process manager.\r\n     */\r\n    public dispose(): void {\r\n        const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (buffer) {\r\n            buffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n    }\r\n}\r\n", "import { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Nullable, DeepImmutable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport type { IEdgesRenderer } from \"./edgesRenderer\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\n/**\r\n * This represents the object necessary to create a rendering group.\r\n * This is exclusively used and created by the rendering manager.\r\n * To modify the behavior, you use the available helpers in your scene or meshes.\r\n * @internal\r\n */\r\nexport class RenderingGroup {\r\n    private static _ZeroVector: DeepImmutable<Vector3> = Vector3.Zero();\r\n    private _scene: Scene;\r\n    private _opaqueSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _transparentSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _alphaTestSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _depthOnlySubMeshes = new SmartArray<SubMesh>(256);\r\n    private _particleSystems = new SmartArray<IParticleSystem>(256);\r\n    private _spriteManagers = new SmartArray<ISpriteManager>(256);\r\n\r\n    private _opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;\r\n    private _alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;\r\n    private _transparentSortCompareFn: (a: SubMesh, b: SubMesh) => number;\r\n\r\n    private _renderOpaque: (subMeshes: SmartArray<SubMesh>) => void;\r\n    private _renderAlphaTest: (subMeshes: SmartArray<SubMesh>) => void;\r\n    private _renderTransparent: (subMeshes: SmartArray<SubMesh>) => void;\r\n\r\n    /** @internal */\r\n    public _empty = true;\r\n\r\n    /** @internal */\r\n    public _edgesRenderers = new SmartArrayNoDuplicate<IEdgesRenderer>(16);\r\n\r\n    public onBeforeTransparentRendering: () => void;\r\n\r\n    public disableDepthPrePass = false;\r\n\r\n    /**\r\n     * Set the opaque sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set opaqueSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._opaqueSortCompareFn = value;\r\n        } else {\r\n            this._opaqueSortCompareFn = RenderingGroup.PainterSortCompare;\r\n        }\r\n        this._renderOpaque = this._renderOpaqueSorted;\r\n    }\r\n\r\n    /**\r\n     * Set the alpha test sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set alphaTestSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._alphaTestSortCompareFn = value;\r\n        } else {\r\n            this._alphaTestSortCompareFn = RenderingGroup.PainterSortCompare;\r\n        }\r\n        this._renderAlphaTest = this._renderAlphaTestSorted;\r\n    }\r\n\r\n    /**\r\n     * Set the transparent sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set transparentSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._transparentSortCompareFn = value;\r\n        } else {\r\n            this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\r\n        }\r\n        this._renderTransparent = this._renderTransparentSorted;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rendering group.\r\n     * @param index The rendering group index\r\n     * @param scene\r\n     * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\r\n     * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\r\n     * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\r\n     */\r\n    constructor(\r\n        public index: number,\r\n        scene: Scene,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ) {\r\n        this._scene = scene;\r\n\r\n        this.opaqueSortCompareFn = opaqueSortCompareFn;\r\n        this.alphaTestSortCompareFn = alphaTestSortCompareFn;\r\n        this.transparentSortCompareFn = transparentSortCompareFn;\r\n    }\r\n\r\n    /**\r\n     * Render all the sub meshes contained in the group.\r\n     * @param customRenderFunction Used to override the default render behaviour of the group.\r\n     * @param renderSprites\r\n     * @param renderParticles\r\n     * @param activeMeshes\r\n     */\r\n    public render(\r\n        customRenderFunction: Nullable<\r\n            (\r\n                opaqueSubMeshes: SmartArray<SubMesh>,\r\n                transparentSubMeshes: SmartArray<SubMesh>,\r\n                alphaTestSubMeshes: SmartArray<SubMesh>,\r\n                depthOnlySubMeshes: SmartArray<SubMesh>\r\n            ) => void\r\n        >,\r\n        renderSprites: boolean,\r\n        renderParticles: boolean,\r\n        activeMeshes: Nullable<AbstractMesh[]>\r\n    ): void {\r\n        if (customRenderFunction) {\r\n            customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Depth only\r\n        if (this._depthOnlySubMeshes.length !== 0) {\r\n            engine.setColorWrite(false);\r\n            this._renderAlphaTest(this._depthOnlySubMeshes);\r\n            engine.setColorWrite(true);\r\n        }\r\n\r\n        // Opaque\r\n        if (this._opaqueSubMeshes.length !== 0) {\r\n            this._renderOpaque(this._opaqueSubMeshes);\r\n        }\r\n\r\n        // Alpha test\r\n        if (this._alphaTestSubMeshes.length !== 0) {\r\n            this._renderAlphaTest(this._alphaTestSubMeshes);\r\n        }\r\n\r\n        const stencilState = engine.getStencilBuffer();\r\n        engine.setStencilBuffer(false);\r\n\r\n        // Sprites\r\n        if (renderSprites) {\r\n            this._renderSprites();\r\n        }\r\n\r\n        // Particles\r\n        if (renderParticles) {\r\n            this._renderParticles(activeMeshes);\r\n        }\r\n\r\n        if (this.onBeforeTransparentRendering) {\r\n            this.onBeforeTransparentRendering();\r\n        }\r\n\r\n        // Transparent\r\n        if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {\r\n            engine.setStencilBuffer(stencilState);\r\n            if (this._scene.useOrderIndependentTransparency) {\r\n                const excludedMeshes = this._scene.depthPeelingRenderer!.render(this._transparentSubMeshes);\r\n                if (excludedMeshes.length) {\r\n                    // Render leftover meshes that could not be processed by depth peeling\r\n                    this._renderTransparent(excludedMeshes);\r\n                }\r\n            } else {\r\n                this._renderTransparent(this._transparentSubMeshes);\r\n            }\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Set back stencil to false in case it changes before the edge renderer.\r\n        engine.setStencilBuffer(false);\r\n\r\n        // Edges\r\n        if (this._edgesRenderers.length) {\r\n            for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\r\n                this._edgesRenderers.data[edgesRendererIndex].render();\r\n            }\r\n\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Restore Stencil state.\r\n        engine.setStencilBuffer(stencilState);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderOpaqueSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false, this.disableDepthPrePass);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderAlphaTestSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false, this.disableDepthPrePass);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the transparentSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderTransparentSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true, this.disableDepthPrePass);\r\n    }\r\n\r\n    /**\r\n     * Renders the submeshes in a specified order.\r\n     * @param subMeshes The submeshes to sort before render\r\n     * @param sortCompareFn The comparison function use to sort\r\n     * @param camera The camera position use to preprocess the submeshes to help sorting\r\n     * @param transparent Specifies to activate blending if true\r\n     * @param disableDepthPrePass Specifies to disable depth pre-pass if true (default: false)\r\n     */\r\n    private static _RenderSorted(\r\n        subMeshes: SmartArray<SubMesh>,\r\n        sortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>,\r\n        camera: Nullable<Camera>,\r\n        transparent: boolean,\r\n        disableDepthPrePass?: boolean\r\n    ): void {\r\n        let subIndex = 0;\r\n        let subMesh: SubMesh;\r\n        const cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;\r\n\r\n        if (transparent) {\r\n            for (; subIndex < subMeshes.length; subIndex++) {\r\n                subMesh = subMeshes.data[subIndex];\r\n                subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\r\n                subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\r\n            }\r\n        }\r\n\r\n        const sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);\r\n\r\n        if (sortCompareFn) {\r\n            sortedArray.sort(sortCompareFn);\r\n        }\r\n\r\n        const scene = sortedArray[0].getMesh().getScene();\r\n        for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\r\n            subMesh = sortedArray[subIndex];\r\n\r\n            if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {\r\n                continue;\r\n            }\r\n\r\n            if (transparent) {\r\n                const material = subMesh.getMaterial();\r\n\r\n                if (material && material.needDepthPrePass && !disableDepthPrePass) {\r\n                    const engine = material.getScene().getEngine();\r\n                    engine.setColorWrite(false);\r\n                    engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n                    subMesh.render(false);\r\n                    engine.setColorWrite(true);\r\n                }\r\n            }\r\n\r\n            subMesh.render(transparent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered back to front if in the same alpha index.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static defaultTransparentSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Alpha index first\r\n        if (a._alphaIndex > b._alphaIndex) {\r\n            return 1;\r\n        }\r\n        if (a._alphaIndex < b._alphaIndex) {\r\n            return -1;\r\n        }\r\n\r\n        // Then distance to camera\r\n        return RenderingGroup.backToFrontSortCompare(a, b);\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered back to front.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static backToFrontSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Then distance to camera\r\n        if (a._distanceToCamera < b._distanceToCamera) {\r\n            return 1;\r\n        }\r\n        if (a._distanceToCamera > b._distanceToCamera) {\r\n            return -1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered front to back (prevent overdraw).\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static frontToBackSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Then distance to camera\r\n        if (a._distanceToCamera < b._distanceToCamera) {\r\n            return -1;\r\n        }\r\n        if (a._distanceToCamera > b._distanceToCamera) {\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are grouped by material then geometry.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    public static PainterSortCompare(a: SubMesh, b: SubMesh): number {\r\n        const meshA = a.getMesh();\r\n        const meshB = b.getMesh();\r\n\r\n        if (meshA.material && meshB.material) {\r\n            return meshA.material.uniqueId - meshB.material.uniqueId;\r\n        }\r\n\r\n        return meshA.uniqueId - meshB.uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Resets the different lists of submeshes to prepare a new frame.\r\n     */\r\n    public prepare(): void {\r\n        this._opaqueSubMeshes.reset();\r\n        this._transparentSubMeshes.reset();\r\n        this._alphaTestSubMeshes.reset();\r\n        this._depthOnlySubMeshes.reset();\r\n        this._particleSystems.reset();\r\n        this.prepareSprites();\r\n        this._edgesRenderers.reset();\r\n        this._empty = true;\r\n    }\r\n\r\n    /**\r\n     * Resets the different lists of sprites to prepare a new frame.\r\n     */\r\n    public prepareSprites(): void {\r\n        this._spriteManagers.reset();\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._opaqueSubMeshes.dispose();\r\n        this._transparentSubMeshes.dispose();\r\n        this._alphaTestSubMeshes.dispose();\r\n        this._depthOnlySubMeshes.dispose();\r\n        this._particleSystems.dispose();\r\n        this._spriteManagers.dispose();\r\n        this._edgesRenderers.dispose();\r\n    }\r\n\r\n    /**\r\n     * Inserts the submesh in its correct queue depending on its material.\r\n     * @param subMesh The submesh to dispatch\r\n     * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        // Get mesh and materials if not provided\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        if (material === undefined) {\r\n            material = subMesh.getMaterial();\r\n        }\r\n\r\n        if (material === null || material === undefined) {\r\n            return;\r\n        }\r\n\r\n        if (material.needAlphaBlendingForMesh(mesh)) {\r\n            // Transparent\r\n            this._transparentSubMeshes.push(subMesh);\r\n        } else if (material.needAlphaTestingForMesh(mesh)) {\r\n            // Alpha test\r\n            if (material.needDepthPrePass && !this.disableDepthPrePass) {\r\n                this._depthOnlySubMeshes.push(subMesh);\r\n            }\r\n\r\n            this._alphaTestSubMeshes.push(subMesh);\r\n        } else {\r\n            if (material.needDepthPrePass && !this.disableDepthPrePass) {\r\n                this._depthOnlySubMeshes.push(subMesh);\r\n            }\r\n\r\n            this._opaqueSubMeshes.push(subMesh); // Opaque\r\n        }\r\n\r\n        mesh._renderingGroup = this;\r\n\r\n        if (mesh._edgesRenderer && mesh.isEnabled() && mesh.isVisible && mesh._edgesRenderer.isEnabled) {\r\n            this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\r\n        }\r\n\r\n        this._empty = false;\r\n    }\r\n\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        this._spriteManagers.push(spriteManager);\r\n        this._empty = false;\r\n    }\r\n\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        this._particleSystems.push(particleSystem);\r\n        this._empty = false;\r\n    }\r\n\r\n    private _renderParticles(activeMeshes: Nullable<AbstractMesh[]>): void {\r\n        if (this._particleSystems.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Particles\r\n        const activeCamera = this._scene.activeCamera;\r\n        this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\r\n        for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\r\n            const particleSystem = this._particleSystems.data[particleIndex];\r\n\r\n            if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\r\n                continue;\r\n            }\r\n\r\n            const emitter: any = particleSystem.emitter;\r\n            if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\r\n                this._scene._activeParticles.addCount(particleSystem.render(), false);\r\n            }\r\n        }\r\n        this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\r\n    }\r\n\r\n    private _renderSprites(): void {\r\n        if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Sprites\r\n        const activeCamera = this._scene.activeCamera;\r\n        this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\r\n        for (let id = 0; id < this._spriteManagers.length; id++) {\r\n            const spriteManager = this._spriteManagers.data[id];\r\n\r\n            if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\r\n                spriteManager.render();\r\n            }\r\n        }\r\n        this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { RenderingGroup } from \"./renderingGroup\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/**\r\n * Interface describing the different options available in the rendering manager\r\n * regarding Auto Clear between groups.\r\n */\r\nexport interface IRenderingManagerAutoClearSetup {\r\n    /**\r\n     * Defines whether or not autoclear is enable.\r\n     */\r\n    autoClear: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the depth buffer.\r\n     */\r\n    depth: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the stencil buffer.\r\n     */\r\n    stencil: boolean;\r\n}\r\n\r\n/**\r\n * This class is used by the onRenderingGroupObservable\r\n */\r\nexport class RenderingGroupInfo {\r\n    /**\r\n     * The Scene that being rendered\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * The camera currently used for the rendering pass\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The ID of the renderingGroup being processed\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * The rendering manager\r\n     */\r\n    renderingManager: RenderingManager;\r\n}\r\n\r\n/**\r\n * This is the manager responsible of all the rendering for meshes sprites and particles.\r\n * It is enable to manage the different groups as well as the different necessary sort functions.\r\n * This should not be used directly aside of the few static configurations\r\n */\r\nexport class RenderingManager {\r\n    /**\r\n     * The max id used for rendering groups (not included)\r\n     */\r\n    public static MAX_RENDERINGGROUPS = 4;\r\n\r\n    /**\r\n     * The min id used for rendering groups (included)\r\n     */\r\n    public static MIN_RENDERINGGROUPS = 0;\r\n\r\n    /**\r\n     * Used to globally prevent autoclearing scenes.\r\n     */\r\n    public static AUTOCLEAR = true;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _useSceneAutoClearSetup = false;\r\n\r\n    private _disableDepthPrePass = false;\r\n    /**\r\n     * Specifies to disable depth pre-pass if true (default: false)\r\n     */\r\n    public get disableDepthPrePass() {\r\n        return this._disableDepthPrePass;\r\n    }\r\n\r\n    public set disableDepthPrePass(value: boolean) {\r\n        this._disableDepthPrePass = value;\r\n        for (const group of this._renderingGroups) {\r\n            group.disableDepthPrePass = value;\r\n        }\r\n    }\r\n\r\n    private _scene: Scene;\r\n    private _renderingGroups = new Array<RenderingGroup>();\r\n    private _depthStencilBufferAlreadyCleaned: boolean;\r\n\r\n    private _autoClearDepthStencil: { [id: number]: IRenderingManagerAutoClearSetup } = {};\r\n    private _customOpaqueSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customAlphaTestSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customTransparentSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _renderingGroupInfo: Nullable<RenderingGroupInfo> = new RenderingGroupInfo();\r\n\r\n    private _maintainStateBetweenFrames = false;\r\n    /**\r\n     * Gets or sets a boolean indicating that the manager will not reset between frames.\r\n     * This means that if a mesh becomes invisible or transparent it will not be visible until this boolean is set to false again.\r\n     * By default, the rendering manager will dispatch all active meshes per frame (moving them to the transparent, opaque or alpha testing lists).\r\n     * By turning this property on, you will accelerate the rendering by keeping all these lists unchanged between frames.\r\n     */\r\n    public get maintainStateBetweenFrames() {\r\n        return this._maintainStateBetweenFrames;\r\n    }\r\n\r\n    public set maintainStateBetweenFrames(value: boolean) {\r\n        if (value === this._maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        this._maintainStateBetweenFrames = value;\r\n        if (!this._maintainStateBetweenFrames) {\r\n            this.restoreDispachedFlags();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore wasDispatched flags on the lists of elements to render.\r\n     */\r\n    public restoreDispachedFlags() {\r\n        for (const mesh of this._scene.meshes) {\r\n            if (mesh.subMeshes) {\r\n                for (const subMesh of mesh.subMeshes) {\r\n                    subMesh._wasDispatched = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._scene.spriteManagers) {\r\n            for (const spriteManager of this._scene.spriteManagers) {\r\n                spriteManager._wasDispatched = false;\r\n            }\r\n        }\r\n\r\n        for (const particleSystem of this._scene.particleSystems) {\r\n            particleSystem._wasDispatched = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new rendering group for a particular scene\r\n     * @param scene Defines the scene the groups belongs to\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n\r\n        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\r\n            this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the rendering group with the specified id.\r\n     * @param id the id of the rendering group (0 by default)\r\n     */\r\n    public getRenderingGroup(id: number): RenderingGroup {\r\n        const renderingGroupId = id || 0;\r\n\r\n        this._prepareRenderingGroup(renderingGroupId);\r\n\r\n        return this._renderingGroups[renderingGroupId];\r\n    }\r\n\r\n    private _clearDepthStencilBuffer(depth = true, stencil = true): void {\r\n        if (this._depthStencilBufferAlreadyCleaned) {\r\n            return;\r\n        }\r\n\r\n        this._scene.getEngine().clear(null, false, depth, stencil);\r\n        this._depthStencilBufferAlreadyCleaned = true;\r\n    }\r\n\r\n    /**\r\n     * Renders the entire managed groups. This is used by the scene or the different render targets.\r\n     * @internal\r\n     */\r\n    public render(\r\n        customRenderFunction: Nullable<\r\n            (\r\n                opaqueSubMeshes: SmartArray<SubMesh>,\r\n                transparentSubMeshes: SmartArray<SubMesh>,\r\n                alphaTestSubMeshes: SmartArray<SubMesh>,\r\n                depthOnlySubMeshes: SmartArray<SubMesh>\r\n            ) => void\r\n        >,\r\n        activeMeshes: Nullable<AbstractMesh[]>,\r\n        renderParticles: boolean,\r\n        renderSprites: boolean\r\n    ): void {\r\n        // Update the observable context (not null as it only goes away on dispose)\r\n        const info = this._renderingGroupInfo!;\r\n        info.scene = this._scene;\r\n        info.camera = this._scene.activeCamera;\r\n        info.renderingManager = this;\r\n\r\n        // Dispatch sprites\r\n        if (this._scene.spriteManagers && renderSprites) {\r\n            for (let index = 0; index < this._scene.spriteManagers.length; index++) {\r\n                const manager = this._scene.spriteManagers[index];\r\n                this.dispatchSprites(manager);\r\n            }\r\n        }\r\n\r\n        // Render\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (!renderingGroup || renderingGroup._empty) {\r\n                continue;\r\n            }\r\n\r\n            const renderingGroupMask = 1 << index;\r\n            info.renderingGroupId = index;\r\n\r\n            // Before Observable\r\n            this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n\r\n            // Clear depth/stencil if needed\r\n            if (RenderingManager.AUTOCLEAR) {\r\n                const autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\r\n\r\n                if (autoClear && autoClear.autoClear) {\r\n                    this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\r\n                }\r\n            }\r\n\r\n            // Render\r\n            for (const step of this._scene._beforeRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n            renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\r\n            for (const step of this._scene._afterRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n\r\n            // After Observable\r\n            this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the different information of the group to prepare a new frame\r\n     * @internal\r\n     */\r\n    public reset(): void {\r\n        if (this.maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.prepare();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the sprites information of the group to prepare a new frame\r\n     * @internal\r\n     */\r\n    public resetSprites(): void {\r\n        if (this.maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.prepareSprites();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the group and its associated resources.\r\n     * @internal\r\n     */\r\n    public dispose(): void {\r\n        this.freeRenderingGroups();\r\n        this._renderingGroups.length = 0;\r\n        this._renderingGroupInfo = null;\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention points during dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _prepareRenderingGroup(renderingGroupId: number): void {\r\n        if (this._renderingGroups[renderingGroupId] === undefined) {\r\n            this._renderingGroups[renderingGroupId] = new RenderingGroup(\r\n                renderingGroupId,\r\n                this._scene,\r\n                this._customOpaqueSortCompareFn[renderingGroupId],\r\n                this._customAlphaTestSortCompareFn[renderingGroupId],\r\n                this._customTransparentSortCompareFn[renderingGroupId]\r\n            );\r\n            this._renderingGroups[renderingGroupId].disableDepthPrePass = this._disableDepthPrePass;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a sprite manager to the rendering manager in order to render it this frame.\r\n     * @param spriteManager Define the sprite manager to render\r\n     */\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        if (this.maintainStateBetweenFrames && spriteManager._wasDispatched) {\r\n            return;\r\n        }\r\n        spriteManager._wasDispatched = true;\r\n        this.getRenderingGroup(spriteManager.renderingGroupId).dispatchSprites(spriteManager);\r\n    }\r\n\r\n    /**\r\n     * Add a particle system to the rendering manager in order to render it this frame.\r\n     * @param particleSystem Define the particle system to render\r\n     */\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        if (this.maintainStateBetweenFrames && particleSystem._wasDispatched) {\r\n            return;\r\n        }\r\n        particleSystem._wasDispatched = true;\r\n        this.getRenderingGroup(particleSystem.renderingGroupId).dispatchParticles(particleSystem);\r\n    }\r\n\r\n    /**\r\n     * Add a submesh to the manager in order to render it this frame\r\n     * @param subMesh The submesh to dispatch\r\n     * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        if (this.maintainStateBetweenFrames && subMesh._wasDispatched) {\r\n            return;\r\n        }\r\n        subMesh._wasDispatched = true;\r\n        this.getRenderingGroup(mesh.renderingGroupId).dispatch(subMesh, mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversely depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(\r\n        renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ) {\r\n        this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\r\n        this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\r\n        this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\r\n\r\n        if (this._renderingGroups[renderingGroupId]) {\r\n            const group = this._renderingGroups[renderingGroupId];\r\n            group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\r\n            group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\r\n            group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth = true, stencil = true): void {\r\n        this._autoClearDepthStencil[renderingGroupId] = {\r\n            autoClear: autoClearDepthStencil,\r\n            depth: depth,\r\n            stencil: stencil,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current auto clear configuration for one rendering group of the rendering\r\n     * manager.\r\n     * @param index the rendering group index to get the information for\r\n     * @returns The auto clear setup for the requested rendering group\r\n     */\r\n    public getAutoClearDepthStencilSetup(index: number): IRenderingManagerAutoClearSetup {\r\n        return this._autoClearDepthStencil[index];\r\n    }\r\n}\r\n", "import type {\r\n    Nullable,\r\n    Immutable,\r\n    Camera,\r\n    Scene,\r\n    AbstractMesh,\r\n    SubMesh,\r\n    Material,\r\n    IParticleSystem,\r\n    InstancedMesh,\r\n    BoundingBox,\r\n    BoundingBoxRenderer,\r\n    UniformBuffer,\r\n    AbstractEngine,\r\n    ClusteredLightContainer,\r\n} from \"core/index\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { RenderingManager } from \"../Rendering/renderingManager\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { _ObserveArray } from \"../Misc/arrayTools\";\r\nimport { _RetryWithInterval } from \"../Misc/timingTools\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { LightConstants } from \"../Lights/lightConstants\";\r\n\r\n/**\r\n * Defines the options of the object renderer\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface ObjectRendererOptions {\r\n    /** The number of passes the renderer will support (1 by default) */\r\n    numPasses?: number;\r\n\r\n    /** True (default) to not change the aspect ratio of the scene in the RTT */\r\n    doNotChangeAspectRatio?: boolean;\r\n\r\n    /** True to enable clustered lights (default: false) */\r\n    enableClusteredLights?: boolean;\r\n}\r\n\r\n/**\r\n * A class that renders objects to the currently bound render target.\r\n * This class only renders objects, and is not concerned with the output texture or post-processing.\r\n */\r\nexport class ObjectRenderer {\r\n    /**\r\n     * Objects will only be rendered once which can be useful to improve performance if everything in your render is static for instance.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONCE: number = 0;\r\n    /**\r\n     * Objects will be rendered every frame and is recommended for dynamic contents.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYFRAME: number = 1;\r\n    /**\r\n     * Objects will be rendered every 2 frames which could be enough if your dynamic objects are not\r\n     * the central point of your effect and can save a lot of performances.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYTWOFRAMES: number = 2;\r\n\r\n    /**\r\n     * Use this predicate to dynamically define the list of mesh you want to render.\r\n     * If set, the renderList property will be overwritten.\r\n     */\r\n    public renderListPredicate: (AbstractMesh: AbstractMesh) => boolean;\r\n\r\n    private _renderList: Nullable<Array<AbstractMesh>>;\r\n    private _unObserveRenderList: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * Use this list to define the list of mesh you want to render.\r\n     */\r\n    public get renderList(): Nullable<Array<AbstractMesh>> {\r\n        return this._renderList;\r\n    }\r\n\r\n    public set renderList(value: Nullable<Array<AbstractMesh>>) {\r\n        if (this._renderList === value) {\r\n            return;\r\n        }\r\n        if (this._unObserveRenderList) {\r\n            this._unObserveRenderList();\r\n            this._unObserveRenderList = null;\r\n        }\r\n\r\n        if (value) {\r\n            this._unObserveRenderList = _ObserveArray(value, this._renderListHasChanged);\r\n        }\r\n\r\n        this._renderList = value;\r\n    }\r\n\r\n    private _renderListHasChanged = (_functionName: string, previousLength: number) => {\r\n        const newLength = this._renderList ? this._renderList.length : 0;\r\n        if ((previousLength === 0 && newLength > 0) || newLength === 0) {\r\n            for (const mesh of this._scene.meshes) {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Define the list of particle systems to render. If not provided, will render all the particle systems of the scene.\r\n     * Note that the particle systems are rendered only if renderParticles is set to true.\r\n     */\r\n    public particleSystemList: Nullable<Array<IParticleSystem>> = null;\r\n\r\n    /**\r\n     * Use this function to overload the renderList array at rendering time.\r\n     * Return null to render with the current renderList, else return the list of meshes to use for rendering.\r\n     * For 2DArray, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of\r\n     * the cube (if the RTT is a cube, else layerOrFace=0).\r\n     * The renderList passed to the function is the current render list (the one that will be used if the function returns null).\r\n     * The length of this list is passed through renderListLength: don't use renderList.length directly because the array can\r\n     * hold dummy elements!\r\n     */\r\n    public getCustomRenderList: Nullable<(layerOrFace: number, renderList: Nullable<Immutable<Array<AbstractMesh>>>, renderListLength: number) => Nullable<Array<AbstractMesh>>> =\r\n        null;\r\n\r\n    /**\r\n     * Define if particles should be rendered.\r\n     */\r\n    public renderParticles = true;\r\n\r\n    /**\r\n     * Define if sprites should be rendered.\r\n     */\r\n    public renderSprites = false;\r\n\r\n    /**\r\n     * Force checking the layerMask property even if a custom list of meshes is provided (ie. if renderList is not undefined)\r\n     */\r\n    public forceLayerMaskCheck = false;\r\n\r\n    /**\r\n     * Enables the rendering of bounding boxes for meshes (still subject to Mesh.showBoundingBox or scene.forceShowBoundingBoxes). Default is false.\r\n     */\r\n    public enableBoundingBoxRendering = false;\r\n\r\n    /**\r\n     * Enables the rendering of outline/overlay for meshes (still subject to Mesh.renderOutline/Mesh.renderOverlay). Default is true.\r\n     */\r\n    public enableOutlineRendering = true;\r\n\r\n    /**\r\n     * Define the camera used to render the objects.\r\n     */\r\n    public activeCamera: Nullable<Camera>;\r\n\r\n    /**\r\n     * Define the camera used to calculate the LOD of the objects.\r\n     * If not defined, activeCamera will be used. If not defined nor activeCamera, scene's active camera will be used.\r\n     */\r\n    public cameraForLOD: Nullable<Camera>;\r\n\r\n    private _disableImageProcessing = false;\r\n    /**\r\n     * If true, the object renderer will render all objects without any image processing applied.\r\n     * If false (default value), the renderer will use the current setting of the scene's image processing configuration.\r\n     */\r\n    public get disableImageProcessing() {\r\n        return this._disableImageProcessing;\r\n    }\r\n\r\n    public set disableImageProcessing(value: boolean) {\r\n        if (value === this._disableImageProcessing) {\r\n            return;\r\n        }\r\n\r\n        this._disableImageProcessing = value;\r\n        this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_ImageProcessingDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * If true, the object renderer will not set the view/projection/transformation matrices for the active camera (default: false).\r\n     * By default, the view/projection/transformation matrices are set from the active camera (either ObjectRenderer.activeCamera or scene.activeCamera).\r\n     * Sets this property to true if you want to define your own transformation matrices (use the onInitRenderingObservable observable\r\n     * to set your own matrices, to be sure they will be correctly taken into account)\r\n     */\r\n    public dontSetTransformationMatrix = false;\r\n\r\n    private _disableDepthPrePass = false;\r\n    /**\r\n     * Specifies to disable depth pre-pass if true (default: false)\r\n     */\r\n    public get disableDepthPrePass() {\r\n        return this._disableDepthPrePass;\r\n    }\r\n\r\n    public set disableDepthPrePass(value: boolean) {\r\n        this._disableDepthPrePass = value;\r\n        this._renderingManager.disableDepthPrePass = value;\r\n    }\r\n\r\n    /**\r\n     * Override the mesh isReady function with your own one.\r\n     */\r\n    public customIsReadyFunction: (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => boolean;\r\n\r\n    /**\r\n     * Override the render function with your own one.\r\n     */\r\n    public customRenderFunction: (\r\n        opaqueSubMeshes: SmartArray<SubMesh>,\r\n        alphaTestSubMeshes: SmartArray<SubMesh>,\r\n        transparentSubMeshes: SmartArray<SubMesh>,\r\n        depthOnlySubMeshes: SmartArray<SubMesh>,\r\n        beforeTransparents?: () => void\r\n    ) => void;\r\n\r\n    /**\r\n     * An event triggered before rendering the objects\r\n     */\r\n    public readonly onBeforeRenderObservable = new Observable<number>();\r\n\r\n    /**\r\n     * An event triggered after rendering the objects\r\n     */\r\n    public readonly onAfterRenderObservable = new Observable<number>();\r\n\r\n    /**\r\n     * An event triggered before the rendering group is processed\r\n     */\r\n    public readonly onBeforeRenderingManagerRenderObservable = new Observable<number>();\r\n\r\n    /**\r\n     * An event triggered after the rendering group is processed\r\n     */\r\n    public readonly onAfterRenderingManagerRenderObservable = new Observable<number>();\r\n\r\n    /**\r\n     * An event triggered when initRender is called\r\n     */\r\n    public readonly onInitRenderingObservable = new Observable<ObjectRenderer>();\r\n\r\n    /**\r\n     * An event triggered when finishRender is called\r\n     */\r\n    public readonly onFinishRenderingObservable = new Observable<ObjectRenderer>();\r\n\r\n    /**\r\n     * An event triggered when fast path rendering is used\r\n     */\r\n    public readonly onFastPathRenderObservable = new Observable<number>();\r\n\r\n    protected _engine: AbstractEngine;\r\n    protected _scene: Scene;\r\n    protected _renderingManager: RenderingManager;\r\n    /** @internal */\r\n    public _waitingRenderList?: string[];\r\n    protected _currentRefreshId = -1;\r\n    protected _refreshRate = 1;\r\n    protected _currentApplyByPostProcessSetting = false;\r\n    protected _activeMeshes = new SmartArray<AbstractMesh>(256);\r\n    protected _activeBoundingBoxes = new SmartArray<BoundingBox>(32);\r\n    protected _useUBO: boolean;\r\n    protected _sceneUBOs: UniformBuffer[]; // It's an array because we may need multiple ubos per frame if the object renderer is used several times in a frame (e.g. for rigged cameras)\r\n    protected _currentSceneUBO: UniformBuffer;\r\n    protected _currentFrameId = -1;\r\n    protected _currentSceneUBOIndex = 0;\r\n\r\n    /**\r\n     * The options used by the object renderer\r\n     */\r\n    public options: Required<ObjectRendererOptions>;\r\n\r\n    private _name: string;\r\n    /**\r\n     * Friendly name of the object renderer\r\n     */\r\n    public get name() {\r\n        return this._name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        if (this._name === value) {\r\n            return;\r\n        }\r\n\r\n        this._name = value;\r\n        if (this._sceneUBOs) {\r\n            for (let i = 0; i < this._sceneUBOs.length; ++i) {\r\n                this._sceneUBOs[i].name = `Scene ubo #${i} for ${this.name}`;\r\n            }\r\n        }\r\n\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < this._renderPassIds.length; ++i) {\r\n            const renderPassId = this._renderPassIds[i];\r\n            this._engine._renderPassNames[renderPassId] = `${this._name}#${i}`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Current render pass id. Note it can change over the rendering as there's a separate id for each face of a cube / each layer of an array layer!\r\n     */\r\n    public renderPassId: number;\r\n    private readonly _renderPassIds: number[];\r\n    /**\r\n     * Gets the render pass ids used by the object renderer.\r\n     */\r\n    public get renderPassIds(): readonly number[] {\r\n        return this._renderPassIds;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the refreshId counter\r\n     */\r\n    public get currentRefreshId() {\r\n        return this._currentRefreshId;\r\n    }\r\n\r\n    /**\r\n     * Gets the array of active meshes\r\n     * @returns an array of AbstractMesh\r\n     */\r\n    public getActiveMeshes(): SmartArray<AbstractMesh> {\r\n        return this._activeMeshes;\r\n    }\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes with this object renderer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material or array of materials to use for this render pass. If undefined is passed, no specific material will be used but the regular material instead (mesh.material). It's possible to provide an array of materials to use a different material for each rendering pass.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material | Material[]): void {\r\n        let meshes;\r\n        if (!Array.isArray(mesh)) {\r\n            meshes = [mesh];\r\n        } else {\r\n            meshes = mesh;\r\n        }\r\n        for (let j = 0; j < meshes.length; ++j) {\r\n            for (let i = 0; i < this.options.numPasses; ++i) {\r\n                let mesh = meshes[j];\r\n                if (meshes[j].isAnInstance) {\r\n                    mesh = (meshes[j] as InstancedMesh).sourceMesh;\r\n                }\r\n                mesh.setMaterialForRenderPass(this._renderPassIds[i], material !== undefined ? (Array.isArray(material) ? material[i] : material) : undefined);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _isFrozen = false;\r\n\r\n    /** @internal */\r\n    public _freezeActiveMeshesCancel: Nullable<() => void> = null;\r\n\r\n    /** @internal */\r\n    public _freezeActiveMeshes(freezeMeshes: boolean) {\r\n        this._freezeActiveMeshesCancel = _RetryWithInterval(\r\n            () => {\r\n                return this._checkReadiness();\r\n            },\r\n            () => {\r\n                this._freezeActiveMeshesCancel = null;\r\n                if (freezeMeshes) {\r\n                    for (let index = 0; index < this._activeMeshes.length; index++) {\r\n                        this._activeMeshes.data[index]._freeze();\r\n                    }\r\n                }\r\n                this._prepareRenderingManager(0, true);\r\n                this._isFrozen = true;\r\n            },\r\n            (err, isTimeout) => {\r\n                this._freezeActiveMeshesCancel = null;\r\n                if (!isTimeout) {\r\n                    Logger.Error(\"ObjectRenderer: An unexpected error occurred while waiting for the renderer to be ready.\");\r\n                    if (err) {\r\n                        Logger.Error(err);\r\n                        if (err.stack) {\r\n                            Logger.Error(err.stack);\r\n                        }\r\n                    }\r\n                } else {\r\n                    Logger.Error(`ObjectRenderer: Timeout while waiting for the renderer to be ready.`);\r\n                    if (err) {\r\n                        Logger.Error(err);\r\n                    }\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    /** @internal */\r\n    public _unfreezeActiveMeshes() {\r\n        this._freezeActiveMeshesCancel?.();\r\n        this._freezeActiveMeshesCancel = null;\r\n        for (let index = 0; index < this._activeMeshes.length; index++) {\r\n            this._activeMeshes.data[index]._unFreeze();\r\n        }\r\n        this._isFrozen = false;\r\n    }\r\n\r\n    /**\r\n     * Instantiates an object renderer.\r\n     * @param name The friendly name of the object renderer\r\n     * @param scene The scene the renderer belongs to\r\n     * @param options The options used to create the renderer (optional)\r\n     */\r\n    constructor(name: string, scene: Scene, options?: ObjectRendererOptions) {\r\n        this.name = name;\r\n        this._scene = scene;\r\n        this._engine = this._scene.getEngine();\r\n        this._useUBO = this._engine.supportsUniformBuffers;\r\n        if (this._useUBO) {\r\n            this._sceneUBOs = [];\r\n            this._createSceneUBO();\r\n        }\r\n\r\n        this.renderList = [] as AbstractMesh[];\r\n        this._renderPassIds = [];\r\n\r\n        this.options = {\r\n            numPasses: 1,\r\n            doNotChangeAspectRatio: true,\r\n            enableClusteredLights: false,\r\n            ...options,\r\n        };\r\n\r\n        this._createRenderPassId();\r\n\r\n        this.renderPassId = this._renderPassIds[0];\r\n\r\n        // Rendering groups\r\n        this._renderingManager = new RenderingManager(scene);\r\n        this._renderingManager._useSceneAutoClearSetup = true;\r\n\r\n        if (this.options.enableClusteredLights) {\r\n            this.onInitRenderingObservable.add(() => {\r\n                for (const light of this._scene.lights) {\r\n                    if (light.getTypeID() === LightConstants.LIGHTTYPEID_CLUSTERED_CONTAINER && (light as ClusteredLightContainer).isSupported) {\r\n                        (light as ClusteredLightContainer)._updateBatches(this.activeCamera).render();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        this._scene.addObjectRenderer(this);\r\n    }\r\n\r\n    private _releaseRenderPassId(): void {\r\n        for (let i = 0; i < this.options.numPasses; ++i) {\r\n            this._engine.releaseRenderPassId(this._renderPassIds[i]);\r\n        }\r\n        this._renderPassIds.length = 0;\r\n    }\r\n\r\n    private _createRenderPassId(): void {\r\n        this._releaseRenderPassId();\r\n\r\n        for (let i = 0; i < this.options.numPasses; ++i) {\r\n            this._renderPassIds[i] = this._engine.createRenderPassId(`${this.name}#${i}`);\r\n        }\r\n    }\r\n\r\n    private _createSceneUBO(): void {\r\n        const index = this._sceneUBOs.length;\r\n\r\n        this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene ubo #${index} for ${this.name}`, false));\r\n    }\r\n\r\n    private _getSceneUBO(): UniformBuffer {\r\n        if (this._currentFrameId !== this._engine.frameId) {\r\n            this._currentSceneUBOIndex = 0;\r\n            this._currentFrameId = this._engine.frameId;\r\n        }\r\n\r\n        if (this._currentSceneUBOIndex >= this._sceneUBOs.length) {\r\n            this._createSceneUBO();\r\n        }\r\n\r\n        const ubo = this._sceneUBOs[this._currentSceneUBOIndex++];\r\n        ubo.unbindEffect();\r\n\r\n        return ubo;\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the renderer and start back from scratch.\r\n     * Could be useful to re-render if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Defines the refresh rate of the rendering or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /**\r\n     * Indicates if the renderer should render the current frame.\r\n     * The output is based on the specified refresh rate.\r\n     * @returns true if the renderer should render the current frame\r\n     */\r\n    public shouldRender(): boolean {\r\n        if (this._currentRefreshId === -1) {\r\n            // At least render once\r\n            this._currentRefreshId = 1;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This function will check if the renderer is ready to render (textures are loaded, shaders are compiled)\r\n     * @param viewportWidth defines the width of the viewport\r\n     * @param viewportHeight defines the height of the viewport\r\n     * @returns true if all required resources are ready\r\n     */\r\n    public isReadyForRendering(viewportWidth: number, viewportHeight: number): boolean {\r\n        this.prepareRenderList();\r\n        this.initRender(viewportWidth, viewportHeight);\r\n\r\n        const isReady = this._checkReadiness();\r\n\r\n        this.finishRender();\r\n\r\n        return isReady;\r\n    }\r\n\r\n    /**\r\n     * Makes sure the list of meshes is ready to be rendered\r\n     * You should call this function before \"initRender\", but if you know the render list is ok, you may call \"initRender\" directly\r\n     */\r\n    public prepareRenderList(): void {\r\n        const scene = this._scene;\r\n\r\n        if (this._waitingRenderList) {\r\n            if (!this.renderListPredicate) {\r\n                this.renderList = [];\r\n                for (let index = 0; index < this._waitingRenderList.length; index++) {\r\n                    const id = this._waitingRenderList[index];\r\n                    const mesh = scene.getMeshById(id);\r\n                    if (mesh) {\r\n                        this.renderList.push(mesh);\r\n                    }\r\n                }\r\n            }\r\n            this._waitingRenderList = undefined;\r\n        }\r\n\r\n        // Is predicate defined?\r\n        if (this.renderListPredicate) {\r\n            if (this.renderList) {\r\n                this.renderList.length = 0; // Clear previous renderList\r\n            } else {\r\n                this.renderList = [];\r\n            }\r\n\r\n            const sceneMeshes = this._scene.meshes;\r\n\r\n            for (let index = 0; index < sceneMeshes.length; index++) {\r\n                const mesh = sceneMeshes[index];\r\n                if (this.renderListPredicate(mesh)) {\r\n                    this.renderList.push(mesh);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._currentApplyByPostProcessSetting = this._scene.imageProcessingConfiguration.applyByPostProcess;\r\n        if (this._disableImageProcessing) {\r\n            // we do not use the applyByPostProcess setter to avoid flagging all the materials as \"image processing dirty\"!\r\n            this._scene.imageProcessingConfiguration._applyByPostProcess = this._disableImageProcessing;\r\n        }\r\n    }\r\n\r\n    private _defaultRenderListPrepared: boolean;\r\n    private _currentSceneCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * This method makes sure everything is setup before \"render\" can be called\r\n     * @param viewportWidth Width of the viewport to render to\r\n     * @param viewportHeight Height of the viewport to render to\r\n     */\r\n    public initRender(viewportWidth: number, viewportHeight: number): void {\r\n        const camera: Nullable<Camera> = this.activeCamera ?? this._scene.activeCamera;\r\n\r\n        this._currentSceneCamera = this._scene.activeCamera;\r\n\r\n        if (this._useUBO) {\r\n            this._currentSceneUBO = this._scene.getSceneUniformBuffer();\r\n            this._currentSceneUBO.unbindEffect();\r\n            this._scene.setSceneUniformBuffer(this._getSceneUBO());\r\n        }\r\n\r\n        this.onInitRenderingObservable.notifyObservers(this);\r\n\r\n        if (camera) {\r\n            if (!this.dontSetTransformationMatrix) {\r\n                this._scene.setTransformMatrix(camera.getViewMatrix(), camera.getProjectionMatrix(true));\r\n            }\r\n            this._scene.activeCamera = camera;\r\n            this._engine.setViewport(camera.rigParent ? camera.rigParent.viewport : camera.viewport, viewportWidth, viewportHeight);\r\n        }\r\n\r\n        if (this._useUBO) {\r\n            this._scene.finalizeSceneUbo();\r\n        }\r\n\r\n        this._defaultRenderListPrepared = false;\r\n    }\r\n\r\n    /**\r\n     * This method must be called after the \"render\" call(s), to complete the rendering process.\r\n     */\r\n    public finishRender() {\r\n        const scene = this._scene;\r\n\r\n        if (this._useUBO) {\r\n            this._scene.setSceneUniformBuffer(this._currentSceneUBO);\r\n        }\r\n\r\n        if (this._disableImageProcessing) {\r\n            scene.imageProcessingConfiguration._applyByPostProcess = this._currentApplyByPostProcessSetting;\r\n        }\r\n\r\n        scene.activeCamera = this._currentSceneCamera;\r\n        if (this._currentSceneCamera) {\r\n            if (this.activeCamera && this.activeCamera !== scene.activeCamera) {\r\n                scene.setTransformMatrix(this._currentSceneCamera.getViewMatrix(), this._currentSceneCamera.getProjectionMatrix(true));\r\n            }\r\n            this._engine.setViewport(this._currentSceneCamera.viewport);\r\n        }\r\n\r\n        scene.resetCachedMaterial();\r\n\r\n        this.onFinishRenderingObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Renders all the objects (meshes, particles systems, sprites) to the currently bound render target texture.\r\n     * @param passIndex defines the pass index to use (default: 0)\r\n     * @param skipOnAfterRenderObservable defines a flag to skip raising the onAfterRenderObservable\r\n     */\r\n    public render(passIndex = 0, skipOnAfterRenderObservable = false): void {\r\n        const currentRenderPassId = this._engine.currentRenderPassId;\r\n\r\n        this._engine.currentRenderPassId = this._renderPassIds[passIndex];\r\n\r\n        this.onBeforeRenderObservable.notifyObservers(passIndex);\r\n\r\n        const fastPath = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === Constants.SNAPSHOTRENDERING_FAST;\r\n\r\n        if (!fastPath) {\r\n            const currentRenderList = this._prepareRenderingManager(passIndex);\r\n\r\n            // The cast to \"any\" is to avoid an error in ES6 in case you don't import outlineRenderer\r\n            const outlineRenderer = (this._scene as any).getOutlineRenderer?.();\r\n            const outlineRendererIsEnabled = outlineRenderer?.enabled;\r\n\r\n            if (outlineRenderer) {\r\n                outlineRenderer.enabled = this.enableOutlineRendering;\r\n            }\r\n\r\n            this.onBeforeRenderingManagerRenderObservable.notifyObservers(passIndex);\r\n\r\n            this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);\r\n\r\n            this.onAfterRenderingManagerRenderObservable.notifyObservers(passIndex);\r\n\r\n            if (outlineRenderer) {\r\n                outlineRenderer.enabled = outlineRendererIsEnabled;\r\n            }\r\n        } else {\r\n            this.onFastPathRenderObservable.notifyObservers(passIndex);\r\n        }\r\n\r\n        if (!skipOnAfterRenderObservable) {\r\n            this.onAfterRenderObservable.notifyObservers(passIndex);\r\n        }\r\n\r\n        this._engine.currentRenderPassId = currentRenderPassId;\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkReadiness(): boolean {\r\n        const scene = this._scene;\r\n        const currentRenderPassId = this._engine.currentRenderPassId;\r\n\r\n        let returnValue = true;\r\n\r\n        if (!scene.getViewMatrix()) {\r\n            // We probably didn't execute scene.render() yet, so make sure we have a view/projection matrix setup for the scene\r\n            scene.updateTransformMatrix();\r\n        }\r\n\r\n        const numPasses = this.options.numPasses;\r\n        for (let passIndex = 0; passIndex < numPasses && returnValue; passIndex++) {\r\n            let currentRenderList: Nullable<Array<AbstractMesh>> = null;\r\n            const defaultRenderList = this.renderList ? this.renderList : scene.frameGraph ? scene.meshes : scene.getActiveMeshes().data;\r\n            const defaultRenderListLength = this.renderList ? this.renderList.length : scene.frameGraph ? scene.meshes.length : scene.getActiveMeshes().length;\r\n\r\n            this._engine.currentRenderPassId = this._renderPassIds[passIndex];\r\n\r\n            this.onBeforeRenderObservable.notifyObservers(passIndex);\r\n\r\n            if (this.getCustomRenderList) {\r\n                currentRenderList = this.getCustomRenderList(passIndex, defaultRenderList, defaultRenderListLength);\r\n            }\r\n\r\n            if (!currentRenderList) {\r\n                currentRenderList = defaultRenderList;\r\n            }\r\n\r\n            if (!this.options.doNotChangeAspectRatio) {\r\n                scene.updateTransformMatrix(true);\r\n            }\r\n\r\n            for (let i = 0; i < currentRenderList.length && returnValue; ++i) {\r\n                const mesh = currentRenderList[i];\r\n\r\n                if (!mesh.isEnabled() || mesh.isBlocked || !mesh.isVisible || !mesh.subMeshes) {\r\n                    continue;\r\n                }\r\n\r\n                if (this.customIsReadyFunction) {\r\n                    if (!this.customIsReadyFunction(mesh, this.refreshRate, true)) {\r\n                        returnValue = false;\r\n                        continue;\r\n                    }\r\n                } else if (!mesh.isReady(true)) {\r\n                    returnValue = false;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            this.onAfterRenderObservable.notifyObservers(passIndex);\r\n\r\n            if (numPasses > 1) {\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n            }\r\n        }\r\n\r\n        const particleSystems = this.particleSystemList || scene.particleSystems;\r\n        for (const particleSystem of particleSystems) {\r\n            if (!particleSystem.isReady()) {\r\n                returnValue = false;\r\n            }\r\n        }\r\n\r\n        this._engine.currentRenderPassId = currentRenderPassId;\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    private _prepareRenderingManager(passIndex = 0, winterIsComing = false): Array<AbstractMesh> {\r\n        const scene = this._scene;\r\n\r\n        // Get the list of meshes to dispatch to the rendering manager\r\n        let currentRenderList: Nullable<Array<AbstractMesh>> = null;\r\n        let currentRenderListLength = 0;\r\n        let checkLayerMask = false;\r\n\r\n        const defaultRenderList = this.renderList ? this.renderList : scene.frameGraph ? scene.meshes : scene.getActiveMeshes().data;\r\n        const defaultRenderListLength = this.renderList ? this.renderList.length : scene.frameGraph ? scene.meshes.length : scene.getActiveMeshes().length;\r\n\r\n        if (this.getCustomRenderList) {\r\n            currentRenderList = this.getCustomRenderList(passIndex, defaultRenderList, defaultRenderListLength);\r\n        }\r\n\r\n        if (!currentRenderList) {\r\n            // No custom render list provided, we prepare the rendering for the default list, but check\r\n            // first if we did not already performed the preparation (in this frame) before so as to avoid re-doing it several times\r\n            if (this._defaultRenderListPrepared && !winterIsComing) {\r\n                return defaultRenderList;\r\n            }\r\n            this._defaultRenderListPrepared = true;\r\n            currentRenderList = defaultRenderList;\r\n            currentRenderListLength = defaultRenderListLength;\r\n            checkLayerMask = !this.renderList || this.forceLayerMaskCheck;\r\n        } else {\r\n            // Prepare the rendering for the custom render list provided\r\n            currentRenderListLength = currentRenderList.length;\r\n            checkLayerMask = this.forceLayerMaskCheck;\r\n        }\r\n\r\n        const camera = scene.activeCamera; // note that at this point, scene.activeCamera == this.activeCamera if defined, because initRender() has been called before\r\n        const cameraForLOD = this.cameraForLOD ?? camera;\r\n\r\n        // The cast to \"any\" is to avoid an error in ES6 in case you don't import boundingBoxRenderer\r\n        const boundingBoxRenderer = (scene as any).getBoundingBoxRenderer?.() as Nullable<BoundingBoxRenderer>;\r\n\r\n        if (scene._activeMeshesFrozen && this._isFrozen) {\r\n            this._renderingManager.resetSprites();\r\n\r\n            if (this.enableBoundingBoxRendering && boundingBoxRenderer) {\r\n                boundingBoxRenderer.reset();\r\n                for (let i = 0; i < this._activeBoundingBoxes.length; i++) {\r\n                    const boundingBox = this._activeBoundingBoxes.data[i];\r\n                    boundingBoxRenderer.renderList.push(boundingBox);\r\n                }\r\n            }\r\n\r\n            return currentRenderList;\r\n        }\r\n\r\n        this._renderingManager.reset();\r\n        this._activeMeshes.reset();\r\n        this._activeBoundingBoxes.reset();\r\n\r\n        // We do not check option.enableBoundingBoxRendering before resetting the current list of bounding boxes, because:\r\n        // * if bounding box rendering is enabled, we want to start with an empty list and add new bounding boxes to it\r\n        // * if bounding box rendering is disabled, we don't want to render any bounding boxes that may have been generated by previous code\r\n        boundingBoxRenderer && boundingBoxRenderer.reset();\r\n\r\n        const sceneRenderId = scene.getRenderId();\r\n        const currentFrameId = scene.getFrameId();\r\n        for (let meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {\r\n            const mesh = currentRenderList[meshIndex];\r\n\r\n            if (mesh && !mesh.isBlocked) {\r\n                if (this.customIsReadyFunction) {\r\n                    if (!this.customIsReadyFunction(mesh, this.refreshRate, false)) {\r\n                        this.resetRefreshCounter();\r\n                        continue;\r\n                    }\r\n                } else if (!mesh.isReady(this.refreshRate === 0)) {\r\n                    this.resetRefreshCounter();\r\n                    continue;\r\n                }\r\n\r\n                let meshToRender: Nullable<AbstractMesh> = null;\r\n\r\n                if (cameraForLOD) {\r\n                    const meshToRenderAndFrameId = mesh._internalAbstractMeshDataInfo._currentLOD.get(cameraForLOD);\r\n                    if (!meshToRenderAndFrameId || meshToRenderAndFrameId[1] !== currentFrameId) {\r\n                        meshToRender = scene.customLODSelector ? scene.customLODSelector(mesh, cameraForLOD) : mesh.getLOD(cameraForLOD);\r\n                        if (!meshToRenderAndFrameId) {\r\n                            mesh._internalAbstractMeshDataInfo._currentLOD.set(cameraForLOD, [meshToRender, currentFrameId]);\r\n                        } else {\r\n                            meshToRenderAndFrameId[0] = meshToRender;\r\n                            meshToRenderAndFrameId[1] = currentFrameId;\r\n                        }\r\n                    } else {\r\n                        meshToRender = meshToRenderAndFrameId[0];\r\n                    }\r\n                } else {\r\n                    meshToRender = mesh;\r\n                }\r\n\r\n                if (!meshToRender) {\r\n                    continue;\r\n                }\r\n\r\n                if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {\r\n                    meshToRender.computeWorldMatrix(); // Compute world matrix if LOD is billboard\r\n                }\r\n\r\n                meshToRender._preActivateForIntermediateRendering(sceneRenderId);\r\n\r\n                let isMasked;\r\n                if (checkLayerMask && camera) {\r\n                    isMasked = (mesh.layerMask & camera.layerMask) === 0;\r\n                } else {\r\n                    isMasked = false;\r\n                }\r\n\r\n                if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {\r\n                    this._activeMeshes.push(mesh);\r\n                    meshToRender._internalAbstractMeshDataInfo._wasActiveLastFrame = true;\r\n\r\n                    if (meshToRender !== mesh) {\r\n                        meshToRender._activate(sceneRenderId, true);\r\n                    }\r\n\r\n                    this.enableBoundingBoxRendering && boundingBoxRenderer && boundingBoxRenderer._preActiveMesh(mesh);\r\n\r\n                    if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {\r\n                        if (!mesh.isAnInstance) {\r\n                            meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;\r\n                        } else {\r\n                            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\r\n                                meshToRender = mesh;\r\n                            }\r\n                        }\r\n                        meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;\r\n\r\n                        scene._prepareSkeleton(meshToRender);\r\n\r\n                        for (let subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {\r\n                            const subMesh = meshToRender.subMeshes[subIndex];\r\n                            this.enableBoundingBoxRendering && boundingBoxRenderer && boundingBoxRenderer._evaluateSubMesh(mesh, subMesh);\r\n                            this._renderingManager.dispatch(subMesh, meshToRender);\r\n                        }\r\n                    }\r\n\r\n                    mesh._postActivate();\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.enableBoundingBoxRendering && boundingBoxRenderer && winterIsComing) {\r\n            for (let i = 0; i < boundingBoxRenderer.renderList.length; i++) {\r\n                const boundingBox = boundingBoxRenderer.renderList.data[i];\r\n                this._activeBoundingBoxes.push(boundingBox);\r\n            }\r\n        }\r\n\r\n        if (this._scene.particlesEnabled) {\r\n            this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\r\n            const particleSystems = this.particleSystemList || scene.particleSystems;\r\n            for (let particleIndex = 0; particleIndex < particleSystems.length; particleIndex++) {\r\n                const particleSystem = particleSystems[particleIndex];\r\n\r\n                const emitter: any = particleSystem.emitter;\r\n\r\n                if (!particleSystem.isStarted() || !emitter || (emitter.position && !emitter.isEnabled())) {\r\n                    continue;\r\n                }\r\n\r\n                this._renderingManager.dispatchParticles(particleSystem);\r\n            }\r\n            this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\r\n        }\r\n\r\n        return currentRenderList;\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering manager\r\n     */\r\n    public get renderingManager(): RenderingManager {\r\n        return this._renderingManager;\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversely depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(\r\n        renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ): void {\r\n        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth = true, stencil = true): void {\r\n        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\r\n        this._renderingManager._useSceneAutoClearSetup = false;\r\n    }\r\n\r\n    /**\r\n     * Clones the renderer.\r\n     * @returns the cloned renderer\r\n     */\r\n    public clone(): ObjectRenderer {\r\n        const newRenderer = new ObjectRenderer(this.name, this._scene, this.options);\r\n\r\n        if (this.renderList) {\r\n            newRenderer.renderList = this.renderList.slice(0);\r\n        }\r\n\r\n        return newRenderer;\r\n    }\r\n\r\n    /**\r\n     * Dispose the renderer and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const renderList = this.renderList ? this.renderList : this._scene.getActiveMeshes().data;\r\n        const renderListLength = this.renderList ? this.renderList.length : this._scene.getActiveMeshes().length;\r\n        for (let i = 0; i < renderListLength; i++) {\r\n            const mesh = renderList[i];\r\n            if (mesh && mesh.getMaterialForRenderPass(this.renderPassId) !== undefined) {\r\n                mesh.setMaterialForRenderPass(this.renderPassId, undefined);\r\n            }\r\n        }\r\n\r\n        this.onInitRenderingObservable.clear();\r\n        this.onFinishRenderingObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onBeforeRenderingManagerRenderObservable.clear();\r\n        this.onAfterRenderingManagerRenderObservable.clear();\r\n        this.onFastPathRenderObservable.clear();\r\n\r\n        this._releaseRenderPassId();\r\n\r\n        this.renderList = null;\r\n        if (this._sceneUBOs) {\r\n            for (const ubo of this._sceneUBOs) {\r\n                ubo.dispose();\r\n            }\r\n        }\r\n        this._sceneUBOs = undefined as any;\r\n\r\n        this._scene.removeObjectRenderer(this);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this.refreshRate === ObjectRenderer.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = ObjectRenderer.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention point in material dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        if (this._renderingManager) {\r\n            this._renderingManager.freeRenderingGroups();\r\n        }\r\n    }\r\n}\r\n", "import type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { SmartArray } from \"../../Misc/smartArray\";\r\nimport type { Nullable, Immutable } from \"../../types\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport type { RenderTargetCreationOptions, TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { PostProcessManager } from \"../../PostProcesses/postProcessManager\";\r\nimport type { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IRenderTargetTexture, RenderTargetWrapper } from \"../../Engines/renderTargetWrapper\";\r\n\r\nimport type { Material } from \"../material\";\r\nimport { FloorPOT, NearestPOT } from \"../../Misc/tools.functions\";\r\nimport { Effect } from \"../effect\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { IParticleSystem } from \"core/Particles/IParticleSystem\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { ObjectRenderer } from \"core/Rendering/objectRenderer\";\r\n\r\ndeclare module \"../effect\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Effect {\r\n        /**\r\n         * Sets a depth stencil texture from a render target on the engine to be used in the shader.\r\n         * @param channel Name of the sampler variable.\r\n         * @param texture Texture to set.\r\n         */\r\n        setDepthStencilTexture(channel: string, texture: Nullable<RenderTargetTexture>): void;\r\n    }\r\n}\r\n\r\n/**\r\n * Sets a depth stencil texture from a render target on the engine to be used in the shader.\r\n * @param channel Name of the sampler variable.\r\n * @param texture Texture to set.\r\n */\r\nEffect.prototype.setDepthStencilTexture = function (channel: string, texture: Nullable<RenderTargetTexture>): void {\r\n    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\r\n};\r\n\r\n/**\r\n * Options for the RenderTargetTexture constructor\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface RenderTargetTextureOptions {\r\n    /** True (default: false) if mipmaps need to be generated after render */\r\n    generateMipMaps?: boolean;\r\n\r\n    /** True (default) to not change the aspect ratio of the scene in the RTT */\r\n    doNotChangeAspectRatio?: boolean;\r\n\r\n    /** The type of the buffer in the RTT (byte (default), half float, float...) */\r\n    type?: number;\r\n\r\n    /** True (default: false) if a cube texture needs to be created */\r\n    isCube?: boolean;\r\n\r\n    /** The sampling mode to be used with the render target (Trilinear (default), Linear, Nearest...) */\r\n    samplingMode?: number;\r\n\r\n    /** True (default) to generate a depth buffer */\r\n    generateDepthBuffer?: boolean;\r\n\r\n    /** True (default: false) to generate a stencil buffer */\r\n    generateStencilBuffer?: boolean;\r\n\r\n    /** True (default: false) if multiple textures need to be created (Draw Buffers) */\r\n    isMulti?: boolean;\r\n\r\n    /** The internal format of the buffer in the RTT (RED, RG, RGB, RGBA (default), ALPHA...) */\r\n    format?: number;\r\n\r\n    /** True (default: false) if the texture allocation should be delayed */\r\n    delayAllocation?: boolean;\r\n\r\n    /** Sample count to use when creating the RTT */\r\n    samples?: number;\r\n\r\n    /** specific flags to use when creating the texture (e.g., Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures) */\r\n    creationFlags?: number;\r\n\r\n    /** True (default: false) to indicate that no color target should be created. (e.g., if you only want to write to the depth buffer) */\r\n    noColorAttachment?: boolean;\r\n\r\n    /** Specifies the internal texture to use directly instead of creating one (ignores `noColorAttachment` flag when set) **/\r\n    colorAttachment?: InternalTexture;\r\n\r\n    /** True (default: false) to create a SRGB texture */\r\n    useSRGBBuffer?: boolean;\r\n\r\n    /** Defines the underlying texture texture space */\r\n    gammaSpace?: boolean;\r\n\r\n    /** If not provided (default), a new object renderer instance will be created */\r\n    existingObjectRenderer?: ObjectRenderer;\r\n\r\n    /** True to enable clustered lights (default: false) */\r\n    enableClusteredLights?: boolean;\r\n}\r\n\r\n/**\r\n * This Helps creating a texture that will be created from a camera in your scene.\r\n * It is basically a dynamic texture that could be used to create special effects for instance.\r\n * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...\r\n */\r\nexport class RenderTargetTexture extends Texture implements IRenderTargetTexture {\r\n    /**\r\n     * The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONCE: number = ObjectRenderer.REFRESHRATE_RENDER_ONCE;\r\n    /**\r\n     * The texture will be rendered every frame and is recommended for dynamic contents.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYFRAME: number = ObjectRenderer.REFRESHRATE_RENDER_ONEVERYFRAME;\r\n    /**\r\n     * The texture will be rendered every 2 frames which could be enough if your dynamic objects are not\r\n     * the central point of your effect and can save a lot of performances.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYTWOFRAMES: number = ObjectRenderer.REFRESHRATE_RENDER_ONEVERYTWOFRAMES;\r\n\r\n    /**\r\n     * Use this predicate to dynamically define the list of mesh you want to render.\r\n     * If set, the renderList property will be overwritten.\r\n     */\r\n    public get renderListPredicate(): (AbstractMesh: AbstractMesh) => boolean {\r\n        return this._objectRenderer.renderListPredicate;\r\n    }\r\n\r\n    public set renderListPredicate(value: (AbstractMesh: AbstractMesh) => boolean) {\r\n        this._objectRenderer.renderListPredicate = value;\r\n    }\r\n\r\n    /**\r\n     * Use this list to define the list of mesh you want to render.\r\n     */\r\n    public get renderList(): Nullable<Array<AbstractMesh>> {\r\n        return this._objectRenderer.renderList;\r\n    }\r\n\r\n    public set renderList(value: Nullable<Array<AbstractMesh>>) {\r\n        this._objectRenderer.renderList = value;\r\n    }\r\n\r\n    /**\r\n     * Define the list of particle systems to render in the texture. If not provided, will render all the particle systems of the scene.\r\n     * Note that the particle systems are rendered only if renderParticles is set to true.\r\n     */\r\n    public get particleSystemList(): Nullable<Array<IParticleSystem>> {\r\n        return this._objectRenderer.particleSystemList;\r\n    }\r\n\r\n    public set particleSystemList(value: Nullable<Array<IParticleSystem>>) {\r\n        this._objectRenderer.particleSystemList = value;\r\n    }\r\n\r\n    /**\r\n     * Use this function to overload the renderList array at rendering time.\r\n     * Return null to render with the current renderList, else return the list of meshes to use for rendering.\r\n     * For 2DArray RTT, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of\r\n     * the cube (if the RTT is a cube, else layerOrFace=0).\r\n     * The renderList passed to the function is the current render list (the one that will be used if the function returns null).\r\n     * The length of this list is passed through renderListLength: don't use renderList.length directly because the array can\r\n     * hold dummy elements!\r\n     */\r\n    public get getCustomRenderList(): Nullable<\r\n        (layerOrFace: number, renderList: Nullable<Immutable<Array<AbstractMesh>>>, renderListLength: number) => Nullable<Array<AbstractMesh>>\r\n    > {\r\n        return this._objectRenderer.getCustomRenderList;\r\n    }\r\n\r\n    public set getCustomRenderList(\r\n        value: Nullable<(layerOrFace: number, renderList: Nullable<Immutable<Array<AbstractMesh>>>, renderListLength: number) => Nullable<Array<AbstractMesh>>>\r\n    ) {\r\n        this._objectRenderer.getCustomRenderList = value;\r\n    }\r\n\r\n    /**\r\n     * Define if particles should be rendered in your texture (default: true).\r\n     */\r\n    public get renderParticles() {\r\n        return this._objectRenderer.renderParticles;\r\n    }\r\n\r\n    public set renderParticles(value: boolean) {\r\n        this._objectRenderer.renderParticles = value;\r\n    }\r\n\r\n    /**\r\n     * Define if sprites should be rendered in your texture (default: false).\r\n     */\r\n    public get renderSprites() {\r\n        return this._objectRenderer.renderSprites;\r\n    }\r\n\r\n    public set renderSprites(value: boolean) {\r\n        this._objectRenderer.renderSprites = value;\r\n    }\r\n\r\n    /**\r\n     * Define if bounding box rendering should be enabled (still subject to Mesh.showBoundingBox or scene.forceShowBoundingBoxes). (Default: false).\r\n     */\r\n    public get enableBoundingBoxRendering() {\r\n        return this._objectRenderer.enableBoundingBoxRendering;\r\n    }\r\n\r\n    public set enableBoundingBoxRendering(value: boolean) {\r\n        this._objectRenderer.enableBoundingBoxRendering = value;\r\n    }\r\n\r\n    /**\r\n     * Define if outline/overlay rendering should be enabled (still subject to Mesh.renderOutline/Mesh.renderOverlay). (Default: true).\r\n     */\r\n    public get enableOutlineRendering() {\r\n        return this._objectRenderer.enableOutlineRendering;\r\n    }\r\n\r\n    public set enableOutlineRendering(value: boolean) {\r\n        this._objectRenderer.enableOutlineRendering = value;\r\n    }\r\n\r\n    /**\r\n     * Force checking the layerMask property even if a custom list of meshes is provided (ie. if renderList is not undefined) (default: false).\r\n     */\r\n    public get forceLayerMaskCheck() {\r\n        return this._objectRenderer.forceLayerMaskCheck;\r\n    }\r\n\r\n    public set forceLayerMaskCheck(value: boolean) {\r\n        this._objectRenderer.forceLayerMaskCheck = value;\r\n    }\r\n\r\n    /**\r\n     * Define the camera used to render the texture.\r\n     */\r\n    public get activeCamera(): Nullable<Camera> {\r\n        return this._objectRenderer.activeCamera;\r\n    }\r\n\r\n    public set activeCamera(value: Nullable<Camera>) {\r\n        this._objectRenderer.activeCamera = value;\r\n    }\r\n\r\n    /**\r\n     * Define the camera used to calculate the LOD of the objects.\r\n     * If not defined, activeCamera will be used. If not defined nor activeCamera, scene's active camera will be used.\r\n     */\r\n    public get cameraForLOD(): Nullable<Camera> {\r\n        return this._objectRenderer.cameraForLOD;\r\n    }\r\n\r\n    public set cameraForLOD(value: Nullable<Camera>) {\r\n        this._objectRenderer.cameraForLOD = value;\r\n    }\r\n\r\n    /**\r\n     * If true, the renderer will render all objects without any image processing applied.\r\n     * If false (default value), the renderer will use the current setting of the scene's image processing configuration.\r\n     */\r\n    public get disableImageProcessing() {\r\n        return this._objectRenderer.disableImageProcessing;\r\n    }\r\n\r\n    public set disableImageProcessing(value: boolean) {\r\n        this._objectRenderer.disableImageProcessing = value;\r\n    }\r\n\r\n    /**\r\n     * Override the mesh isReady function with your own one.\r\n     */\r\n    public get customIsReadyFunction(): (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => boolean {\r\n        return this._objectRenderer.customIsReadyFunction;\r\n    }\r\n\r\n    public set customIsReadyFunction(value: (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => boolean) {\r\n        this._objectRenderer.customIsReadyFunction = value;\r\n    }\r\n\r\n    /**\r\n     * Override the render function of the texture with your own one.\r\n     */\r\n    public get customRenderFunction(): (\r\n        opaqueSubMeshes: SmartArray<SubMesh>,\r\n        alphaTestSubMeshes: SmartArray<SubMesh>,\r\n        transparentSubMeshes: SmartArray<SubMesh>,\r\n        depthOnlySubMeshes: SmartArray<SubMesh>,\r\n        beforeTransparents?: () => void\r\n    ) => void {\r\n        return this._objectRenderer.customRenderFunction;\r\n    }\r\n\r\n    public set customRenderFunction(\r\n        value: (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>,\r\n            beforeTransparents?: () => void\r\n        ) => void\r\n    ) {\r\n        this._objectRenderer.customRenderFunction = value;\r\n    }\r\n\r\n    /**\r\n     * Define if camera post processes should be use while rendering the texture.\r\n     */\r\n    public useCameraPostProcesses: boolean;\r\n    /**\r\n     * Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.\r\n     */\r\n    public ignoreCameraViewport: boolean = false;\r\n\r\n    private _postProcessManager: Nullable<PostProcessManager>;\r\n\r\n    /**\r\n     * Post-processes for this render target\r\n     */\r\n    public get postProcesses() {\r\n        return this._postProcesses;\r\n    }\r\n    private _postProcesses: PostProcess[];\r\n    private _resizeObserver: Nullable<Observer<AbstractEngine>>;\r\n\r\n    private get _prePassEnabled() {\r\n        return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the texture is unbind.\r\n     */\r\n    public onBeforeBindObservable = new Observable<RenderTargetTexture>();\r\n\r\n    /**\r\n     * An event triggered when the texture is unbind.\r\n     */\r\n    public onAfterUnbindObservable = new Observable<RenderTargetTexture>();\r\n\r\n    private _onAfterUnbindObserver: Nullable<Observer<RenderTargetTexture>>;\r\n    /**\r\n     * Set a after unbind callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.\r\n     */\r\n    public set onAfterUnbind(callback: () => void) {\r\n        if (this._onAfterUnbindObserver) {\r\n            this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\r\n        }\r\n        this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the texture\r\n     */\r\n    public get onBeforeRenderObservable() {\r\n        return this._objectRenderer.onBeforeRenderObservable;\r\n    }\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<number>>;\r\n    /**\r\n     * Set a before render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.\r\n     */\r\n    public set onBeforeRender(callback: (faceIndex: number) => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the texture\r\n     */\r\n    public get onAfterRenderObservable() {\r\n        return this._objectRenderer.onAfterRenderObservable;\r\n    }\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<number>>;\r\n    /**\r\n     * Set a after render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.\r\n     */\r\n    public set onAfterRender(callback: (faceIndex: number) => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after the texture clear\r\n     */\r\n    public onClearObservable = new Observable<AbstractEngine>();\r\n\r\n    private _onClearObserver: Nullable<Observer<AbstractEngine>>;\r\n    /**\r\n     * Set a clear callback in the texture.\r\n     * This has been kept for backward compatibility and use of onClearObservable is recommended.\r\n     */\r\n    public set onClear(callback: (Engine: AbstractEngine) => void) {\r\n        if (this._onClearObserver) {\r\n            this.onClearObservable.remove(this._onClearObserver);\r\n        }\r\n        this._onClearObserver = this.onClearObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the texture is resized.\r\n     */\r\n    public onResizeObservable = new Observable<RenderTargetTexture>();\r\n\r\n    /**\r\n     * Define the clear color of the Render Target if it should be different from the scene.\r\n     */\r\n    public clearColor: Color4;\r\n    /** @internal */\r\n    public _size: TextureSize;\r\n    protected _initialSizeParameter: TextureSize | { ratio: number };\r\n    protected _sizeRatio: Nullable<number>;\r\n    /** @internal */\r\n    public _generateMipMaps: boolean;\r\n    /** @internal */\r\n    public _cleared = false;\r\n    /**\r\n     * Skip the initial clear of the rtt at the beginning of the frame render loop\r\n     */\r\n    public skipInitialClear = false;\r\n    /** @internal */\r\n    public get _waitingRenderList() {\r\n        return this._objectRenderer._waitingRenderList;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _waitingRenderList(value: string[] | undefined) {\r\n        this._objectRenderer._waitingRenderList = value;\r\n    }\r\n\r\n    protected _objectRenderer: ObjectRenderer;\r\n    protected _doNotChangeAspectRatio: boolean;\r\n    protected _textureMatrix: Matrix;\r\n    protected _samples = 1;\r\n    protected _renderTargetOptions: RenderTargetCreationOptions;\r\n    private _canRescale = true;\r\n    protected _renderTarget: Nullable<RenderTargetWrapper> = null;\r\n    private _currentFaceIndex: number;\r\n    private _currentLayer: number;\r\n    private _currentUseCameraPostProcess: boolean;\r\n    private _currentDumpForDebug: boolean;\r\n    private _dontDisposeObjectRenderer = false;\r\n\r\n    /**\r\n     * Current render pass id of the render target texture. Note it can change over the rendering as there's a separate id for each face of a cube / each layer of an array layer!\r\n     */\r\n    public get renderPassId(): number {\r\n        return this._objectRenderer.renderPassId;\r\n    }\r\n\r\n    /**\r\n     * Gets the render pass ids used by the render target texture. For a single render target the array length will be 1, for a cube texture it will be 6 and for\r\n     * a 2D texture array it will return an array of ids the size of the 2D texture array\r\n     */\r\n    public get renderPassIds(): readonly number[] {\r\n        return this._objectRenderer.renderPassIds;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the refreshId counter\r\n     */\r\n    public get currentRefreshId() {\r\n        return this._objectRenderer.currentRefreshId;\r\n    }\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes in this render target texture\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material or array of materials to use for this render pass. If undefined is passed, no specific material will be used but the regular material instead (mesh.material). It's possible to provide an array of materials to use a different material for each rendering in the case of a cube texture (6 rendering) and a 2D texture array (as many rendering as the length of the array)\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material | Material[]): void {\r\n        this._objectRenderer.setMaterialForRendering(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Define if the texture has multiple draw buffers or if false a single draw buffer.\r\n     */\r\n    public get isMulti(): boolean {\r\n        return this._renderTarget?.isMulti ?? false;\r\n    }\r\n\r\n    /**\r\n     * Gets render target creation options that were used.\r\n     */\r\n    public get renderTargetOptions(): RenderTargetCreationOptions {\r\n        return this._renderTargetOptions;\r\n    }\r\n\r\n    /**\r\n     * Gets the render target wrapper associated with this render target\r\n     */\r\n    public get renderTarget(): Nullable<RenderTargetWrapper> {\r\n        return this._renderTarget;\r\n    }\r\n\r\n    protected _onRatioRescale(): void {\r\n        if (this._sizeRatio) {\r\n            this.resize(this._initialSizeParameter);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the texture (when in cube mode)\r\n     * It must define where the camera used to render the texture is set\r\n     */\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the texture (when in cube mode)\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    /**\r\n     * In case the RTT has been created with a depth texture, get the associated\r\n     * depth texture.\r\n     * Otherwise, return null.\r\n     */\r\n    public get depthStencilTexture(): Nullable<InternalTexture> {\r\n        return this._renderTarget?._depthStencilTexture ?? null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _disableEngineStages = false; // TODO: remove this when the shadow generator task (frame graph) is reworked (see https://github.com/BabylonJS/Babylon.js/pull/15962#discussion_r1874417607)\r\n\r\n    private readonly _onBeforeRenderingManagerRenderObserver: Nullable<Observer<number>>;\r\n    private readonly _onAfterRenderingManagerRenderObserver: Nullable<Observer<number>>;\r\n    private readonly _onFastPathRenderObserver: Nullable<Observer<number>>;\r\n\r\n    /**\r\n     * Instantiate a render target texture. This is mainly used to render the scene off screen, to apply (for instance) post processing effects\r\n     * or use a shadow or depth texture...\r\n     * @param name The friendly name of the texture\r\n     * @param size The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)\r\n     * @param scene The scene the RTT belongs to. Default is the last created scene.\r\n     * @param options The options for creating the render target texture.\r\n     */\r\n    constructor(name: string, size: TextureSize | { ratio: number }, scene?: Nullable<Scene>, options?: RenderTargetTextureOptions);\r\n\r\n    /**\r\n     * Instantiate a render target texture. This is mainly used to render the scene off screen, to apply (for instance) post processing effects\r\n     * or use a shadow or depth texture...\r\n     * @param name The friendly name of the texture\r\n     * @param size The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)\r\n     * @param scene The scene the RTT belongs to. Default is the last created scene\r\n     * @param generateMipMaps True (default: false) if mipmaps need to be generated after render\r\n     * @param doNotChangeAspectRatio True (default) to not change the aspect ratio of the scene in the RTT\r\n     * @param type The type of the buffer in the RTT (byte (default), half float, float...)\r\n     * @param isCube True (default: false) if a cube texture needs to be created\r\n     * @param samplingMode The sampling mode to be used with the render target (Trilinear (default), Linear, Nearest...)\r\n     * @param generateDepthBuffer True (default) to generate a depth buffer\r\n     * @param generateStencilBuffer True (default: false) to generate a stencil buffer\r\n     * @param isMulti True (default: false) if multiple textures need to be created (Draw Buffers)\r\n     * @param format The internal format of the buffer in the RTT (RED, RG, RGB, RGBA (default), ALPHA...)\r\n     * @param delayAllocation True (default: false) if the texture allocation should be delayed\r\n     * @param samples Sample count to use when creating the RTT\r\n     * @param creationFlags specific flags to use when creating the texture (e.g., Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures)\r\n     * @param noColorAttachment True (default: false) to indicate that no color target should be created. (e.g., if you only want to write to the depth buffer)\r\n     * @param useSRGBBuffer True (default: false) to create a SRGB texture\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize | { ratio: number },\r\n        scene?: Nullable<Scene>,\r\n        generateMipMaps?: boolean,\r\n        doNotChangeAspectRatio?: boolean,\r\n        type?: number,\r\n        isCube?: boolean,\r\n        samplingMode?: number,\r\n        generateDepthBuffer?: boolean,\r\n        generateStencilBuffer?: boolean,\r\n        isMulti?: boolean,\r\n        format?: number,\r\n        delayAllocation?: boolean,\r\n        samples?: number,\r\n        creationFlags?: number,\r\n        noColorAttachment?: boolean,\r\n        useSRGBBuffer?: boolean\r\n    );\r\n\r\n    /** @internal */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize | { ratio: number },\r\n        scene?: Nullable<Scene>,\r\n        generateMipMaps: boolean | RenderTargetTextureOptions = false,\r\n        doNotChangeAspectRatio: boolean = true,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        isCube = false,\r\n        samplingMode = Texture.TRILINEAR_SAMPLINGMODE,\r\n        generateDepthBuffer = true,\r\n        generateStencilBuffer = false,\r\n        isMulti = false,\r\n        format = Constants.TEXTUREFORMAT_RGBA,\r\n        delayAllocation = false,\r\n        samples?: number,\r\n        creationFlags?: number,\r\n        noColorAttachment = false,\r\n        useSRGBBuffer = false\r\n    ) {\r\n        let colorAttachment: InternalTexture | undefined = undefined;\r\n        let gammaSpace = true;\r\n        let existingObjectRenderer: ObjectRenderer | undefined = undefined;\r\n        let enableClusteredLights = false;\r\n        if (typeof generateMipMaps === \"object\") {\r\n            const options = generateMipMaps;\r\n            generateMipMaps = !!options.generateMipMaps;\r\n            doNotChangeAspectRatio = options.doNotChangeAspectRatio ?? true;\r\n            type = options.type ?? Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            isCube = !!options.isCube;\r\n            samplingMode = options.samplingMode ?? Texture.TRILINEAR_SAMPLINGMODE;\r\n            generateDepthBuffer = options.generateDepthBuffer ?? true;\r\n            generateStencilBuffer = !!options.generateStencilBuffer;\r\n            isMulti = !!options.isMulti;\r\n            format = options.format ?? Constants.TEXTUREFORMAT_RGBA;\r\n            delayAllocation = !!options.delayAllocation;\r\n            samples = options.samples;\r\n            creationFlags = options.creationFlags;\r\n            noColorAttachment = !!options.noColorAttachment;\r\n            useSRGBBuffer = !!options.useSRGBBuffer;\r\n            colorAttachment = options.colorAttachment;\r\n            gammaSpace = options.gammaSpace ?? gammaSpace;\r\n            existingObjectRenderer = options.existingObjectRenderer;\r\n            enableClusteredLights = !!options.enableClusteredLights;\r\n        }\r\n\r\n        super(null, scene, !generateMipMaps, undefined, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this.getScene()!.getEngine();\r\n\r\n        this._gammaSpace = gammaSpace;\r\n        this._coordinatesMode = Texture.PROJECTION_MODE;\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._initialSizeParameter = size;\r\n        this._dontDisposeObjectRenderer = !!existingObjectRenderer;\r\n\r\n        this._processSizeParameter(size);\r\n\r\n        this._objectRenderer =\r\n            existingObjectRenderer ??\r\n            new ObjectRenderer(name, scene, {\r\n                numPasses: isCube ? 6 : this.getRenderLayers() || 1,\r\n                doNotChangeAspectRatio,\r\n                enableClusteredLights,\r\n            });\r\n\r\n        this._onBeforeRenderingManagerRenderObserver = this._objectRenderer.onBeforeRenderingManagerRenderObservable.add(() => {\r\n            // Before clear\r\n            if (!this._disableEngineStages) {\r\n                for (const step of this._scene!._beforeRenderTargetClearStage) {\r\n                    step.action(this, this._currentFaceIndex, this._currentLayer);\r\n                }\r\n            }\r\n\r\n            // Clear\r\n            if (this.onClearObservable.hasObservers()) {\r\n                this.onClearObservable.notifyObservers(engine);\r\n            } else if (!this.skipInitialClear) {\r\n                engine.clear(this.clearColor || this._scene!.clearColor, true, true, true);\r\n            }\r\n\r\n            if (!this._doNotChangeAspectRatio) {\r\n                this._scene!.updateTransformMatrix(true);\r\n            }\r\n\r\n            // Before Camera Draw\r\n            if (!this._disableEngineStages) {\r\n                for (const step of this._scene!._beforeRenderTargetDrawStage) {\r\n                    step.action(this, this._currentFaceIndex, this._currentLayer);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onAfterRenderingManagerRenderObserver = this._objectRenderer.onAfterRenderingManagerRenderObservable.add(() => {\r\n            // After Camera Draw\r\n            if (!this._disableEngineStages) {\r\n                for (const step of this._scene!._afterRenderTargetDrawStage) {\r\n                    step.action(this, this._currentFaceIndex, this._currentLayer);\r\n                }\r\n            }\r\n\r\n            const saveGenerateMipMaps = this._texture?.generateMipMaps ?? false;\r\n\r\n            if (this._texture) {\r\n                this._texture.generateMipMaps = false; // if left true, the mipmaps will be generated (if this._texture.generateMipMaps = true) when the first post process binds its own RTT: by doing so it will unbind the current RTT,\r\n                // which will trigger a mipmap generation. We don't want this because it's a wasted work, we will do an unbind of the current RTT at the end of the process (see unbindFrameBuffer) which will\r\n                // trigger the generation of the final mipmaps\r\n            }\r\n\r\n            if (this._postProcessManager) {\r\n                this._postProcessManager._finalizeFrame(false, this._renderTarget ?? undefined, this._currentFaceIndex, this._postProcesses, this.ignoreCameraViewport);\r\n            } else if (this._currentUseCameraPostProcess) {\r\n                this._scene!.postProcessManager._finalizeFrame(false, this._renderTarget ?? undefined, this._currentFaceIndex);\r\n            }\r\n\r\n            if (!this._disableEngineStages) {\r\n                for (const step of this._scene!._afterRenderTargetPostProcessStage) {\r\n                    step.action(this, this._currentFaceIndex, this._currentLayer);\r\n                }\r\n            }\r\n\r\n            if (this._texture) {\r\n                this._texture.generateMipMaps = saveGenerateMipMaps;\r\n            }\r\n\r\n            if (!this._doNotChangeAspectRatio) {\r\n                this._scene!.updateTransformMatrix(true);\r\n            }\r\n\r\n            // Dump ?\r\n            if (this._currentDumpForDebug) {\r\n                if (!this._dumpTools) {\r\n                    Logger.Error(\"dumpTools module is still being loaded. To speed up the process import dump tools directly in your project\");\r\n                } else {\r\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                    this._dumpTools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onFastPathRenderObserver = this._objectRenderer.onFastPathRenderObservable.add(() => {\r\n            if (this.onClearObservable.hasObservers()) {\r\n                this.onClearObservable.notifyObservers(engine);\r\n            } else {\r\n                if (!this.skipInitialClear) {\r\n                    engine.clear(this.clearColor || this._scene!.clearColor, true, true, true);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._resizeObserver = engine.onResizeObservable.add(() => {});\r\n\r\n        this._generateMipMaps = generateMipMaps ? true : false;\r\n        this._doNotChangeAspectRatio = doNotChangeAspectRatio;\r\n\r\n        if (isMulti) {\r\n            return;\r\n        }\r\n\r\n        this._renderTargetOptions = {\r\n            generateMipMaps: generateMipMaps,\r\n            type: type,\r\n            format: this._format ?? undefined,\r\n            samplingMode: this.samplingMode,\r\n            generateDepthBuffer: generateDepthBuffer,\r\n            generateStencilBuffer: generateStencilBuffer,\r\n            samples,\r\n            creationFlags,\r\n            noColorAttachment: noColorAttachment,\r\n            useSRGBBuffer,\r\n            colorAttachment: colorAttachment,\r\n            label: this.name,\r\n        };\r\n\r\n        if (this.samplingMode === Texture.NEAREST_SAMPLINGMODE) {\r\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        }\r\n\r\n        if (!delayAllocation) {\r\n            if (isCube) {\r\n                this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\r\n                this.coordinatesMode = Texture.INVCUBIC_MODE;\r\n                this._textureMatrix = Matrix.Identity();\r\n            } else {\r\n                this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\r\n            }\r\n            this._texture = this._renderTarget.texture;\r\n            if (samples !== undefined) {\r\n                this.samples = samples;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a depth stencil texture.\r\n     * This is only available in WebGL 2 or with the depth texture extension available.\r\n     * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode (default: 0)\r\n     * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture (default: true)\r\n     * @param generateStencil Specifies whether or not a stencil should be allocated in the texture (default: false)\r\n     * @param samples sample count of the depth/stencil texture (default: 1)\r\n     * @param format format of the depth texture (default: Constants.TEXTUREFORMAT_DEPTH32_FLOAT)\r\n     * @param label defines the label of the texture (for debugging purpose)\r\n     */\r\n    public createDepthStencilTexture(\r\n        comparisonFunction: number = 0,\r\n        bilinearFiltering: boolean = true,\r\n        generateStencil: boolean = false,\r\n        samples: number = 1,\r\n        format: number = Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n        label?: string\r\n    ): void {\r\n        this._renderTarget?.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format, label);\r\n    }\r\n\r\n    protected _processSizeParameter(size: TextureSize | { ratio: number }): void {\r\n        if ((<{ ratio: number }>size).ratio) {\r\n            this._sizeRatio = (<{ ratio: number }>size).ratio;\r\n            const engine = this._getEngine()!;\r\n            this._size = {\r\n                width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),\r\n                height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio),\r\n            };\r\n        } else {\r\n            this._size = <TextureSize>size;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define the number of samples to use in case of MSAA.\r\n     * It defaults to one meaning no MSAA has been enabled.\r\n     */\r\n    public get samples(): number {\r\n        return this._renderTarget?.samples ?? this._samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        if (this._renderTarget) {\r\n            this._samples = this._renderTarget.setSamples(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a post process to the render target rendering passes.\r\n     * @param postProcess define the post process to add\r\n     */\r\n    public addPostProcess(postProcess: PostProcess): void {\r\n        if (!this._postProcessManager) {\r\n            const scene = this.getScene();\r\n\r\n            if (!scene) {\r\n                return;\r\n            }\r\n            this._postProcessManager = new PostProcessManager(scene);\r\n            this._postProcesses = new Array<PostProcess>();\r\n        }\r\n\r\n        this._postProcesses.push(postProcess);\r\n        this._postProcesses[0].autoClear = false;\r\n    }\r\n\r\n    /**\r\n     * Clear all the post processes attached to the render target\r\n     * @param dispose define if the cleared post processes should also be disposed (false by default)\r\n     */\r\n    public clearPostProcesses(dispose: boolean = false): void {\r\n        if (!this._postProcesses) {\r\n            return;\r\n        }\r\n\r\n        if (dispose) {\r\n            for (const postProcess of this._postProcesses) {\r\n                postProcess.dispose();\r\n            }\r\n        }\r\n\r\n        this._postProcesses = [];\r\n    }\r\n\r\n    /**\r\n     * Remove one of the post process from the list of attached post processes to the texture\r\n     * @param postProcess define the post process to remove from the list\r\n     */\r\n    public removePostProcess(postProcess: PostProcess): void {\r\n        if (!this._postProcesses) {\r\n            return;\r\n        }\r\n\r\n        const index = this._postProcesses.indexOf(postProcess);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._postProcesses.splice(index, 1);\r\n\r\n        if (this._postProcesses.length > 0) {\r\n            this._postProcesses[0].autoClear = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._objectRenderer.resetRefreshCounter();\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    public get refreshRate(): number {\r\n        return this._objectRenderer.refreshRate;\r\n    }\r\n    public set refreshRate(value: number) {\r\n        this._objectRenderer.refreshRate = value;\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRender(): boolean {\r\n        return this._objectRenderer.shouldRender();\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render size of the texture.\r\n     * @returns the width of the render size\r\n     */\r\n    public getRenderSize(): number {\r\n        return this.getRenderWidth();\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render width of the texture.\r\n     * @returns the width of the render size\r\n     */\r\n    public getRenderWidth(): number {\r\n        if ((<{ width: number; height: number }>this._size).width) {\r\n            return (<{ width: number; height: number }>this._size).width;\r\n        }\r\n\r\n        return <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render height of the texture.\r\n     * @returns the height of the render size\r\n     */\r\n    public getRenderHeight(): number {\r\n        if ((<{ width: number; height: number }>this._size).width) {\r\n            return (<{ width: number; height: number }>this._size).height;\r\n        }\r\n\r\n        return <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual number of layers of the texture or, in the case of a 3D texture, return the depth.\r\n     * @returns the number of layers\r\n     */\r\n    public getRenderLayers(): number {\r\n        const layers = (<{ width: number; height: number; depth?: number; layers?: number }>this._size).layers;\r\n        if (layers) {\r\n            return layers;\r\n        }\r\n        const depth = (<{ width: number; height: number; depth?: number; layers?: number }>this._size).depth;\r\n        if (depth) {\r\n            return depth;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Don't allow this render target texture to rescale. Mainly used to prevent rescaling by the scene optimizer.\r\n     */\r\n    public disableRescaling() {\r\n        this._canRescale = false;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture can be rescaled or not.\r\n     */\r\n    public override get canRescale(): boolean {\r\n        return this._canRescale;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture using a ratio.\r\n     * @param ratio the ratio to apply to the texture size in order to compute the new target size\r\n     */\r\n    public override scale(ratio: number): void {\r\n        const newSize = Math.max(1, this.getRenderSize() * ratio);\r\n\r\n        this.resize(newSize);\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public override getReflectionTextureMatrix(): Matrix {\r\n        if (this.isCube) {\r\n            return this._textureMatrix;\r\n        }\r\n\r\n        return super.getReflectionTextureMatrix();\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to a new desired size.\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param size Define the new size. It can be:\r\n     *   - a number for squared texture,\r\n     *   - an object containing { width: number, height: number }\r\n     *   - or an object containing a ratio { ratio: number }\r\n     */\r\n    public resize(size: TextureSize | { ratio: number }): void {\r\n        const wasCube = this.isCube;\r\n\r\n        this._renderTarget?.dispose();\r\n        this._renderTarget = null;\r\n\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._processSizeParameter(size);\r\n\r\n        if (wasCube) {\r\n            this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\r\n        } else {\r\n            this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\r\n        }\r\n        this._texture = this._renderTarget.texture;\r\n\r\n        if (this._renderTargetOptions.samples !== undefined) {\r\n            this.samples = this._renderTargetOptions.samples;\r\n        }\r\n\r\n        if (this.onResizeObservable.hasObservers()) {\r\n            this.onResizeObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders all the objects from the render list into the texture.\r\n     * @param useCameraPostProcess Define if camera post processes should be used during the rendering\r\n     * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose\r\n     */\r\n    public render(useCameraPostProcess: boolean = false, dumpForDebug: boolean = false): void {\r\n        this._render(useCameraPostProcess, dumpForDebug);\r\n    }\r\n\r\n    private _dumpToolsLoading = false;\r\n    private _dumpTools: typeof import(\"../../Misc/dumpTools\");\r\n\r\n    /**\r\n     * This function will check if the render target texture can be rendered (textures are loaded, shaders are compiled)\r\n     * @returns true if all required resources are ready\r\n     */\r\n    public isReadyForRendering(): boolean {\r\n        if (!this._dumpToolsLoading) {\r\n            this._dumpToolsLoading = true;\r\n            // avoid a static import to allow ignoring the import in some cases\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            import(\"../../Misc/dumpTools\").then((module) => (this._dumpTools = module));\r\n        }\r\n\r\n        this._objectRenderer.prepareRenderList();\r\n\r\n        this.onBeforeBindObservable.notifyObservers(this);\r\n\r\n        this._objectRenderer.initRender(this.getRenderWidth(), this.getRenderHeight());\r\n\r\n        const isReady = this._objectRenderer._checkReadiness();\r\n\r\n        this.onAfterUnbindObservable.notifyObservers(this);\r\n\r\n        this._objectRenderer.finishRender();\r\n\r\n        return isReady;\r\n    }\r\n\r\n    private _render(useCameraPostProcess: boolean = false, dumpForDebug: boolean = false): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        if (this.useCameraPostProcesses !== undefined) {\r\n            useCameraPostProcess = this.useCameraPostProcesses;\r\n        }\r\n\r\n        this._objectRenderer.prepareRenderList();\r\n\r\n        this.onBeforeBindObservable.notifyObservers(this);\r\n\r\n        this._objectRenderer.initRender(this.getRenderWidth(), this.getRenderHeight());\r\n\r\n        if ((this.is2DArray || this.is3D) && !this.isMulti) {\r\n            for (let layer = 0; layer < this.getRenderLayers(); layer++) {\r\n                this._renderToTarget(0, useCameraPostProcess, dumpForDebug, layer);\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n            }\r\n        } else if (this.isCube && !this.isMulti) {\r\n            for (let face = 0; face < 6; face++) {\r\n                this._renderToTarget(face, useCameraPostProcess, dumpForDebug);\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n            }\r\n        } else {\r\n            this._renderToTarget(0, useCameraPostProcess, dumpForDebug);\r\n        }\r\n\r\n        this.onAfterUnbindObservable.notifyObservers(this);\r\n\r\n        this._objectRenderer.finishRender();\r\n    }\r\n\r\n    private _bestReflectionRenderTargetDimension(renderDimension: number, scale: number): number {\r\n        const minimum = 128;\r\n        const x = renderDimension * scale;\r\n        const curved = NearestPOT(x + (minimum * minimum) / (minimum + x));\r\n\r\n        // Ensure we don't exceed the render dimension (while staying POT)\r\n        return Math.min(FloorPOT(renderDimension), curved);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param faceIndex face index to bind to if this is a cubetexture\r\n     * @param layer defines the index of the texture to bind in the array\r\n     */\r\n    public _bindFrameBuffer(faceIndex: number = 0, layer = 0) {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n        if (this._renderTarget) {\r\n            engine.bindFramebuffer(this._renderTarget, this.isCube ? faceIndex : undefined, undefined, undefined, this.ignoreCameraViewport, 0, layer);\r\n        }\r\n    }\r\n\r\n    protected _unbindFrameBuffer(engine: AbstractEngine, faceIndex: number): void {\r\n        if (!this._renderTarget) {\r\n            return;\r\n        }\r\n        engine.unBindFramebuffer(this._renderTarget, this.isCube, () => {\r\n            this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _prepareFrame(scene: Scene, faceIndex?: number, layer?: number, useCameraPostProcess?: boolean) {\r\n        if (this._postProcessManager) {\r\n            if (!this._prePassEnabled) {\r\n                if (!this._postProcessManager._prepareFrame(this._texture, this._postProcesses)) {\r\n                    this._bindFrameBuffer(faceIndex, layer);\r\n                }\r\n            }\r\n        } else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {\r\n            this._bindFrameBuffer(faceIndex, layer);\r\n        }\r\n    }\r\n\r\n    private _renderToTarget(faceIndex: number, useCameraPostProcess: boolean, dumpForDebug: boolean, layer = 0): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._currentFaceIndex = faceIndex;\r\n        this._currentLayer = layer;\r\n        this._currentUseCameraPostProcess = useCameraPostProcess;\r\n        this._currentDumpForDebug = dumpForDebug;\r\n\r\n        this._prepareFrame(scene, faceIndex, layer, useCameraPostProcess);\r\n\r\n        engine._debugPushGroup?.(`render to face #${faceIndex} layer #${layer}`, 2);\r\n\r\n        this._objectRenderer.render(faceIndex + layer, true); // only faceIndex or layer (if any) will be different from 0 (we don't support array of cubes), so it's safe to add them to get the pass index\r\n\r\n        engine._debugPopGroup?.(2);\r\n\r\n        this._unbindFrameBuffer(engine, faceIndex);\r\n\r\n        if (this._texture && this.isCube && faceIndex === 5) {\r\n            engine.generateMipMapsForCubemap(this._texture, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversely depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(\r\n        renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ): void {\r\n        this._objectRenderer.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void {\r\n        this._objectRenderer.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): RenderTargetTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new RenderTargetTexture(\r\n            this.name,\r\n            textureSize,\r\n            this.getScene(),\r\n            this._renderTargetOptions.generateMipMaps,\r\n            this._doNotChangeAspectRatio,\r\n            this._renderTargetOptions.type,\r\n            this.isCube,\r\n            this._renderTargetOptions.samplingMode,\r\n            this._renderTargetOptions.generateDepthBuffer,\r\n            this._renderTargetOptions.generateStencilBuffer,\r\n            undefined,\r\n            this._renderTargetOptions.format,\r\n            undefined,\r\n            this._renderTargetOptions.samples\r\n        );\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n        if (this.renderList) {\r\n            newTexture.renderList = this.renderList.slice(0);\r\n        }\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the respective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public override serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.renderTargetSize = this.getRenderSize();\r\n        serializationObject.renderList = [];\r\n\r\n        if (this.renderList) {\r\n            for (let index = 0; index < this.renderList.length; index++) {\r\n                serializationObject.renderList.push(this.renderList[index].id);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore\r\n     */\r\n    public disposeFramebufferObjects(): void {\r\n        this._renderTarget?.dispose(true);\r\n    }\r\n\r\n    /**\r\n     * Release and destroy the underlying lower level texture aka internalTexture.\r\n     */\r\n    public override releaseInternalTexture(): void {\r\n        this._renderTarget?.releaseTextures();\r\n        this._texture = null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        this.onResizeObservable.clear();\r\n        this.onClearObservable.clear();\r\n        this.onAfterUnbindObservable.clear();\r\n        this.onBeforeBindObservable.clear();\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager.dispose();\r\n            this._postProcessManager = null;\r\n        }\r\n\r\n        if (this._prePassRenderTarget) {\r\n            this._prePassRenderTarget.dispose();\r\n        }\r\n\r\n        this._objectRenderer.onBeforeRenderingManagerRenderObservable.remove(this._onBeforeRenderingManagerRenderObserver);\r\n        this._objectRenderer.onAfterRenderingManagerRenderObservable.remove(this._onAfterRenderingManagerRenderObserver);\r\n        this._objectRenderer.onFastPathRenderObservable.remove(this._onFastPathRenderObserver);\r\n\r\n        if (!this._dontDisposeObjectRenderer) {\r\n            this._objectRenderer.dispose();\r\n        }\r\n\r\n        this.clearPostProcesses(true);\r\n\r\n        if (this._resizeObserver) {\r\n            this.getScene()!.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n            this._resizeObserver = null;\r\n        }\r\n\r\n        // Remove from custom render targets\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        let index = scene.customRenderTargets.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.customRenderTargets.splice(index, 1);\r\n        }\r\n\r\n        for (const camera of scene.cameras) {\r\n            index = camera.customRenderTargets.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                camera.customRenderTargets.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._renderTarget?.dispose();\r\n        this._renderTarget = null;\r\n        this._texture = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /** @internal */\r\n    public override _rebuild(): void {\r\n        this._objectRenderer._rebuild();\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention point in material dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        this._objectRenderer.freeRenderingGroups();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\r\n     * @returns the view count\r\n     */\r\n    public getViewCount() {\r\n        return 1;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nTexture._CreateRenderTargetTexture = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean, creationFlags?: number) => {\r\n    return new RenderTargetTexture(name, renderTargetSize, scene, generateMipMaps);\r\n};\r\n", "import type { Nullable } from \"../types\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { RenderTargetCreationOptions } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport type { Color4 } from \"../Maths/math.color\";\r\n\r\nimport type { NodeMaterial } from \"../Materials/Node/nodeMaterial\";\r\nimport { serialize, serializeAsColor4 } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { GetClass, RegisterClass } from \"../Misc/typeStore\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport type { PrePassEffectConfiguration } from \"../Rendering/prePassEffectConfiguration\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { GetExponentOfTwo } from \"../Misc/tools.functions\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport type { EffectWrapperCustomShaderCodeProcessing, EffectWrapperCreationOptions } from \"../Materials/effectRenderer\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\n\r\ndeclare module \"../Engines/abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Sets a texture to the context from a postprocess\r\n         * @param channel defines the channel to use\r\n         * @param postProcess defines the source postprocess\r\n         * @param name name of the channel\r\n         */\r\n        setTextureFromPostProcess(channel: number, postProcess: Nullable<PostProcess>, name: string): void;\r\n\r\n        /**\r\n         * Binds the output of the passed in post process to the texture channel specified\r\n         * @param channel The channel the texture should be bound to\r\n         * @param postProcess The post process which's output should be bound\r\n         * @param name name of the channel\r\n         */\r\n        setTextureFromPostProcessOutput(channel: number, postProcess: Nullable<PostProcess>, name: string): void;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype.setTextureFromPostProcess = function (channel: number, postProcess: Nullable<PostProcess>, name: string): void {\r\n    let postProcessInput = null;\r\n    if (postProcess) {\r\n        if (postProcess._forcedOutputTexture) {\r\n            postProcessInput = postProcess._forcedOutputTexture;\r\n        } else if (postProcess._textures.data[postProcess._currentRenderTextureInd]) {\r\n            postProcessInput = postProcess._textures.data[postProcess._currentRenderTextureInd];\r\n        }\r\n    }\r\n\r\n    this._bindTexture(channel, postProcessInput?.texture ?? null, name);\r\n};\r\n\r\nAbstractEngine.prototype.setTextureFromPostProcessOutput = function (channel: number, postProcess: Nullable<PostProcess>, name: string): void {\r\n    this._bindTexture(channel, postProcess?._outputTexture?.texture ?? null, name);\r\n};\r\n\r\ndeclare module \"../Materials/effect\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Effect {\r\n        /**\r\n         * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\r\n         * @param channel Name of the sampler variable.\r\n         * @param postProcess Post process to get the input texture from.\r\n         */\r\n        setTextureFromPostProcess(channel: string, postProcess: Nullable<PostProcess>): void;\r\n\r\n        /**\r\n         * (Warning! setTextureFromPostProcessOutput may be desired instead)\r\n         * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\r\n         * @param channel Name of the sampler variable.\r\n         * @param postProcess Post process to get the output texture from.\r\n         */\r\n        setTextureFromPostProcessOutput(channel: string, postProcess: Nullable<PostProcess>): void;\r\n    }\r\n}\r\n\r\n/**\r\n * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\r\n * @param channel Name of the sampler variable.\r\n * @param postProcess Post process to get the input texture from.\r\n */\r\nEffect.prototype.setTextureFromPostProcess = function (channel: string, postProcess: Nullable<PostProcess>): void {\r\n    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);\r\n};\r\n\r\n/**\r\n * (Warning! setTextureFromPostProcessOutput may be desired instead)\r\n * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\r\n * @param channel Name of the sampler variable.\r\n * @param postProcess Post process to get the output texture from.\r\n */\r\nEffect.prototype.setTextureFromPostProcessOutput = function (channel: string, postProcess: Nullable<PostProcess>): void {\r\n    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);\r\n};\r\n\r\n/**\r\n * Options for the PostProcess constructor\r\n */\r\nexport type PostProcessOptions = EffectWrapperCreationOptions & {\r\n    /**\r\n     * The width of the texture created for this post process.\r\n     * This parameter (and height) is only used when passing a value for the 5th parameter (options) to the PostProcess constructor function.\r\n     * If you use a PostProcessOptions for the 3rd parameter of the constructor, size is used instead of width and height.\r\n     */\r\n    width?: number;\r\n    /**\r\n     * The height of the texture created for this post process.\r\n     * This parameter (and width) is only used when passing a value for the 5th parameter (options) to the PostProcess constructor function.\r\n     * If you use a PostProcessOptions for the 3rd parameter of the constructor, size is used instead of width and height.\r\n     */\r\n    height?: number;\r\n\r\n    /**\r\n     * The size of the post process texture.\r\n     * It is either a ratio to downscale or upscale the texture create for this post process, or an object containing width and height values.\r\n     * Default: 1\r\n     */\r\n    size?: number | { width: number; height: number };\r\n    /**\r\n     * The camera that the post process will be attached to (default: null)\r\n     */\r\n    camera?: Nullable<Camera>;\r\n    /**\r\n     * The sampling mode to be used by the shader (default: Constants.TEXTURE_NEAREST_SAMPLINGMODE)\r\n     */\r\n    samplingMode?: number;\r\n    /**\r\n     * The engine to be used to render the post process (default: engine from scene)\r\n     */\r\n    engine?: AbstractEngine;\r\n    /**\r\n     * If the post process can be reused on the same frame. (default: false)\r\n     */\r\n    reusable?: boolean;\r\n    /**\r\n     * Type of the texture created for this post process (default: Constants.TEXTURETYPE_UNSIGNED_BYTE)\r\n     */\r\n    textureType?: number;\r\n    /**\r\n     * Format of the texture created for this post process (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    textureFormat?: number;\r\n    /**\r\n     * The effect wrapper instance used by the post process. If not provided, a new one will be created.\r\n     */\r\n    effectWrapper?: EffectWrapper;\r\n};\r\n\r\ntype TextureCache = { texture: RenderTargetWrapper; postProcessChannel: number; lastUsedRenderId: number };\r\n\r\n/**\r\n * PostProcess can be used to apply a shader to a texture after it has been rendered\r\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses\r\n */\r\nexport class PostProcess {\r\n    /**\r\n     * Force all the postprocesses to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static get ForceGLSL(): boolean {\r\n        return EffectWrapper.ForceGLSL;\r\n    }\r\n\r\n    public static set ForceGLSL(force: boolean) {\r\n        EffectWrapper.ForceGLSL = force;\r\n    }\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /**\r\n     * Registers a shader code processing with a post process name.\r\n     * @param postProcessName name of the post process. Use null for the fallback shader code processing. This is the shader code processing that will be used in case no specific shader code processing has been associated to a post process name\r\n     * @param customShaderCodeProcessing shader code processing to associate to the post process name\r\n     */\r\n    public static RegisterShaderCodeProcessing(postProcessName: Nullable<string>, customShaderCodeProcessing?: EffectWrapperCustomShaderCodeProcessing) {\r\n        EffectWrapper.RegisterShaderCodeProcessing(postProcessName, customShaderCodeProcessing);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the post process\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /** Name of the PostProcess. */\r\n    @serialize()\r\n    public get name() {\r\n        return this._effectWrapper.name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._effectWrapper.name = value;\r\n    }\r\n\r\n    /**\r\n     * Width of the texture to apply the post process on\r\n     */\r\n    @serialize()\r\n    public width = -1;\r\n\r\n    /**\r\n     * Height of the texture to apply the post process on\r\n     */\r\n    @serialize()\r\n    public height = -1;\r\n\r\n    /**\r\n     * Gets the node material used to create this postprocess (null if the postprocess was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /**\r\n     * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)\r\n     * @internal\r\n     */\r\n    public _outputTexture: Nullable<RenderTargetWrapper> = null;\r\n    /**\r\n     * Sampling mode used by the shader\r\n     */\r\n    @serialize()\r\n    public renderTargetSamplingMode: number;\r\n    /**\r\n     * Clear color to use when screen clearing\r\n     */\r\n    @serializeAsColor4()\r\n    public clearColor: Color4;\r\n    /**\r\n     * If the buffer needs to be cleared before applying the post process. (default: true)\r\n     * Should be set to false if shader will overwrite all previous pixels.\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n    /**\r\n     * If clearing the buffer should be forced in autoClear mode, even when alpha mode is enabled (default: false).\r\n     * By default, the buffer will only be cleared if alpha mode is disabled (and autoClear is true).\r\n     */\r\n    @serialize()\r\n    public forceAutoClearInAlphaMode = false;\r\n\r\n    /**\r\n     * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)\r\n     */\r\n    @serialize()\r\n    public get alphaMode() {\r\n        return this._effectWrapper.alphaMode;\r\n    }\r\n\r\n    public set alphaMode(value: number) {\r\n        this._effectWrapper.alphaMode = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the setAlphaBlendConstants of the babylon engine\r\n     */\r\n    @serialize()\r\n    public alphaConstants: Color4;\r\n\r\n    /**\r\n     * Animations to be used for the post processing\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * Enable Pixel Perfect mode where texture is not scaled to be power of 2.\r\n     * Can only be used on a single postprocess or on the last one of a chain. (default: false)\r\n     */\r\n    @serialize()\r\n    public enablePixelPerfectMode = false;\r\n\r\n    /**\r\n     * Force the postprocess to be applied without taking in account viewport\r\n     */\r\n    @serialize()\r\n    public forceFullscreenViewport = true;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |\r\n     * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |\r\n     * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |\r\n     *\r\n     */\r\n    @serialize()\r\n    public scaleMode = Constants.SCALEMODE_FLOOR;\r\n    /**\r\n     * Force textures to be a power of two (default: false)\r\n     */\r\n    @serialize()\r\n    public alwaysForcePOT = false;\r\n\r\n    @serialize(\"samples\")\r\n    private _samples = 1;\r\n\r\n    /**\r\n     * Number of sample textures (default: 1)\r\n     */\r\n    public get samples() {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(n: number) {\r\n        this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);\r\n\r\n        this._textures.forEach((texture) => {\r\n            texture.setSamples(this._samples);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Modify the scale of the post process to be the same as the viewport (default: false)\r\n     */\r\n    @serialize()\r\n    public adaptScaleToCurrentViewport = false;\r\n\r\n    private _camera: Camera;\r\n    protected _scene: Scene;\r\n    private _engine: AbstractEngine;\r\n\r\n    protected _webGPUReady = false;\r\n\r\n    private _options: number | { width: number; height: number };\r\n    private _reusable = false;\r\n    private _renderId = 0;\r\n    private _textureType: number;\r\n    private _textureFormat: number;\r\n    /** @internal */\r\n    private _shaderLanguage: ShaderLanguage;\r\n\r\n    /**\r\n     * Gets the shader language type used to generate vertex and fragment source code.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * if externalTextureSamplerBinding is true, the \"apply\" method won't bind the textureSampler texture, it is expected to be done by the \"outside\" (by the onApplyObservable observer most probably).\r\n     * counter-productive in some cases because if the texture bound by \"apply\" is different from the currently texture bound, (the one set by the onApplyObservable observer, for eg) some\r\n     * internal structures (materialContext) will be dirtified, which may impact performances\r\n     */\r\n    public externalTextureSamplerBinding = false;\r\n\r\n    /**\r\n     * Smart array of input and output textures for the post process.\r\n     * @internal\r\n     */\r\n    public _textures = new SmartArray<RenderTargetWrapper>(2);\r\n    /**\r\n     * Smart array of input and output textures for the post process.\r\n     * @internal\r\n     */\r\n    private _textureCache: TextureCache[] = [];\r\n    /**\r\n     * The index in _textures that corresponds to the output texture.\r\n     * @internal\r\n     */\r\n    public _currentRenderTextureInd = 0;\r\n    private _samplers: string[];\r\n    private _fragmentUrl: string;\r\n    private _vertexUrl: string;\r\n    private _parameters: string[];\r\n    private _uniformBuffers: string[];\r\n    protected _postProcessDefines: Nullable<string>;\r\n    private _scaleRatio = new Vector2(1, 1);\r\n    protected _indexParameters: any;\r\n    private _shareOutputWithPostProcess: Nullable<PostProcess>;\r\n    private _texelSize = Vector2.Zero();\r\n\r\n    /** @internal */\r\n    public _forcedOutputTexture: Nullable<RenderTargetWrapper>;\r\n\r\n    /**\r\n     * Prepass configuration in case this post process needs a texture from prepass\r\n     * @internal\r\n     */\r\n    public _prePassEffectConfiguration: PrePassEffectConfiguration;\r\n\r\n    /**\r\n     * Returns the fragment url or shader name used in the post process.\r\n     * @returns the fragment url or name in the shader store.\r\n     */\r\n    public getEffectName(): string {\r\n        return this._fragmentUrl;\r\n    }\r\n\r\n    /**\r\n     * Executed when the effect was created\r\n     * @returns effect that was created for this post process\r\n     */\r\n    public onEffectCreatedObservable;\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An event triggered when the postprocess is activated.\r\n     */\r\n    public onActivateObservable = new Observable<Camera>();\r\n\r\n    private _onActivateObserver: Nullable<Observer<Camera>>;\r\n    /**\r\n     * A function that is added to the onActivateObservable\r\n     */\r\n    public set onActivate(callback: Nullable<(camera: Camera) => void>) {\r\n        if (this._onActivateObserver) {\r\n            this.onActivateObservable.remove(this._onActivateObserver);\r\n        }\r\n        if (callback) {\r\n            this._onActivateObserver = this.onActivateObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the postprocess changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<PostProcess>();\r\n\r\n    private _onSizeChangedObserver: Nullable<Observer<PostProcess>>;\r\n    /**\r\n     * A function that is added to the onSizeChangedObservable\r\n     */\r\n    public set onSizeChanged(callback: (postProcess: PostProcess) => void) {\r\n        if (this._onSizeChangedObserver) {\r\n            this.onSizeChangedObservable.remove(this._onSizeChangedObserver);\r\n        }\r\n        this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the postprocess applies its effect.\r\n     */\r\n    public onApplyObservable = new Observable<Effect>();\r\n\r\n    private _onApplyObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n     * A function that is added to the onApplyObservable\r\n     */\r\n    public set onApply(callback: (effect: Effect) => void) {\r\n        if (this._onApplyObserver) {\r\n            this.onApplyObservable.remove(this._onApplyObserver);\r\n        }\r\n        this._onApplyObserver = this.onApplyObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the postprocess\r\n     */\r\n    public onBeforeRenderObservable = new Observable<Effect>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n     * A function that is added to the onBeforeRenderObservable\r\n     */\r\n    public set onBeforeRender(callback: (effect: Effect) => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the postprocess\r\n     */\r\n    public onAfterRenderObservable = new Observable<Effect>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n     * A function that is added to the onAfterRenderObservable\r\n     */\r\n    public set onAfterRender(callback: (efect: Effect) => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the post-process is disposed\r\n     */\r\n    public readonly onDisposeObservable = new Observable<void>();\r\n\r\n    /**\r\n     * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will\r\n     * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.\r\n     */\r\n    public get inputTexture(): RenderTargetWrapper {\r\n        return this._textures.data[this._currentRenderTextureInd];\r\n    }\r\n\r\n    public set inputTexture(value: RenderTargetWrapper) {\r\n        this._forcedOutputTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Since inputTexture should always be defined, if we previously manually set `inputTexture`,\r\n     * the only way to unset it is to use this function to restore its internal state\r\n     */\r\n    public restoreDefaultInputTexture() {\r\n        if (this._forcedOutputTexture) {\r\n            this._forcedOutputTexture = null;\r\n            this.markTextureDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the camera which post process is applied to.\r\n     * @returns The camera the post process is applied to.\r\n     */\r\n    public getCamera(): Camera {\r\n        return this._camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the texel size of the postprocess.\r\n     * See https://en.wikipedia.org/wiki/Texel_(graphics)\r\n     */\r\n    public get texelSize(): Vector2 {\r\n        if (this._shareOutputWithPostProcess) {\r\n            return this._shareOutputWithPostProcess.texelSize;\r\n        }\r\n\r\n        if (this._forcedOutputTexture) {\r\n            this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture.width, 1.0 / this._forcedOutputTexture.height);\r\n        }\r\n\r\n        return this._texelSize;\r\n    }\r\n\r\n    protected readonly _effectWrapper: EffectWrapper;\r\n    protected readonly _useExistingThinPostProcess: boolean;\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param name The name of the PostProcess.\r\n     * @param fragmentUrl The url of the fragment shader to be used.\r\n     * @param options The options to be used when constructing the post process.\r\n     */\r\n    constructor(name: string, fragmentUrl: string, options?: PostProcessOptions);\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param name The name of the PostProcess.\r\n     * @param fragmentUrl The url of the fragment shader to be used.\r\n     * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.\r\n     * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param defines String of defines that will be set when running the fragment shader. (default: null)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param vertexUrl The url of the vertex shader to be used. (default: \"postprocess\")\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param blockCompilation If the shader should not be compiled immediatly. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     * @param shaderLanguage The shader language of the shader. (default: GLSL)\r\n     * @param extraInitializations Defines additional code to call to prepare the shader code\r\n     */\r\n    constructor(\r\n        name: string,\r\n        fragmentUrl: string,\r\n        parameters: Nullable<string[]>,\r\n        samplers: Nullable<string[]>,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        defines?: Nullable<string>,\r\n        textureType?: number,\r\n        vertexUrl?: string,\r\n        indexParameters?: any,\r\n        blockCompilation?: boolean,\r\n        textureFormat?: number,\r\n        shaderLanguage?: ShaderLanguage,\r\n        extraInitializations?: (useWebGPU: boolean, list: Promise<any>[]) => void\r\n    );\r\n\r\n    /** @internal */\r\n    constructor(\r\n        name: string,\r\n        fragmentUrl: string,\r\n        parameters?: Nullable<string[]> | PostProcessOptions,\r\n        samplers?: Nullable<string[]>,\r\n        _size?: number | PostProcessOptions,\r\n        camera?: Nullable<Camera>,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        defines: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        vertexUrl: string = \"postprocess\",\r\n        indexParameters?: any,\r\n        blockCompilation = false,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA,\r\n        shaderLanguage?: ShaderLanguage,\r\n        extraInitializations?: (useWebGPU: boolean, list: Promise<any>[]) => void\r\n    ) {\r\n        let size: number | { width: number; height: number } = 1;\r\n        let uniformBuffers: Nullable<string[]> = null;\r\n        let effectWrapper: EffectWrapper | undefined;\r\n        if (parameters && !Array.isArray(parameters)) {\r\n            const options = parameters;\r\n            parameters = options.uniforms ?? null;\r\n            samplers = options.samplers ?? null;\r\n            size = options.size ?? 1;\r\n            camera = options.camera ?? null;\r\n            samplingMode = options.samplingMode ?? Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n            engine = options.engine;\r\n            reusable = options.reusable;\r\n            defines = Array.isArray(options.defines) ? options.defines.join(\"\\n\") : (options.defines ?? null);\r\n            textureType = options.textureType ?? Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            vertexUrl = options.vertexUrl ?? \"postprocess\";\r\n            indexParameters = options.indexParameters;\r\n            blockCompilation = options.blockCompilation ?? false;\r\n            textureFormat = options.textureFormat ?? Constants.TEXTUREFORMAT_RGBA;\r\n            shaderLanguage = options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n            uniformBuffers = options.uniformBuffers ?? null;\r\n            extraInitializations = options.extraInitializations;\r\n            effectWrapper = options.effectWrapper;\r\n        } else if (_size) {\r\n            if (typeof _size === \"number\") {\r\n                size = _size;\r\n            } else {\r\n                size = { width: _size.width!, height: _size.height! };\r\n            }\r\n        }\r\n\r\n        this._useExistingThinPostProcess = !!effectWrapper;\r\n\r\n        this._effectWrapper =\r\n            effectWrapper ??\r\n            new EffectWrapper({\r\n                name,\r\n                useShaderStore: true,\r\n                useAsPostProcess: true,\r\n                fragmentShader: fragmentUrl,\r\n                engine: engine || camera?.getScene().getEngine(),\r\n                uniforms: parameters,\r\n                samplers,\r\n                uniformBuffers,\r\n                defines,\r\n                vertexUrl,\r\n                indexParameters,\r\n                blockCompilation: true,\r\n                shaderLanguage,\r\n                extraInitializations: undefined,\r\n            });\r\n\r\n        this.name = name;\r\n        this.onEffectCreatedObservable = this._effectWrapper.onEffectCreatedObservable;\r\n\r\n        if (camera != null) {\r\n            this._camera = camera;\r\n            this._scene = camera.getScene();\r\n            camera.attachPostProcess(this);\r\n            this._engine = this._scene.getEngine();\r\n\r\n            this._scene.addPostProcess(this);\r\n            this.uniqueId = this._scene.getUniqueId();\r\n        } else if (engine) {\r\n            this._engine = engine;\r\n            this._engine.postProcesses.push(this);\r\n        }\r\n\r\n        this._options = size;\r\n        this.renderTargetSamplingMode = samplingMode ? samplingMode : Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        this._reusable = reusable || false;\r\n        this._textureType = textureType;\r\n        this._textureFormat = textureFormat;\r\n        this._shaderLanguage = shaderLanguage || ShaderLanguage.GLSL;\r\n\r\n        this._samplers = samplers || [];\r\n        if (this._samplers.indexOf(\"textureSampler\") === -1) {\r\n            this._samplers.push(\"textureSampler\");\r\n        }\r\n\r\n        this._fragmentUrl = fragmentUrl;\r\n        this._vertexUrl = vertexUrl;\r\n        this._parameters = parameters || [];\r\n\r\n        if (this._parameters.indexOf(\"scale\") === -1) {\r\n            this._parameters.push(\"scale\");\r\n        }\r\n        this._uniformBuffers = uniformBuffers || [];\r\n\r\n        this._indexParameters = indexParameters;\r\n\r\n        if (!this._useExistingThinPostProcess) {\r\n            this._webGPUReady = this._shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n            const importPromises: Array<Promise<any>> = [];\r\n\r\n            this._gatherImports(this._engine.isWebGPU && !PostProcess.ForceGLSL, importPromises);\r\n\r\n            this._effectWrapper._webGPUReady = this._webGPUReady;\r\n            this._effectWrapper._postConstructor(blockCompilation, defines, extraInitializations, importPromises);\r\n        }\r\n    }\r\n\r\n    protected _gatherImports(useWebGPU = false, list: Promise<any>[]) {\r\n        // this._webGPUReady is used to detect when a postprocess is intended to be used with WebGPU\r\n        if (useWebGPU && this._webGPUReady) {\r\n            list.push(Promise.all([import(\"../ShadersWGSL/postprocess.vertex\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/postprocess.vertex\")]));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"PostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Gets the engine which this post process belongs to.\r\n     * @returns The engine the post process was enabled with.\r\n     */\r\n    public getEngine(): AbstractEngine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding to the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._effectWrapper.drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.\r\n     * @param postProcess The post process to share the output with.\r\n     * @returns This post process.\r\n     */\r\n    public shareOutputWith(postProcess: PostProcess): PostProcess {\r\n        this._disposeTextures();\r\n\r\n        this._shareOutputWithPostProcess = postProcess;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.\r\n     * This should be called if the post process that shares output with this post process is disabled/disposed.\r\n     */\r\n    public useOwnOutput() {\r\n        if (this._textures.length == 0) {\r\n            this._textures = new SmartArray<RenderTargetWrapper>(2);\r\n        }\r\n\r\n        this._shareOutputWithPostProcess = null;\r\n    }\r\n\r\n    /**\r\n     * Updates the effect with the current post process compile time values and recompiles the shader.\r\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param onCompiled Called when the shader has been compiled.\r\n     * @param onError Called if there is an error when compiling a shader.\r\n     * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)\r\n     * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)\r\n     */\r\n    public updateEffect(\r\n        defines: Nullable<string> = null,\r\n        uniforms: Nullable<string[]> = null,\r\n        samplers: Nullable<string[]> = null,\r\n        indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void,\r\n        vertexUrl?: string,\r\n        fragmentUrl?: string\r\n    ) {\r\n        this._effectWrapper.updateEffect(defines, uniforms, samplers, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl);\r\n        this._postProcessDefines = Array.isArray(this._effectWrapper.options.defines) ? this._effectWrapper.options.defines.join(\"\\n\") : this._effectWrapper.options.defines;\r\n    }\r\n\r\n    /**\r\n     * The post process is reusable if it can be used multiple times within one frame.\r\n     * @returns If the post process is reusable\r\n     */\r\n    public isReusable(): boolean {\r\n        return this._reusable;\r\n    }\r\n\r\n    /** invalidate frameBuffer to hint the postprocess to create a depth buffer */\r\n    public markTextureDirty(): void {\r\n        this.width = -1;\r\n    }\r\n\r\n    private _createRenderTargetTexture(textureSize: { width: number; height: number }, textureOptions: RenderTargetCreationOptions, channel = 0) {\r\n        for (let i = 0; i < this._textureCache.length; i++) {\r\n            if (\r\n                this._textureCache[i].texture.width === textureSize.width &&\r\n                this._textureCache[i].texture.height === textureSize.height &&\r\n                this._textureCache[i].postProcessChannel === channel &&\r\n                this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer &&\r\n                this._textureCache[i].texture.samples === textureOptions.samples\r\n            ) {\r\n                return this._textureCache[i].texture;\r\n            }\r\n        }\r\n\r\n        const tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);\r\n        this._textureCache.push({ texture: tex, postProcessChannel: channel, lastUsedRenderId: -1 });\r\n\r\n        return tex;\r\n    }\r\n\r\n    private _flushTextureCache() {\r\n        const currentRenderId = this._renderId;\r\n\r\n        for (let i = this._textureCache.length - 1; i >= 0; i--) {\r\n            if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {\r\n                let currentlyUsed = false;\r\n                for (let j = 0; j < this._textures.length; j++) {\r\n                    if (this._textures.data[j] === this._textureCache[i].texture) {\r\n                        currentlyUsed = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!currentlyUsed) {\r\n                    this._textureCache[i].texture.dispose();\r\n                    this._textureCache.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resizes the post-process texture\r\n     * @param width Width of the texture\r\n     * @param height Height of the texture\r\n     * @param camera The camera this post-process is applied to. Pass null if the post-process is used outside the context of a camera post-process chain (default: null)\r\n     * @param needMipMaps True if mip maps need to be generated after render (default: false)\r\n     * @param forceDepthStencil True to force post-process texture creation with stencil depth and buffer (default: false)\r\n     */\r\n    public resize(width: number, height: number, camera: Nullable<Camera> = null, needMipMaps = false, forceDepthStencil = false) {\r\n        if (this._textures.length > 0) {\r\n            this._textures.reset();\r\n        }\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        let firstPP = null;\r\n        if (camera) {\r\n            for (let i = 0; i < camera._postProcesses.length; i++) {\r\n                if (camera._postProcesses[i] !== null) {\r\n                    firstPP = camera._postProcesses[i];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const textureSize = { width: this.width, height: this.height };\r\n        const textureOptions = {\r\n            generateMipMaps: needMipMaps,\r\n            generateDepthBuffer: forceDepthStencil || firstPP === this,\r\n            generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,\r\n            samplingMode: this.renderTargetSamplingMode,\r\n            type: this._textureType,\r\n            format: this._textureFormat,\r\n            samples: this._samples,\r\n            label: \"PostProcessRTT-\" + this.name,\r\n        };\r\n\r\n        this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));\r\n\r\n        if (this._reusable) {\r\n            this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));\r\n        }\r\n\r\n        this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);\r\n\r\n        this.onSizeChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    private _getTarget() {\r\n        let target: RenderTargetWrapper;\r\n\r\n        if (this._shareOutputWithPostProcess) {\r\n            target = this._shareOutputWithPostProcess.inputTexture;\r\n        } else if (this._forcedOutputTexture) {\r\n            target = this._forcedOutputTexture;\r\n\r\n            this.width = this._forcedOutputTexture.width;\r\n            this.height = this._forcedOutputTexture.height;\r\n        } else {\r\n            target = this.inputTexture;\r\n\r\n            let cache;\r\n            for (let i = 0; i < this._textureCache.length; i++) {\r\n                if (this._textureCache[i].texture === target) {\r\n                    cache = this._textureCache[i];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (cache) {\r\n                cache.lastUsedRenderId = this._renderId;\r\n            }\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.\r\n     * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.\r\n     * @param cameraOrScene The camera that will be used in the post process. This camera will be used when calling onActivateObservable. You can also pass the scene if no camera is available.\r\n     * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)\r\n     * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)\r\n     * @returns The render target wrapper that was bound to be written to.\r\n     */\r\n    public activate(cameraOrScene: Nullable<Camera> | Scene, sourceTexture: Nullable<InternalTexture> = null, forceDepthStencil?: boolean): RenderTargetWrapper {\r\n        const camera = cameraOrScene === null || (cameraOrScene as Camera).cameraRigMode !== undefined ? (cameraOrScene as Camera) || this._camera : null;\r\n\r\n        const scene = camera?.getScene() ?? (cameraOrScene as Scene);\r\n        const engine = scene.getEngine();\r\n        const maxSize = engine.getCaps().maxTextureSize;\r\n\r\n        const requiredWidth = ((sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * <number>this._options) | 0;\r\n        const requiredHeight = ((sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * <number>this._options) | 0;\r\n\r\n        let desiredWidth = (<PostProcessOptions>this._options).width || requiredWidth;\r\n        let desiredHeight = (<PostProcessOptions>this._options).height || requiredHeight;\r\n\r\n        const needMipMaps =\r\n            this.renderTargetSamplingMode !== Constants.TEXTURE_NEAREST_LINEAR &&\r\n            this.renderTargetSamplingMode !== Constants.TEXTURE_NEAREST_NEAREST &&\r\n            this.renderTargetSamplingMode !== Constants.TEXTURE_LINEAR_LINEAR;\r\n\r\n        let target: Nullable<RenderTargetWrapper> = null;\r\n\r\n        if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\r\n            if (this.adaptScaleToCurrentViewport) {\r\n                const currentViewport = engine.currentViewport;\r\n\r\n                if (currentViewport) {\r\n                    desiredWidth *= currentViewport.width;\r\n                    desiredHeight *= currentViewport.height;\r\n                }\r\n            }\r\n\r\n            if (needMipMaps || this.alwaysForcePOT) {\r\n                if (!(<PostProcessOptions>this._options).width) {\r\n                    desiredWidth = engine.needPOTTextures ? GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;\r\n                }\r\n\r\n                if (!(<PostProcessOptions>this._options).height) {\r\n                    desiredHeight = engine.needPOTTextures ? GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;\r\n                }\r\n            }\r\n\r\n            if (this.width !== desiredWidth || this.height !== desiredHeight || !(target = this._getTarget())) {\r\n                this.resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);\r\n            }\r\n\r\n            this._textures.forEach((texture) => {\r\n                if (texture.samples !== this.samples) {\r\n                    this._engine.updateRenderTargetTextureSampleCount(texture, this.samples);\r\n                }\r\n            });\r\n\r\n            this._flushTextureCache();\r\n            this._renderId++;\r\n        }\r\n\r\n        if (!target) {\r\n            target = this._getTarget();\r\n        }\r\n\r\n        // Bind the input of this post process to be used as the output of the previous post process.\r\n        if (this.enablePixelPerfectMode) {\r\n            this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);\r\n            this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);\r\n        } else {\r\n            this._scaleRatio.copyFromFloats(1, 1);\r\n            this._engine.bindFramebuffer(target, 0, undefined, undefined, this.forceFullscreenViewport);\r\n        }\r\n\r\n        this._engine._debugInsertMarker?.(`post process ${this.name} input`);\r\n\r\n        this.onActivateObservable.notifyObservers(camera!);\r\n\r\n        // Clear\r\n        if (this.autoClear && (this.alphaMode === Constants.ALPHA_DISABLE || this.forceAutoClearInAlphaMode)) {\r\n            this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);\r\n        }\r\n\r\n        if (this._reusable) {\r\n            this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;\r\n        }\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * If the post process is supported.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._effectWrapper.drawWrapper.effect!.isSupported;\r\n    }\r\n\r\n    /**\r\n     * The aspect ratio of the output texture.\r\n     */\r\n    public get aspectRatio(): number {\r\n        if (this._shareOutputWithPostProcess) {\r\n            return this._shareOutputWithPostProcess.aspectRatio;\r\n        }\r\n\r\n        if (this._forcedOutputTexture) {\r\n            return this._forcedOutputTexture.width / this._forcedOutputTexture.height;\r\n        }\r\n        return this.width / this.height;\r\n    }\r\n\r\n    /**\r\n     * Get a value indicating if the post-process is ready to be used\r\n     * @returns true if the post-process is ready (shader is compiled)\r\n     */\r\n    public isReady(): boolean {\r\n        return this._effectWrapper.isReady();\r\n    }\r\n\r\n    /**\r\n     * Binds all textures and uniforms to the shader, this will be run on every pass.\r\n     * @returns the effect corresponding to this post process. Null if not compiled or not ready.\r\n     */\r\n    public apply(): Nullable<Effect> {\r\n        // Check\r\n        if (!this._effectWrapper.isReady()) {\r\n            return null;\r\n        }\r\n\r\n        // States\r\n        this._engine.enableEffect(this._effectWrapper.drawWrapper);\r\n        this._engine.setState(false);\r\n        this._engine.setDepthBuffer(false);\r\n        this._engine.setDepthWrite(false);\r\n\r\n        // Alpha\r\n        if (this.alphaConstants) {\r\n            this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);\r\n        }\r\n\r\n        this._engine.setAlphaMode(this.alphaMode);\r\n\r\n        // Bind the output texture of the preivous post process as the input to this post process.\r\n        let source: RenderTargetWrapper;\r\n        if (this._shareOutputWithPostProcess) {\r\n            source = this._shareOutputWithPostProcess.inputTexture;\r\n        } else if (this._forcedOutputTexture) {\r\n            source = this._forcedOutputTexture;\r\n        } else {\r\n            source = this.inputTexture;\r\n        }\r\n\r\n        if (!this.externalTextureSamplerBinding) {\r\n            this._effectWrapper.drawWrapper.effect!._bindTexture(\"textureSampler\", source?.texture);\r\n        }\r\n\r\n        // Parameters\r\n        this._effectWrapper.drawWrapper.effect!.setVector2(\"scale\", this._scaleRatio);\r\n        this.onApplyObservable.notifyObservers(this._effectWrapper.drawWrapper.effect!);\r\n\r\n        this._effectWrapper.bind(true);\r\n\r\n        return this._effectWrapper.drawWrapper.effect;\r\n    }\r\n\r\n    private _disposeTextures() {\r\n        if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {\r\n            this._disposeTextureCache();\r\n            return;\r\n        }\r\n\r\n        this._disposeTextureCache();\r\n        this._textures.dispose();\r\n    }\r\n\r\n    private _disposeTextureCache() {\r\n        for (let i = this._textureCache.length - 1; i >= 0; i--) {\r\n            this._textureCache[i].texture.dispose();\r\n        }\r\n\r\n        this._textureCache.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        if (this._prePassEffectConfiguration) {\r\n            this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\r\n            this._prePassEffectConfiguration.enabled = true;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public dispose(camera?: Camera): void {\r\n        camera = camera || this._camera;\r\n\r\n        if (!this._useExistingThinPostProcess) {\r\n            this._effectWrapper.dispose();\r\n        }\r\n\r\n        this._disposeTextures();\r\n\r\n        let index;\r\n        if (this._scene) {\r\n            index = this._scene.removePostProcess(this);\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.postProcesses.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.postProcesses.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        index = this._engine.postProcesses.indexOf(this);\r\n        if (index !== -1) {\r\n            this._engine.postProcesses.splice(index, 1);\r\n        }\r\n\r\n        this.onDisposeObservable.notifyObservers();\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n        camera.detachPostProcess(this);\r\n\r\n        index = camera._postProcesses.indexOf(this);\r\n        if (index === 0 && camera._postProcesses.length > 0) {\r\n            const firstPostProcess = this._camera._getFirstPostProcess();\r\n            if (firstPostProcess) {\r\n                firstPostProcess.markTextureDirty();\r\n            }\r\n        }\r\n\r\n        this.onActivateObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onApplyObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n        this.onEffectCreatedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Serializes the post process to a JSON object\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        const camera = this.getCamera() || (this._scene && this._scene.activeCamera);\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.cameraId = camera ? camera.id : null;\r\n        serializationObject.reusable = this._reusable;\r\n        serializationObject.textureType = this._textureType;\r\n        serializationObject.fragmentUrl = this._fragmentUrl;\r\n        serializationObject.parameters = this._parameters;\r\n        serializationObject.samplers = this._samplers;\r\n        serializationObject.uniformBuffers = this._uniformBuffers;\r\n        serializationObject.options = this._options;\r\n        serializationObject.defines = this._postProcessDefines;\r\n        serializationObject.textureFormat = this._textureFormat;\r\n        serializationObject.vertexUrl = this._vertexUrl;\r\n        serializationObject.indexParameters = this._indexParameters;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Clones this post process\r\n     * @returns a new post process similar to this one\r\n     */\r\n    public clone(): Nullable<PostProcess> {\r\n        const serializationObject = this.serialize();\r\n        serializationObject._engine = this._engine;\r\n        serializationObject.cameraId = null;\r\n\r\n        const result = PostProcess.Parse(serializationObject, this._scene, \"\");\r\n\r\n        if (!result) {\r\n            return null;\r\n        }\r\n\r\n        result.onActivateObservable = this.onActivateObservable.clone();\r\n        result.onSizeChangedObservable = this.onSizeChangedObservable.clone();\r\n        result.onApplyObservable = this.onApplyObservable.clone();\r\n        result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();\r\n        result.onAfterRenderObservable = this.onAfterRenderObservable.clone();\r\n\r\n        result._prePassEffectConfiguration = this._prePassEffectConfiguration;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedPostProcess defines parsed post process data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new post process\r\n     */\r\n    public static Parse(parsedPostProcess: any, scene: Scene, rootUrl: string): Nullable<PostProcess> {\r\n        const postProcessType = GetClass(parsedPostProcess.customType);\r\n\r\n        if (!postProcessType || !postProcessType._Parse) {\r\n            return null;\r\n        }\r\n\r\n        const camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;\r\n        return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl) as Nullable<PostProcess>;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Nullable<Camera>, scene: Nullable<Scene>, rootUrl: string): Nullable<PostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.fragmentUrl,\r\n                    parsedPostProcess.parameters,\r\n                    parsedPostProcess.samplers,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.defines,\r\n                    parsedPostProcess.textureType,\r\n                    parsedPostProcess.vertexUrl,\r\n                    parsedPostProcess.indexParameters,\r\n                    false,\r\n                    parsedPostProcess.textureFormat\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PostProcess\", PostProcess);\r\n"],
  "mappings": "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",
  "names": ["mesh", "index"]
}
