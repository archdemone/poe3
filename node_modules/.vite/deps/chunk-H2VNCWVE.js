import {
  SmartArray
} from "./chunk-SZB5QSYK.js";
import {
  Frustum
} from "./chunk-CUS3R4VO.js";
import {
  Viewport
} from "./chunk-4BKKNZXJ.js";
import {
  Node
} from "./chunk-SQHPNIL3.js";
import {
  Tools
} from "./chunk-A25D3L3D.js";
import {
  SerializationHelper
} from "./chunk-RKGZOZHN.js";
import {
  __decorate,
  serialize,
  serializeAsVector3
} from "./chunk-PVEEDNYT.js";
import {
  _WarnImport
} from "./chunk-OWCZTH5B.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import {
  Matrix,
  Quaternion,
  Vector3
} from "./chunk-MBRMNX5M.js";
import {
  Observable
} from "./chunk-2YUEJ7I2.js";
import {
  GetClass
} from "./chunk-S7NDMBDF.js";

// node_modules/@babylonjs/core/sceneComponent.js
var SceneComponentConstants = class {
};
SceneComponentConstants.NAME_EFFECTLAYER = "EffectLayer";
SceneComponentConstants.NAME_LAYER = "Layer";
SceneComponentConstants.NAME_LENSFLARESYSTEM = "LensFlareSystem";
SceneComponentConstants.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
SceneComponentConstants.NAME_PARTICLESYSTEM = "ParticleSystem";
SceneComponentConstants.NAME_GAMEPAD = "Gamepad";
SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
SceneComponentConstants.NAME_PREPASSRENDERER = "PrePassRenderer";
SceneComponentConstants.NAME_DEPTHRENDERER = "DepthRenderer";
SceneComponentConstants.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer";
SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
SceneComponentConstants.NAME_SPRITE = "Sprite";
SceneComponentConstants.NAME_SUBSURFACE = "SubSurface";
SceneComponentConstants.NAME_OUTLINERENDERER = "Outline";
SceneComponentConstants.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
SceneComponentConstants.NAME_SHADOWGENERATOR = "ShadowGenerator";
SceneComponentConstants.NAME_OCTREE = "Octree";
SceneComponentConstants.NAME_PHYSICSENGINE = "PhysicsEngine";
SceneComponentConstants.NAME_AUDIO = "Audio";
SceneComponentConstants.NAME_FLUIDRENDERER = "FluidRenderer";
SceneComponentConstants.NAME_IBLCDFGENERATOR = "iblCDFGenerator";
SceneComponentConstants.NAME_CLUSTEREDLIGHTING = "ClusteredLighting";
SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS = 0;
SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;
SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER = 2;
SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;
SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER = 1;
SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS = 0;
SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
SceneComponentConstants.STEP_BEFORECLEAR_PREPASS = 1;
SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER = 1;
SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS = 0;
SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;
SceneComponentConstants.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;
SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;
SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER = 4;
SceneComponentConstants.STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5;
SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0;
SceneComponentConstants.STEP_AFTERRENDER_AUDIO = 0;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_CLUSTEREDLIGHTING = 2;
SceneComponentConstants.STEP_POINTERMOVE_SPRITE = 0;
SceneComponentConstants.STEP_POINTERDOWN_SPRITE = 0;
SceneComponentConstants.STEP_POINTERUP_SPRITE = 0;
var Stage = class _Stage extends Array {
  /**
   * Hide ctor from the rest of the world.
   * @param items The items to add.
   */
  constructor(items) {
    super(...items);
  }
  /**
   * Creates a new Stage.
   * @returns A new instance of a Stage
   */
  static Create() {
    return Object.create(_Stage.prototype);
  }
  /**
   * Registers a step in an ordered way in the targeted stage.
   * @param index Defines the position to register the step in
   * @param component Defines the component attached to the step
   * @param action Defines the action to launch during the step
   */
  registerStep(index, component, action) {
    let i = 0;
    let maxIndex = Number.MAX_VALUE;
    for (; i < this.length; i++) {
      const step = this[i];
      maxIndex = step.index;
      if (index < maxIndex) {
        break;
      }
    }
    this.splice(i, 0, { index, component, action: action.bind(component) });
  }
  /**
   * Clears all the steps from the stage.
   */
  clear() {
    this.length = 0;
  }
};

// node_modules/@babylonjs/core/Cameras/camera.js
var Camera = class _Camera extends Node {
  /**
   * Define the current local position of the camera in the scene
   */
  get position() {
    return this._position;
  }
  set position(newPosition) {
    this._position = newPosition;
  }
  /**
   * The vector the camera should consider as up.
   * (default is Vector3(0, 1, 0) aka Vector3.Up())
   */
  set upVector(vec) {
    this._upVector = vec;
  }
  get upVector() {
    return this._upVector;
  }
  /**
   * The screen area in scene units squared
   */
  get screenArea() {
    let x = 0;
    let y = 0;
    if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
      if (this.fovMode === _Camera.FOVMODE_VERTICAL_FIXED) {
        y = this.minZ * 2 * Math.tan(this.fov / 2);
        x = this.getEngine().getAspectRatio(this) * y;
      } else {
        x = this.minZ * 2 * Math.tan(this.fov / 2);
        y = x / this.getEngine().getAspectRatio(this);
      }
    } else {
      const halfWidth = this.getEngine().getRenderWidth() / 2;
      const halfHeight = this.getEngine().getRenderHeight() / 2;
      x = (this.orthoRight ?? halfWidth) - (this.orthoLeft ?? -halfWidth);
      y = (this.orthoTop ?? halfHeight) - (this.orthoBottom ?? -halfHeight);
    }
    return x * y;
  }
  /**
   * Define the current limit on the left side for an orthographic camera
   * In scene unit
   */
  set orthoLeft(value) {
    this._orthoLeft = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoLeft = value;
    }
  }
  get orthoLeft() {
    return this._orthoLeft;
  }
  /**
   * Define the current limit on the right side for an orthographic camera
   * In scene unit
   */
  set orthoRight(value) {
    this._orthoRight = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoRight = value;
    }
  }
  get orthoRight() {
    return this._orthoRight;
  }
  /**
   * Define the current limit on the bottom side for an orthographic camera
   * In scene unit
   */
  set orthoBottom(value) {
    this._orthoBottom = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoBottom = value;
    }
  }
  get orthoBottom() {
    return this._orthoBottom;
  }
  /**
   * Define the current limit on the top side for an orthographic camera
   * In scene unit
   */
  set orthoTop(value) {
    this._orthoTop = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoTop = value;
    }
  }
  get orthoTop() {
    return this._orthoTop;
  }
  /**
   * Sets the camera's field of view in radians based on the focal length and sensor size.
   * @param value the focal length of the camera in mm.
   * @param sensorSize the sensor width size of the camera in mm. (default is 36mm, which is a full frame sensor)
   */
  setFocalLength(value, sensorSize = 36) {
    this.fov = 2 * Math.atan(sensorSize / (2 * value));
  }
  /**
   * Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.ORTHOGRAPHIC_CAMERA)
   */
  set mode(mode) {
    this._mode = mode;
    for (const rigCamera of this._rigCameras) {
      rigCamera.mode = mode;
    }
  }
  get mode() {
    return this._mode;
  }
  /**
   * Gets a flag indicating that the camera has moved in some way since the last call to Camera.update()
   */
  get hasMoved() {
    return this._hasMoved;
  }
  /**
   * Instantiates a new camera object.
   * This should not be used directly but through the inherited cameras: ArcRotate, Free...
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras
   * @param name Defines the name of the camera in the scene
   * @param position Defines the position of the camera
   * @param scene Defines the scene the camera belongs too
   * @param setActiveOnSceneIfNoneActive Defines if the camera should be set as active after creation if no other camera have been defined in the scene
   */
  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {
    super(name, scene, false);
    this._position = Vector3.Zero();
    this._upVector = Vector3.Up();
    this.oblique = null;
    this._orthoLeft = null;
    this._orthoRight = null;
    this._orthoBottom = null;
    this._orthoTop = null;
    this.fov = 0.8;
    this.projectionPlaneTilt = 0;
    this.minZ = 1;
    this.maxZ = 1e4;
    this.inertia = 0.9;
    this._mode = _Camera.PERSPECTIVE_CAMERA;
    this.isIntermediate = false;
    this.viewport = new Viewport(0, 0, 1, 1);
    this.layerMask = 268435455;
    this.fovMode = _Camera.FOVMODE_VERTICAL_FIXED;
    this.cameraRigMode = _Camera.RIG_MODE_NONE;
    this.customRenderTargets = [];
    this.outputRenderTarget = null;
    this.onViewMatrixChangedObservable = new Observable();
    this.onProjectionMatrixChangedObservable = new Observable();
    this.onAfterCheckInputsObservable = new Observable();
    this.onRestoreStateObservable = new Observable();
    this.isRigCamera = false;
    this._hasMoved = false;
    this._rigCameras = new Array();
    this._skipRendering = false;
    this._projectionMatrix = new Matrix();
    this._postProcesses = new Array();
    this._activeMeshes = new SmartArray(256);
    this._globalPosition = Vector3.Zero();
    this._computedViewMatrix = Matrix.Identity();
    this._doNotComputeProjectionMatrix = false;
    this._transformMatrix = Matrix.Zero();
    this._refreshFrustumPlanes = true;
    this._absoluteRotation = Quaternion.Identity();
    this._isCamera = true;
    this._isLeftCamera = false;
    this._isRightCamera = false;
    this.getScene().addCamera(this);
    if (setActiveOnSceneIfNoneActive && !this.getScene().activeCamera) {
      this.getScene().activeCamera = this;
    }
    this.position = position;
    this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${name}`);
  }
  /**
   * Store current camera state (fov, position, etc..)
   * @returns the camera
   */
  storeState() {
    this._stateStored = true;
    this._storedFov = this.fov;
    return this;
  }
  /**
   * Returns true if a state has been stored by calling storeState method.
   * @returns true if state has been stored.
   */
  hasStateStored() {
    return !!this._stateStored;
  }
  /**
   * Restores the camera state values if it has been stored. You must call storeState() first
   * @returns true if restored and false otherwise
   */
  _restoreStateValues() {
    if (!this._stateStored) {
      return false;
    }
    this.fov = this._storedFov;
    return true;
  }
  /**
   * Restored camera state. You must call storeState() first.
   * @returns true if restored and false otherwise
   */
  restoreState() {
    if (this._restoreStateValues()) {
      this.onRestoreStateObservable.notifyObservers(this);
      return true;
    }
    return false;
  }
  /**
   * Gets the class name of the camera.
   * @returns the class name
   */
  getClassName() {
    return "Camera";
  }
  /**
   * Gets a string representation of the camera useful for debug purpose.
   * @param fullDetails Defines that a more verbose level of logging is required
   * @returns the string representation
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    ret += ", type: " + this.getClassName();
    if (this.animations) {
      for (let i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  }
  /**
   * Automatically tilts the projection plane, using `projectionPlaneTilt`, to correct the perspective effect on vertical lines.
   */
  applyVerticalCorrection() {
    const rot = this.absoluteRotation.toEulerAngles();
    this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;
  }
  /**
   * Gets the current world space position of the camera.
   */
  get globalPosition() {
    return this._globalPosition;
  }
  /**
   * Gets the list of active meshes this frame (meshes no culled or excluded by lod s in the frame)
   * @returns the active meshe list
   */
  getActiveMeshes() {
    return this._activeMeshes;
  }
  /**
   * Check whether a mesh is part of the current active mesh list of the camera
   * @param mesh Defines the mesh to check
   * @returns true if active, false otherwise
   */
  isActiveMesh(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  }
  /**
   * Is this camera ready to be used/rendered
   * @param completeCheck defines if a complete check (including post processes) has to be done (false by default)
   * @returns true if the camera is ready
   */
  isReady(completeCheck = false) {
    if (completeCheck) {
      for (const pp of this._postProcesses) {
        if (pp && !pp.isReady()) {
          return false;
        }
      }
    }
    return super.isReady(completeCheck);
  }
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.mode = void 0;
    this._cache.minZ = void 0;
    this._cache.maxZ = void 0;
    this._cache.fov = void 0;
    this._cache.fovMode = void 0;
    this._cache.aspectRatio = void 0;
    this._cache.orthoLeft = void 0;
    this._cache.orthoRight = void 0;
    this._cache.orthoBottom = void 0;
    this._cache.orthoTop = void 0;
    this._cache.obliqueAngle = void 0;
    this._cache.obliqueLength = void 0;
    this._cache.obliqueOffset = void 0;
    this._cache.renderWidth = void 0;
    this._cache.renderHeight = void 0;
  }
  /**
   * @internal
   */
  _updateCache(ignoreParentClass) {
    if (!ignoreParentClass) {
      super._updateCache();
    }
    this._cache.position.copyFrom(this.position);
    this._cache.upVector.copyFrom(this.upVector);
  }
  /** @internal */
  _isSynchronized() {
    return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
  }
  /** @internal */
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronized()) {
      return false;
    }
    return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();
  }
  /** @internal */
  _isSynchronizedProjectionMatrix() {
    let isSynchronized = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
    if (!isSynchronized) {
      return false;
    }
    const engine = this.getEngine();
    if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
      isSynchronized = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === engine.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt;
    } else {
      isSynchronized = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === engine.getRenderWidth() && this._cache.renderHeight === engine.getRenderHeight();
      if (this.oblique) {
        isSynchronized = isSynchronized && this._cache.obliqueAngle === this.oblique.angle && this._cache.obliqueLength === this.oblique.length && this._cache.obliqueOffset === this.oblique.offset;
      }
    }
    return isSynchronized;
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * This function is here because typescript removes the typing of the last function.
   * @param _ignored defines an ignored parameter kept for backward compatibility.
   * @param _noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(_ignored, _noPreventDefault) {
  }
  /**
   * Detach the current controls from the specified dom element.
   * This function is here because typescript removes the typing of the last function.
   * @param _ignored defines an ignored parameter kept for backward compatibility.
   */
  detachControl(_ignored) {
  }
  /**
   * Update the camera state according to the different inputs gathered during the frame.
   */
  update() {
    this._hasMoved = false;
    this._checkInputs();
    if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
      this._updateRigCameras();
    }
    this.getViewMatrix();
    this.getProjectionMatrix();
  }
  /** @internal */
  _checkInputs() {
    this.onAfterCheckInputsObservable.notifyObservers(this);
  }
  /** @internal */
  get rigCameras() {
    return this._rigCameras;
  }
  /**
   * Gets the post process used by the rig cameras
   */
  get rigPostProcess() {
    return this._rigPostProcess;
  }
  /**
   * Internal, gets the first post process.
   * @returns the first post process to be run on this camera.
   */
  _getFirstPostProcess() {
    for (let ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {
      if (this._postProcesses[ppIndex] !== null) {
        return this._postProcesses[ppIndex];
      }
    }
    return null;
  }
  _cascadePostProcessesToRigCams() {
    const firstPostProcess = this._getFirstPostProcess();
    if (firstPostProcess) {
      firstPostProcess.markTextureDirty();
    }
    for (let i = 0, len = this._rigCameras.length; i < len; i++) {
      const cam = this._rigCameras[i];
      const rigPostProcess = cam._rigPostProcess;
      if (rigPostProcess) {
        const isPass = rigPostProcess.getEffectName() === "pass";
        if (isPass) {
          cam.isIntermediate = this._postProcesses.length === 0;
        }
        cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);
        rigPostProcess.markTextureDirty();
      } else {
        cam._postProcesses = this._postProcesses.slice(0);
      }
    }
  }
  /**
   * Attach a post process to the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess
   * @param postProcess The post process to attach to the camera
   * @param insertAt The position of the post process in case several of them are in use in the scene
   * @returns the position the post process has been inserted at
   */
  attachPostProcess(postProcess, insertAt = null) {
    if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {
      Logger.Error("You're trying to reuse a post process not defined as reusable.");
      return 0;
    }
    if (insertAt == null || insertAt < 0) {
      this._postProcesses.push(postProcess);
    } else if (this._postProcesses[insertAt] === null) {
      this._postProcesses[insertAt] = postProcess;
    } else {
      this._postProcesses.splice(insertAt, 0, postProcess);
    }
    this._cascadePostProcessesToRigCams();
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    return this._postProcesses.indexOf(postProcess);
  }
  /**
   * Detach a post process to the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess
   * @param postProcess The post process to detach from the camera
   */
  detachPostProcess(postProcess) {
    const idx = this._postProcesses.indexOf(postProcess);
    if (idx !== -1) {
      this._postProcesses[idx] = null;
    }
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    this._cascadePostProcessesToRigCams();
  }
  /**
   * Gets the current world matrix of the camera
   * @returns the world matrix
   */
  getWorldMatrix() {
    if (this._isSynchronizedViewMatrix()) {
      return this._worldMatrix;
    }
    this.getViewMatrix();
    return this._worldMatrix;
  }
  /** @internal */
  _getViewMatrix() {
    return Matrix.Identity();
  }
  /**
   * Gets the current view matrix of the camera.
   * @param force forces the camera to recompute the matrix without looking at the cached state
   * @returns the view matrix
   */
  getViewMatrix(force) {
    if (!force && this._isSynchronizedViewMatrix()) {
      return this._computedViewMatrix;
    }
    this._hasMoved = true;
    this.updateCache();
    this._computedViewMatrix = this._getViewMatrix();
    this._currentRenderId = this.getScene().getRenderId();
    this._childUpdateId++;
    this._refreshFrustumPlanes = true;
    if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {
      this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);
    }
    if (this.parent && this.parent.onViewMatrixChangedObservable) {
      this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);
    }
    this.onViewMatrixChangedObservable.notifyObservers(this);
    this._computedViewMatrix.invertToRef(this._worldMatrix);
    return this._computedViewMatrix;
  }
  /**
   * Freeze the projection matrix.
   * It will prevent the cache check of the camera projection compute and can speed up perf
   * if no parameter of the camera are meant to change
   * @param projection Defines manually a projection if necessary
   */
  freezeProjectionMatrix(projection) {
    this._doNotComputeProjectionMatrix = true;
    if (projection !== void 0) {
      this._projectionMatrix = projection;
    }
  }
  /**
   * Unfreeze the projection matrix if it has previously been freezed by freezeProjectionMatrix.
   */
  unfreezeProjectionMatrix() {
    this._doNotComputeProjectionMatrix = false;
  }
  /**
   * Gets the current projection matrix of the camera.
   * @param force forces the camera to recompute the matrix without looking at the cached state
   * @returns the projection matrix
   */
  getProjectionMatrix(force) {
    var _a, _b, _c;
    if (this._doNotComputeProjectionMatrix || !force && this._isSynchronizedProjectionMatrix()) {
      return this._projectionMatrix;
    }
    this._cache.mode = this.mode;
    this._cache.minZ = this.minZ;
    this._cache.maxZ = this.maxZ;
    this._refreshFrustumPlanes = true;
    const engine = this.getEngine();
    const scene = this.getScene();
    const reverseDepth = engine.useReverseDepthBuffer;
    if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
      this._cache.fov = this.fov;
      this._cache.fovMode = this.fovMode;
      this._cache.aspectRatio = engine.getAspectRatio(this);
      this._cache.projectionPlaneTilt = this.projectionPlaneTilt;
      if (this.minZ <= 0) {
        this.minZ = 0.1;
      }
      let getProjectionMatrix;
      if (scene.useRightHandedSystem) {
        getProjectionMatrix = Matrix.PerspectiveFovRHToRef;
      } else {
        getProjectionMatrix = Matrix.PerspectiveFovLHToRef;
      }
      getProjectionMatrix(this.fov, engine.getAspectRatio(this), reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === _Camera.FOVMODE_VERTICAL_FIXED, engine.isNDCHalfZRange, this.projectionPlaneTilt, reverseDepth);
    } else {
      const halfWidth = engine.getRenderWidth() / 2;
      const halfHeight = engine.getRenderHeight() / 2;
      if (scene.useRightHandedSystem) {
        if (this.oblique) {
          Matrix.ObliqueOffCenterRHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, engine.isNDCHalfZRange);
        } else {
          Matrix.OrthoOffCenterRHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
        }
      } else {
        if (this.oblique) {
          Matrix.ObliqueOffCenterLHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, engine.isNDCHalfZRange);
        } else {
          Matrix.OrthoOffCenterLHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
        }
      }
      this._cache.orthoLeft = this.orthoLeft;
      this._cache.orthoRight = this.orthoRight;
      this._cache.orthoBottom = this.orthoBottom;
      this._cache.orthoTop = this.orthoTop;
      this._cache.obliqueAngle = (_a = this.oblique) == null ? void 0 : _a.angle;
      this._cache.obliqueLength = (_b = this.oblique) == null ? void 0 : _b.length;
      this._cache.obliqueOffset = (_c = this.oblique) == null ? void 0 : _c.offset;
      this._cache.renderWidth = engine.getRenderWidth();
      this._cache.renderHeight = engine.getRenderHeight();
    }
    this.onProjectionMatrixChangedObservable.notifyObservers(this);
    return this._projectionMatrix;
  }
  /**
   * Gets the transformation matrix (ie. the multiplication of view by projection matrices)
   * @returns a Matrix
   */
  getTransformationMatrix() {
    this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    return this._transformMatrix;
  }
  _computeObliqueDistance(offset) {
    const arcRotateCamera = this;
    const targetCamera = this;
    return (arcRotateCamera.radius || (targetCamera.target ? Vector3.Distance(this.position, targetCamera.target) : this.position.length())) + offset;
  }
  /** @internal */
  _updateFrustumPlanes() {
    if (!this._refreshFrustumPlanes) {
      return;
    }
    this.getTransformationMatrix();
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    this._refreshFrustumPlanes = false;
  }
  /**
   * Checks if a cullable object (mesh...) is in the camera frustum
   * This checks the bounding box center. See isCompletelyInFrustum for a full bounding check
   * @param target The object to check
   * @param checkRigCameras If the rig cameras should be checked (eg. with VR camera both eyes should be checked) (Default: false)
   * @returns true if the object is in frustum otherwise false
   */
  isInFrustum(target, checkRigCameras = false) {
    this._updateFrustumPlanes();
    if (checkRigCameras && this.rigCameras.length > 0) {
      let result = false;
      for (const cam of this.rigCameras) {
        cam._updateFrustumPlanes();
        result = result || target.isInFrustum(cam._frustumPlanes);
      }
      return result;
    } else {
      return target.isInFrustum(this._frustumPlanes);
    }
  }
  /**
   * Checks if a cullable object (mesh...) is in the camera frustum
   * Unlike isInFrustum this checks the full bounding box
   * @param target The object to check
   * @returns true if the object is in frustum otherwise false
   */
  isCompletelyInFrustum(target) {
    this._updateFrustumPlanes();
    return target.isCompletelyInFrustum(this._frustumPlanes);
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Gets a ray in the forward direction from the camera.
   * @param length Defines the length of the ray to create
   * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a world space ray
   * @param origin Defines the start point of the ray which defaults to the camera position
   * @returns the forward ray
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getForwardRay(length = 100, transform, origin) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Gets a ray in the forward direction from the camera.
   * @param refRay the ray to (re)use when setting the values
   * @param length Defines the length of the ray to create
   * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a world space ray
   * @param origin Defines the start point of the ray which defaults to the camera position
   * @returns the forward ray
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getForwardRayToRef(refRay, length = 100, transform, origin) {
    throw _WarnImport("Ray");
  }
  /**
   * Releases resources associated with this node.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this.onViewMatrixChangedObservable.clear();
    this.onProjectionMatrixChangedObservable.clear();
    this.onAfterCheckInputsObservable.clear();
    this.onRestoreStateObservable.clear();
    if (this.inputs) {
      this.inputs.clear();
    }
    this.getScene().stopAnimation(this);
    this.getScene().removeCamera(this);
    while (this._rigCameras.length > 0) {
      const camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    if (this._parentContainer) {
      const index = this._parentContainer.cameras.indexOf(this);
      if (index > -1) {
        this._parentContainer.cameras.splice(index, 1);
      }
      this._parentContainer = null;
    }
    if (this._rigPostProcess) {
      this._rigPostProcess.dispose(this);
      this._rigPostProcess = null;
      this._postProcesses.length = 0;
    } else if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
      this._rigPostProcess = null;
      this._postProcesses.length = 0;
    } else {
      let i2 = this._postProcesses.length;
      while (--i2 >= 0) {
        const postProcess = this._postProcesses[i2];
        if (postProcess) {
          postProcess.dispose(this);
        }
      }
    }
    let i = this.customRenderTargets.length;
    while (--i >= 0) {
      this.customRenderTargets[i].dispose();
    }
    this.customRenderTargets.length = 0;
    this._activeMeshes.dispose();
    this.getScene().getEngine().releaseRenderPassId(this.renderPassId);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * Gets the left camera of a rig setup in case of Rigged Camera
   */
  get isLeftCamera() {
    return this._isLeftCamera;
  }
  /**
   * Gets the right camera of a rig setup in case of Rigged Camera
   */
  get isRightCamera() {
    return this._isRightCamera;
  }
  /**
   * Gets the left camera of a rig setup in case of Rigged Camera
   */
  get leftCamera() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0];
  }
  /**
   * Gets the right camera of a rig setup in case of Rigged Camera
   */
  get rightCamera() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1];
  }
  /**
   * Gets the left camera target of a rig setup in case of Rigged Camera
   * @returns the target position
   */
  getLeftTarget() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0].getTarget();
  }
  /**
   * Gets the right camera target of a rig setup in case of Rigged Camera
   * @returns the target position
   */
  getRightTarget() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1].getTarget();
  }
  /**
   * @internal
   */
  setCameraRigMode(mode, rigParams) {
    if (this.cameraRigMode === mode) {
      return;
    }
    while (this._rigCameras.length > 0) {
      const camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    this.cameraRigMode = mode;
    this._cameraRigParams = {};
    this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;
    this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);
    if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
      const leftCamera = this.createRigCamera(this.name + "_L", 0);
      if (leftCamera) {
        leftCamera._isLeftCamera = true;
      }
      const rightCamera = this.createRigCamera(this.name + "_R", 1);
      if (rightCamera) {
        rightCamera._isRightCamera = true;
      }
      if (leftCamera && rightCamera) {
        this._rigCameras.push(leftCamera);
        this._rigCameras.push(rightCamera);
      }
    }
    this._setRigMode(rigParams);
    this._cascadePostProcessesToRigCams();
    this.update();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _setRigMode(rigParams) {
  }
  /** @internal */
  _getVRProjectionMatrix() {
    Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, true, this.getEngine().isNDCHalfZRange);
    this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);
    return this._projectionMatrix;
  }
  /**
   * @internal
   */
  setCameraRigParameter(name, value) {
    if (!this._cameraRigParams) {
      this._cameraRigParams = {};
    }
    this._cameraRigParams[name] = value;
    if (name === "interaxialDistance") {
      this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);
    }
  }
  /**
   * needs to be overridden by children so sub has required properties to be copied
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createRigCamera(name, cameraIndex) {
    return null;
  }
  /**
   * May need to be overridden by children
   * @internal
   */
  _updateRigCameras() {
    for (let i = 0; i < this._rigCameras.length; i++) {
      this._rigCameras[i].minZ = this.minZ;
      this._rigCameras[i].maxZ = this.maxZ;
      this._rigCameras[i].fov = this.fov;
      this._rigCameras[i].upVector.copyFrom(this.upVector);
    }
    if (this.cameraRigMode === _Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {
      this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;
    }
  }
  /** @internal */
  _setupInputs() {
  }
  /**
   * Serialiaze the camera setup to a json representation
   * @returns the JSON representation
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getClassName();
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    if (this.inputs) {
      this.inputs.serialize(serializationObject);
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  }
  /**
   * Clones the current camera.
   * @param name The cloned camera name
   * @param newParent The cloned camera's new parent (none by default)
   * @returns the cloned camera
   */
  clone(name, newParent = null) {
    const camera = SerializationHelper.Clone(_Camera.GetConstructorFromName(this.getClassName(), name, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
    camera.name = name;
    camera.parent = newParent;
    this.onClonedObservable.notifyObservers(camera);
    return camera;
  }
  /**
   * Gets the direction of the camera relative to a given local axis.
   * @param localAxis Defines the reference axis to provide a relative direction.
   * @returns the direction
   */
  getDirection(localAxis) {
    const result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  }
  /**
   * Returns the current camera absolute rotation
   */
  get absoluteRotation() {
    this.getWorldMatrix().decompose(void 0, this._absoluteRotation);
    return this._absoluteRotation;
  }
  /**
   * Gets the direction of the camera relative to a given local axis into a passed vector.
   * @param localAxis Defines the reference axis to provide a relative direction.
   * @param result Defines the vector to store the result in
   */
  getDirectionToRef(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
  }
  /**
   * Gets a camera constructor for a given camera type
   * @param type The type of the camera to construct (should be equal to one of the camera class name)
   * @param name The name of the camera the result will be able to instantiate
   * @param scene The scene the result will construct the camera in
   * @param interaxial_distance In case of stereoscopic setup, the distance between both eyes
   * @param isStereoscopicSideBySide In case of stereoscopic setup, should the sereo be side b side
   * @returns a factory method to construct the camera
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static GetConstructorFromName(type, name, scene, interaxial_distance = 0, isStereoscopicSideBySide = true) {
    const constructorFunc = Node.Construct(type, name, scene, {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      interaxial_distance,
      isStereoscopicSideBySide
    });
    if (constructorFunc) {
      return constructorFunc;
    }
    return () => _Camera._CreateDefaultParsedCamera(name, scene);
  }
  /**
   * Compute the world  matrix of the camera.
   * @returns the camera world matrix
   */
  computeWorldMatrix() {
    return this.getWorldMatrix();
  }
  /**
   * Parse a JSON and creates the camera from the parsed information
   * @param parsedCamera The JSON to parse
   * @param scene The scene to instantiate the camera in
   * @returns the newly constructed camera
   */
  static Parse(parsedCamera, scene) {
    const type = parsedCamera.type;
    const construct = _Camera.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);
    const camera = SerializationHelper.Parse(construct, parsedCamera, scene);
    if (parsedCamera.parentId !== void 0) {
      camera._waitingParentId = parsedCamera.parentId;
    }
    if (parsedCamera.parentInstanceIndex !== void 0) {
      camera._waitingParentInstanceIndex = parsedCamera.parentInstanceIndex;
    }
    if (camera.inputs) {
      camera.inputs.parse(parsedCamera);
      camera._setupInputs();
    }
    if (parsedCamera.upVector) {
      camera.upVector = Vector3.FromArray(parsedCamera.upVector);
    }
    if (camera.setPosition) {
      camera.position.copyFromFloats(0, 0, 0);
      camera.setPosition(Vector3.FromArray(parsedCamera.position));
    }
    if (parsedCamera.target) {
      if (camera.setTarget) {
        camera.setTarget(Vector3.FromArray(parsedCamera.target));
      }
    }
    if (parsedCamera.cameraRigMode) {
      const rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};
      camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);
    }
    if (parsedCamera.animations) {
      for (let animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {
        const parsedAnimation = parsedCamera.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          camera.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(camera, parsedCamera, scene);
    }
    if (parsedCamera.autoAnimate) {
      scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1);
    }
    if (parsedCamera.isEnabled !== void 0) {
      camera.setEnabled(parsedCamera.isEnabled);
    }
    return camera;
  }
  /** @internal */
  _calculateHandednessMultiplier() {
    let handednessMultiplier = this.getScene().useRightHandedSystem ? -1 : 1;
    if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {
      handednessMultiplier *= -1;
    }
    return handednessMultiplier;
  }
};
Camera._CreateDefaultParsedCamera = (name, scene) => {
  throw _WarnImport("UniversalCamera");
};
Camera.PERSPECTIVE_CAMERA = 0;
Camera.ORTHOGRAPHIC_CAMERA = 1;
Camera.FOVMODE_VERTICAL_FIXED = 0;
Camera.FOVMODE_HORIZONTAL_FIXED = 1;
Camera.RIG_MODE_NONE = 0;
Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
Camera.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
Camera.RIG_MODE_VR = 20;
Camera.RIG_MODE_CUSTOM = 22;
Camera.ForceAttachControlToAlwaysPreventDefault = false;
__decorate([
  serializeAsVector3("position")
], Camera.prototype, "_position", void 0);
__decorate([
  serializeAsVector3("upVector")
], Camera.prototype, "_upVector", void 0);
__decorate([
  serialize()
], Camera.prototype, "orthoLeft", null);
__decorate([
  serialize()
], Camera.prototype, "orthoRight", null);
__decorate([
  serialize()
], Camera.prototype, "orthoBottom", null);
__decorate([
  serialize()
], Camera.prototype, "orthoTop", null);
__decorate([
  serialize()
], Camera.prototype, "fov", void 0);
__decorate([
  serialize()
], Camera.prototype, "projectionPlaneTilt", void 0);
__decorate([
  serialize()
], Camera.prototype, "minZ", void 0);
__decorate([
  serialize()
], Camera.prototype, "maxZ", void 0);
__decorate([
  serialize()
], Camera.prototype, "inertia", void 0);
__decorate([
  serialize()
], Camera.prototype, "mode", null);
__decorate([
  serialize()
], Camera.prototype, "layerMask", void 0);
__decorate([
  serialize()
], Camera.prototype, "fovMode", void 0);
__decorate([
  serialize()
], Camera.prototype, "cameraRigMode", void 0);
__decorate([
  serialize()
], Camera.prototype, "interaxialDistance", void 0);
__decorate([
  serialize()
], Camera.prototype, "isStereoscopicSideBySide", void 0);

export {
  SceneComponentConstants,
  Stage,
  Camera
};
//# sourceMappingURL=chunk-H2VNCWVE.js.map
