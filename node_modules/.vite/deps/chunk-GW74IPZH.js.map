{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/webRequest.fetch.ts", "../../../dev/core/src/Loading/sceneLoader.ts"],
  "sourcesContent": ["import { WebRequest } from \"./webRequest\";\r\n\r\n/**\r\n * Fetches a resource from the network\r\n * @param url defines the url to fetch the resource from\r\n * @param options defines the options to use when fetching the resource\r\n * @returns a promise that resolves when the resource is fetched\r\n * @internal\r\n */\r\nexport async function _FetchAsync(\r\n    url: string,\r\n    options: Partial<{ method: string; responseHeaders?: string[] }>\r\n): Promise<{ response: Response; headerValues: { [key: string]: string } }> {\r\n    const method = options.method || \"GET\";\r\n    return await new Promise((resolve, reject) => {\r\n        const request = new WebRequest();\r\n        request.addEventListener(\"readystatechange\", () => {\r\n            if (request.readyState == 4) {\r\n                if (request.status == 200) {\r\n                    const headerValues: { [key: string]: string } = {};\r\n                    if (options.responseHeaders) {\r\n                        for (const header of options.responseHeaders) {\r\n                            headerValues[header] = request.getResponseHeader(header) || \"\";\r\n                        }\r\n                    }\r\n\r\n                    resolve({ response: request.response, headerValues: headerValues });\r\n                } else {\r\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                    reject(`Unable to fetch data from ${url}. Error code: ${request.status}`);\r\n                }\r\n            }\r\n        });\r\n\r\n        request.open(method, url);\r\n        request.send();\r\n    });\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { DeepImmutable, Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { AnimationGroup } from \"../Animations/animationGroup\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags\";\r\nimport type { IFileRequest } from \"../Misc/fileRequest\";\r\nimport type { WebRequest } from \"../Misc/webRequest\";\r\nimport type { LoadFileError } from \"../Misc/fileTools\";\r\nimport { IsBase64DataUrl } from \"../Misc/fileTools\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Geometry } from \"../Meshes/geometry\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport { RandomGUID } from \"../Misc/guid\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { _FetchAsync } from \"core/Misc/webRequest.fetch\";\r\n\r\n/**\r\n * Type used for the success callback of ImportMesh\r\n */\r\nexport type SceneLoaderSuccessCallback = (\r\n    meshes: AbstractMesh[],\r\n    particleSystems: IParticleSystem[],\r\n    skeletons: Skeleton[],\r\n    animationGroups: AnimationGroup[],\r\n    transformNodes: TransformNode[],\r\n    geometries: Geometry[],\r\n    lights: Light[],\r\n    spriteManagers: ISpriteManager[]\r\n) => void;\r\n\r\n/**\r\n * Interface used for the result of ImportMeshAsync\r\n */\r\nexport interface ISceneLoaderAsyncResult {\r\n    /**\r\n     * The array of loaded meshes\r\n     */\r\n    readonly meshes: AbstractMesh[];\r\n\r\n    /**\r\n     * The array of loaded particle systems\r\n     */\r\n    readonly particleSystems: IParticleSystem[];\r\n\r\n    /**\r\n     * The array of loaded skeletons\r\n     */\r\n    readonly skeletons: Skeleton[];\r\n\r\n    /**\r\n     * The array of loaded animation groups\r\n     */\r\n    readonly animationGroups: AnimationGroup[];\r\n\r\n    /**\r\n     * The array of loaded transform nodes\r\n     */\r\n    readonly transformNodes: TransformNode[];\r\n\r\n    /**\r\n     * The array of loaded geometries\r\n     */\r\n    readonly geometries: Geometry[];\r\n\r\n    /**\r\n     * The array of loaded lights\r\n     */\r\n    readonly lights: Light[];\r\n\r\n    /**\r\n     * The array of loaded sprite managers\r\n     */\r\n    readonly spriteManagers: ISpriteManager[];\r\n}\r\n\r\n/**\r\n * Interface used to represent data loading progression\r\n */\r\nexport interface ISceneLoaderProgressEvent {\r\n    /**\r\n     * Defines if data length to load can be evaluated\r\n     */\r\n    readonly lengthComputable: boolean;\r\n\r\n    /**\r\n     * Defines the loaded data length\r\n     */\r\n    readonly loaded: number;\r\n\r\n    /**\r\n     * Defines the data length to load\r\n     */\r\n    readonly total: number;\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugins to define supported file extensions\r\n */\r\nexport interface ISceneLoaderPluginExtensions {\r\n    /**\r\n     * Defines the list of supported extensions\r\n     */\r\n    readonly [extension: string]: {\r\n        readonly isBinary: boolean;\r\n        readonly mimeType?: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Metadata for a SceneLoader plugin that must also be provided by a plugin factory\r\n */\r\nexport interface ISceneLoaderPluginMetadata {\r\n    /**\r\n     * The friendly name of the plugin.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * The file extensions supported by the plugin.\r\n     */\r\n    readonly extensions: string | ISceneLoaderPluginExtensions;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     * @param data string containing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    canDirectLoad?(data: string): boolean;\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugin factory\r\n */\r\nexport interface ISceneLoaderPluginFactory extends ISceneLoaderPluginMetadata {\r\n    /**\r\n     * Function called to create a new plugin\r\n     * @param options plugin options that were passed to the SceneLoader operation\r\n     * @returns the new plugin\r\n     */\r\n    createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPlugin | ISceneLoaderPluginAsync | Promise<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;\r\n}\r\n\r\n/**\r\n * Interface used to define the base of ISceneLoaderPlugin and ISceneLoaderPluginAsync\r\n */\r\nexport interface ISceneLoaderPluginBase extends ISceneLoaderPluginMetadata {\r\n    /**\r\n     * The callback called when loading from a url.\r\n     * @param scene scene loading this url\r\n     * @param fileOrUrl file or url to load\r\n     * @param rootUrl root url to use to load assets\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @param name defines the name of the file when loading a binary file\r\n     * @returns a file request object\r\n     */\r\n    loadFile?(\r\n        scene: Scene,\r\n        fileOrUrl: File | string | ArrayBufferView,\r\n        rootUrl: string,\r\n        onSuccess: (data: unknown, responseURL?: string) => void,\r\n        onProgress?: (ev: ISceneLoaderProgressEvent) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        name?: string\r\n    ): Nullable<IFileRequest>;\r\n\r\n    /**\r\n     * The callback that returns the data to pass to the plugin if the data can be directly loaded.\r\n     * @param scene scene loading this data\r\n     * @param data string containing the data\r\n     * @returns data to pass to the plugin\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\r\n    directLoad?(scene: Scene, data: string): unknown | Promise<unknown>;\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n}\r\n\r\n/**\r\n * Interface used to define a SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPlugin extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param meshes The meshes array to import into\r\n     * @param particleSystems The particle systems array to import into\r\n     * @param skeletons The skeletons array to import into\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    importMesh(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        data: unknown,\r\n        rootUrl: string,\r\n        meshes: AbstractMesh[],\r\n        particleSystems: IParticleSystem[],\r\n        skeletons: Skeleton[],\r\n        onError?: (message: string, exception?: any) => void\r\n    ): boolean;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    load(scene: Scene, data: unknown, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainer(scene: Scene, data: unknown, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer;\r\n}\r\n\r\n/**\r\n * Interface used to define an async SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPluginAsync extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded objects (e.g. meshes, particle systems, skeletons, animation groups, etc.)\r\n     */\r\n    importMeshAsync(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        data: unknown,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult>;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns Nothing\r\n     */\r\n    loadAsync(scene: Scene, data: unknown, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void>;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainerAsync(scene: Scene, data: unknown, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer>;\r\n}\r\n\r\n/**\r\n * Mode that determines how to handle old animation groups before loading new ones.\r\n */\r\nexport const enum SceneLoaderAnimationGroupLoadingMode {\r\n    /**\r\n     * Reset all old animations to initial state then dispose them.\r\n     */\r\n    Clean = 0,\r\n\r\n    /**\r\n     * Stop all old animations.\r\n     */\r\n    Stop = 1,\r\n\r\n    /**\r\n     * Restart old animations from first frame.\r\n     */\r\n    Sync = 2,\r\n\r\n    /**\r\n     * Old animations remains untouched.\r\n     */\r\n    NoSync = 3,\r\n}\r\n\r\n/**\r\n * Defines internal only plugin members.\r\n */\r\ninterface ISceneLoaderPluginInternal {\r\n    /**\r\n     * An optional observable to notify when the plugin is disposed\r\n     */\r\n    readonly onDisposeObservable: Observable<void>;\r\n}\r\n\r\n/**\r\n * Defines a plugin registered by the SceneLoader\r\n */\r\ninterface IRegisteredPlugin {\r\n    /**\r\n     * Defines the plugin to use\r\n     */\r\n    plugin: ((ISceneLoaderPlugin | ISceneLoaderPluginAsync) & Partial<ISceneLoaderPluginInternal>) | ISceneLoaderPluginFactory;\r\n    /**\r\n     * Defines if the plugin supports binary data\r\n     */\r\n    isBinary: boolean;\r\n    mimeType?: string;\r\n}\r\n\r\nfunction IsFactory(pluginOrFactory: IRegisteredPlugin[\"plugin\"]): pluginOrFactory is ISceneLoaderPluginFactory {\r\n    return !!(pluginOrFactory as ISceneLoaderPluginFactory).createPlugin;\r\n}\r\n\r\n/**\r\n * Defines file information\r\n */\r\ninterface IFileInfo {\r\n    /**\r\n     * Gets the file url\r\n     */\r\n    url: string;\r\n    /**\r\n     * Gets the root url\r\n     */\r\n    rootUrl: string;\r\n    /**\r\n     * Gets filename\r\n     */\r\n    name: string;\r\n    /**\r\n     * Gets the file\r\n     */\r\n    file: Nullable<File>;\r\n\r\n    /**\r\n     * Gets raw binary data.\r\n     */\r\n    rawData: Nullable<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * Defines options for SceneLoader plugins. This interface is extended by specific plugins.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/naming-convention\r\nexport interface SceneLoaderPluginOptions extends Record<string, Record<string, unknown> | undefined> {}\r\n\r\n/**\r\n * Adds default/implicit options to plugin specific options.\r\n */\r\ntype DefaultPluginOptions<BasePluginOptions> = {\r\n    /**\r\n     * Defines if the plugin is enabled\r\n     */\r\n    enabled?: boolean;\r\n} & BasePluginOptions;\r\n\r\n// This captures the type defined inline for the pluginOptions property, which is just SceneLoaderPluginOptions wrapped with DefaultPluginOptions.\r\n// We do it this way rather than explicitly defining the type here and then using it in SceneLoaderOptions because we want the full expanded type\r\n// to show up in the user's intellisense to make it easier to understand what options are available.\r\nexport type PluginOptions = ISceneLoaderOptions[\"pluginOptions\"];\r\n\r\ntype SceneSource = string | File | ArrayBufferView;\r\n\r\n/**\r\n * Defines common options for loading operations performed by SceneLoader.\r\n */\r\ninterface ISceneLoaderOptions {\r\n    /**\r\n     * A string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     */\r\n    rootUrl?: string;\r\n\r\n    /**\r\n     * A callback with a progress event for each file being loaded\r\n     */\r\n    onProgress?: (event: ISceneLoaderProgressEvent) => void;\r\n\r\n    /**\r\n     * The extension used to determine the plugin\r\n     */\r\n    pluginExtension?: string;\r\n\r\n    /**\r\n     * Defines the filename, if the data is binary\r\n     */\r\n    name?: string;\r\n\r\n    /**\r\n     * Defines options for the registered plugins\r\n     */\r\n    pluginOptions?: {\r\n        // NOTE: This type is doing two things:\r\n        // 1. Adding an implicit 'enabled' property to the options for each plugin.\r\n        // 2. Creating a mapped type of all the options of all the plugins to make it just look like a consolidated plain object in intellisense for the user.\r\n        [Plugin in keyof SceneLoaderPluginOptions]?: {\r\n            [Option in keyof DefaultPluginOptions<SceneLoaderPluginOptions[Plugin]>]: DefaultPluginOptions<SceneLoaderPluginOptions[Plugin]>[Option];\r\n        };\r\n    };\r\n}\r\n\r\n/**\r\n * Defines options for ImportMeshAsync.\r\n */\r\nexport interface ImportMeshOptions extends ISceneLoaderOptions {\r\n    /**\r\n     * An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     */\r\n    meshNames?: string | readonly string[] | null | undefined;\r\n}\r\n\r\n/**\r\n * Defines options for LoadAsync.\r\n */\r\nexport interface LoadOptions extends ISceneLoaderOptions {}\r\n\r\n/**\r\n * Defines options for AppendAsync.\r\n */\r\nexport interface AppendOptions extends ISceneLoaderOptions {}\r\n\r\n/**\r\n * Defines options for LoadAssetContainerAsync.\r\n */\r\nexport interface LoadAssetContainerOptions extends ISceneLoaderOptions {}\r\n\r\n/**\r\n * Defines options for ImportAnimationsAsync.\r\n */\r\nexport interface ImportAnimationsOptions extends ISceneLoaderOptions {\r\n    /**\r\n     * When true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     */\r\n    overwriteAnimations?: boolean;\r\n\r\n    /**\r\n     * Defines how to handle old animations groups before importing new ones\r\n     */\r\n    animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode;\r\n\r\n    /**\r\n     * defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     */\r\n    targetConverter?: Nullable<(target: unknown) => unknown>;\r\n}\r\n\r\nfunction isFile(value: unknown): value is File {\r\n    return !!(value as File).name;\r\n}\r\n\r\nconst onPluginActivatedObservable = new Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>();\r\nconst registeredPlugins: { [extension: string]: IRegisteredPlugin } = {};\r\nlet showingLoadingScreen = false;\r\n\r\nfunction getDefaultPlugin(): IRegisteredPlugin | undefined {\r\n    return registeredPlugins[\".babylon\"];\r\n}\r\n\r\nfunction getPluginForMimeType(mimeType: string): IRegisteredPlugin | undefined {\r\n    for (const registeredPluginKey in registeredPlugins) {\r\n        const registeredPlugin = registeredPlugins[registeredPluginKey];\r\n        if (registeredPlugin.mimeType === mimeType) {\r\n            return registeredPlugin;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getPluginForExtension(extension: string, returnDefault: boolean): IRegisteredPlugin | undefined {\r\n    const registeredPlugin = registeredPlugins[extension];\r\n    if (registeredPlugin) {\r\n        return registeredPlugin;\r\n    }\r\n    Logger.Warn(\r\n        \"Unable to find a plugin to load \" +\r\n            extension +\r\n            \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\"\r\n    );\r\n    return returnDefault ? getDefaultPlugin() : undefined;\r\n}\r\n\r\nfunction isPluginForExtensionAvailable(extension: string): boolean {\r\n    return !!registeredPlugins[extension];\r\n}\r\n\r\nfunction getPluginForDirectLoad(data: string): IRegisteredPlugin | undefined {\r\n    for (const extension in registeredPlugins) {\r\n        const plugin = registeredPlugins[extension].plugin;\r\n\r\n        if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\r\n            return registeredPlugins[extension];\r\n        }\r\n    }\r\n\r\n    return getDefaultPlugin();\r\n}\r\n\r\nfunction getFilenameExtension(sceneFilename: string): string {\r\n    const queryStringPosition = sceneFilename.indexOf(\"?\");\r\n\r\n    if (queryStringPosition !== -1) {\r\n        sceneFilename = sceneFilename.substring(0, queryStringPosition);\r\n    }\r\n\r\n    const dotPosition = sceneFilename.lastIndexOf(\".\");\r\n\r\n    return sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\r\n}\r\n\r\nfunction getDirectLoad(sceneFilename: string): Nullable<string> {\r\n    if (sceneFilename.substring(0, 5) === \"data:\") {\r\n        return sceneFilename.substring(5);\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction formatErrorMessage(fileInfo: IFileInfo, message?: string, exception?: any): string {\r\n    const fromLoad = fileInfo.rawData ? \"binary data\" : fileInfo.url;\r\n    let errorMessage = \"Unable to load from \" + fromLoad;\r\n\r\n    if (message) {\r\n        errorMessage += `: ${message}`;\r\n    } else if (exception) {\r\n        errorMessage += `: ${exception}`;\r\n    }\r\n\r\n    return errorMessage;\r\n}\r\n\r\nasync function loadDataAsync(\r\n    fileInfo: IFileInfo,\r\n    scene: Scene,\r\n    onSuccess: (plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync, data: unknown, responseURL?: string) => void,\r\n    onProgress: ((event: ISceneLoaderProgressEvent) => void) | undefined,\r\n    onError: (message?: string, exception?: any) => void,\r\n    onDispose: () => void,\r\n    pluginExtension: Nullable<string>,\r\n    name: string,\r\n    pluginOptions: PluginOptions\r\n): Promise<Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>> {\r\n    const directLoad = getDirectLoad(fileInfo.url);\r\n\r\n    if (fileInfo.rawData && !pluginExtension) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"When using ArrayBufferView to load data the file extension must be provided.\";\r\n    }\r\n\r\n    const fileExtension = !directLoad && !pluginExtension ? getFilenameExtension(fileInfo.url) : \"\";\r\n\r\n    let registeredPlugin = pluginExtension\r\n        ? getPluginForExtension(pluginExtension, true)\r\n        : directLoad\r\n          ? getPluginForDirectLoad(fileInfo.url)\r\n          : getPluginForExtension(fileExtension, false);\r\n\r\n    if (!registeredPlugin && fileExtension) {\r\n        if (fileInfo.url && !fileInfo.url.startsWith(\"blob:\")) {\r\n            // Fetching head content to get the mime type\r\n            const response = await _FetchAsync(fileInfo.url, { method: \"HEAD\", responseHeaders: [\"Content-Type\"] });\r\n            const mimeType = response.headerValues ? response.headerValues[\"Content-Type\"] : \"\";\r\n            if (mimeType) {\r\n                // eslint-disable-next-line require-atomic-updates\r\n                registeredPlugin = getPluginForMimeType(mimeType);\r\n            }\r\n        }\r\n\r\n        if (!registeredPlugin) {\r\n            registeredPlugin = getDefaultPlugin();\r\n        }\r\n    }\r\n\r\n    if (!registeredPlugin) {\r\n        throw new Error(`No plugin or fallback for ${pluginExtension ?? fileInfo.url}`);\r\n    }\r\n\r\n    if (pluginOptions?.[registeredPlugin.plugin.name]?.enabled === false) {\r\n        throw new Error(`The '${registeredPlugin.plugin.name}' plugin is disabled via the loader options passed to the loading operation.`);\r\n    }\r\n\r\n    if (fileInfo.rawData && !registeredPlugin.isBinary) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"Loading from ArrayBufferView can not be used with plugins that don't support binary loading.\";\r\n    }\r\n\r\n    const getPluginInstance = (callback: (plugin: (ISceneLoaderPlugin | ISceneLoaderPluginAsync) & Partial<ISceneLoaderPluginInternal>) => void) => {\r\n        // For plugin factories, the plugin is instantiated on each SceneLoader operation. This makes options handling\r\n        // much simpler as we can just pass the options to the factory, rather than passing options through to every possible\r\n        // plugin call. Given this, options are only supported for plugins that provide a factory function.\r\n        if (IsFactory(registeredPlugin.plugin)) {\r\n            const pluginFactory = registeredPlugin.plugin;\r\n            const partialPlugin = pluginFactory.createPlugin(pluginOptions ?? {});\r\n            if (partialPlugin instanceof Promise) {\r\n                // eslint-disable-next-line github/no-then\r\n                partialPlugin.then(callback).catch((error) => {\r\n                    onError(\"Error instantiating plugin.\", error);\r\n                });\r\n                // When async factories are used, the plugin instance cannot be returned synchronously.\r\n                // In this case, the legacy loader functions will return null.\r\n                return null;\r\n            } else {\r\n                callback(partialPlugin);\r\n                return partialPlugin;\r\n            }\r\n        } else {\r\n            callback(registeredPlugin.plugin);\r\n            return registeredPlugin.plugin;\r\n        }\r\n    };\r\n\r\n    return getPluginInstance((plugin) => {\r\n        if (!plugin) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw `The loader plugin corresponding to the '${pluginExtension}' file type has not been found. If using es6, please import the plugin you wish to use before.`;\r\n        }\r\n\r\n        onPluginActivatedObservable.notifyObservers(plugin);\r\n\r\n        // Check if we have a direct load url. If the plugin is registered to handle\r\n        // it or it's not a base64 data url, then pass it through the direct load path.\r\n        if (directLoad && ((plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url)) || !IsBase64DataUrl(fileInfo.url))) {\r\n            if (plugin.directLoad) {\r\n                const result = plugin.directLoad(scene, directLoad);\r\n                if (result instanceof Promise) {\r\n                    result\r\n                        // eslint-disable-next-line github/no-then\r\n                        .then((data: unknown) => {\r\n                            onSuccess(plugin, data);\r\n                        })\r\n                        // eslint-disable-next-line github/no-then\r\n                        .catch((error: any) => {\r\n                            onError(\"Error in directLoad of _loadData: \" + error, error);\r\n                        });\r\n                } else {\r\n                    onSuccess(plugin, result);\r\n                }\r\n            } else {\r\n                onSuccess(plugin, directLoad);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const useArrayBuffer = registeredPlugin.isBinary;\r\n\r\n        const dataCallback = (data: unknown, responseURL?: string) => {\r\n            if (scene.isDisposed) {\r\n                onError(\"Scene has been disposed\");\r\n                return;\r\n            }\r\n\r\n            onSuccess(plugin, data, responseURL);\r\n        };\r\n\r\n        let request: Nullable<IFileRequest> = null;\r\n        let pluginDisposed = false;\r\n        plugin.onDisposeObservable?.add(() => {\r\n            pluginDisposed = true;\r\n\r\n            if (request) {\r\n                request.abort();\r\n                request = null;\r\n            }\r\n\r\n            onDispose();\r\n        });\r\n\r\n        const manifestChecked = () => {\r\n            if (pluginDisposed) {\r\n                return;\r\n            }\r\n\r\n            const errorCallback = (request?: WebRequest, exception?: LoadFileError) => {\r\n                onError(request?.statusText, exception);\r\n            };\r\n\r\n            if (!plugin.loadFile && fileInfo.rawData) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"Plugin does not support loading ArrayBufferView.\";\r\n            }\r\n\r\n            request = plugin.loadFile\r\n                ? plugin.loadFile(scene, fileInfo.rawData || fileInfo.file || fileInfo.url, fileInfo.rootUrl, dataCallback, onProgress, useArrayBuffer, errorCallback, name)\r\n                : scene._loadFile(fileInfo.file || fileInfo.url, dataCallback, onProgress, true, useArrayBuffer, errorCallback);\r\n        };\r\n\r\n        const engine = scene.getEngine();\r\n        let canUseOfflineSupport = engine.enableOfflineSupport;\r\n        if (canUseOfflineSupport) {\r\n            // Also check for exceptions\r\n            let exceptionFound = false;\r\n            for (const regex of scene.disableOfflineSupportExceptionRules) {\r\n                if (regex.test(fileInfo.url)) {\r\n                    exceptionFound = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            canUseOfflineSupport = !exceptionFound;\r\n        }\r\n\r\n        if (canUseOfflineSupport && AbstractEngine.OfflineProviderFactory) {\r\n            // Checking if a manifest file has been set for this scene and if offline mode has been requested\r\n            scene.offlineProvider = AbstractEngine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\r\n        } else {\r\n            manifestChecked();\r\n        }\r\n    });\r\n}\r\n\r\nfunction GetFileInfo(rootUrl: string, sceneSource: SceneSource): Nullable<IFileInfo> {\r\n    let url: string;\r\n    let name: string;\r\n    let file: Nullable<File> = null;\r\n    let rawData: Nullable<ArrayBufferView> = null;\r\n\r\n    if (!sceneSource) {\r\n        url = rootUrl;\r\n        name = Tools.GetFilename(rootUrl);\r\n        rootUrl = Tools.GetFolderPath(rootUrl);\r\n    } else if (isFile(sceneSource)) {\r\n        url = `file:${sceneSource.name}`;\r\n        name = sceneSource.name;\r\n        file = sceneSource;\r\n    } else if (ArrayBuffer.isView(sceneSource)) {\r\n        url = \"\";\r\n        name = RandomGUID();\r\n        rawData = sceneSource;\r\n    } else if (sceneSource.startsWith(\"data:\")) {\r\n        url = sceneSource;\r\n        name = \"\";\r\n    } else if (rootUrl) {\r\n        const filename = sceneSource;\r\n        if (filename.substring(0, 1) === \"/\") {\r\n            Tools.Error(\"Wrong sceneFilename parameter\");\r\n            return null;\r\n        }\r\n\r\n        url = rootUrl + filename;\r\n        name = filename;\r\n    } else {\r\n        url = sceneSource;\r\n        name = Tools.GetFilename(sceneSource);\r\n        rootUrl = Tools.GetFolderPath(sceneSource);\r\n    }\r\n\r\n    return {\r\n        url: url,\r\n        rootUrl: rootUrl,\r\n        name: name,\r\n        file: file,\r\n        rawData,\r\n    };\r\n}\r\n\r\n/**\r\n * Adds a new plugin to the list of registered plugins\r\n * @param plugin defines the plugin to add\r\n */\r\nexport function RegisterSceneLoaderPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory): void {\r\n    if (typeof plugin.extensions === \"string\") {\r\n        const extension = plugin.extensions;\r\n        registeredPlugins[extension.toLowerCase()] = {\r\n            plugin: plugin,\r\n            isBinary: false,\r\n        };\r\n    } else {\r\n        const extensions = plugin.extensions;\r\n        const keys = Object.keys(extensions);\r\n        for (const extension of keys) {\r\n            registeredPlugins[extension.toLowerCase()] = {\r\n                plugin: plugin,\r\n                isBinary: extensions[extension].isBinary,\r\n                mimeType: extensions[extension].mimeType,\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Adds a new plugin to the list of registered plugins\r\n * @deprecated Please use {@link RegisterSceneLoaderPlugin} instead.\r\n * @param plugin defines the plugin to add\r\n */\r\nexport function registerSceneLoaderPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory): void {\r\n    RegisterSceneLoaderPlugin(plugin);\r\n}\r\n\r\n/**\r\n * Gets metadata for all currently registered scene loader plugins.\r\n * @returns An array where each entry has metadata for a single scene loader plugin.\r\n */\r\nexport function GetRegisteredSceneLoaderPluginMetadata(): DeepImmutable<\r\n    Array<\r\n        Pick<ISceneLoaderPluginMetadata, \"name\"> & {\r\n            /**\r\n             * The extensions supported by the plugin.\r\n             */\r\n            extensions: ({\r\n                /**\r\n                 * The file extension.\r\n                 */\r\n                extension: string;\r\n            } & ISceneLoaderPluginExtensions[string])[];\r\n        }\r\n    >\r\n> {\r\n    return Array.from(\r\n        Object.entries(registeredPlugins).reduce((pluginMap, [extension, extensionRegistration]) => {\r\n            let pluginMetadata = pluginMap.get(extensionRegistration.plugin.name);\r\n            if (!pluginMetadata) {\r\n                pluginMap.set(extensionRegistration.plugin.name, (pluginMetadata = []));\r\n            }\r\n            pluginMetadata.push({ extension, isBinary: extensionRegistration.isBinary, mimeType: extensionRegistration.mimeType });\r\n            return pluginMap;\r\n        }, new Map<string, ({ extension: string } & ISceneLoaderPluginExtensions[string])[]>())\r\n    ).map(([name, extensions]) => ({ name, extensions }));\r\n}\r\n\r\n/**\r\n * Import meshes into a scene\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene the instance of BABYLON.Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n */\r\nexport async function ImportMeshAsync(source: SceneSource, scene: Scene, options?: ImportMeshOptions): Promise<ISceneLoaderAsyncResult> {\r\n    const { meshNames, rootUrl = \"\", onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    return await importMeshAsyncCoreAsync(meshNames, rootUrl, source, scene, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\nasync function importMeshAsync(\r\n    meshNames: string | readonly string[] | null | undefined,\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n    onSuccess: Nullable<SceneLoaderSuccessCallback> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>> {\r\n    if (!scene) {\r\n        Logger.Error(\"No scene available to import mesh to\");\r\n        return null;\r\n    }\r\n\r\n    const fileInfo = GetFileInfo(rootUrl, sceneFilename);\r\n    if (!fileInfo) {\r\n        return null;\r\n    }\r\n\r\n    const loadingToken = {};\r\n    scene.addPendingData(loadingToken);\r\n\r\n    const disposeHandler = () => {\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    const errorHandler = (message?: string, exception?: any) => {\r\n        const errorMessage = formatErrorMessage(fileInfo, message, exception);\r\n\r\n        if (onError) {\r\n            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n        } else {\r\n            Logger.Error(errorMessage);\r\n            // should the exception be thrown?\r\n        }\r\n\r\n        disposeHandler();\r\n    };\r\n\r\n    const progressHandler = onProgress\r\n        ? (event: ISceneLoaderProgressEvent) => {\r\n              try {\r\n                  onProgress(event);\r\n              } catch (e) {\r\n                  errorHandler(\"Error in onProgress callback: \" + e, e);\r\n              }\r\n          }\r\n        : undefined;\r\n\r\n    const successHandler: SceneLoaderSuccessCallback = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {\r\n        scene.importedMeshesFiles.push(fileInfo.url);\r\n\r\n        if (onSuccess) {\r\n            try {\r\n                onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers);\r\n            } catch (e) {\r\n                errorHandler(\"Error in onSuccess callback: \" + e, e);\r\n            }\r\n        }\r\n\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    return await loadDataAsync(\r\n        fileInfo,\r\n        scene,\r\n        (plugin, data, responseURL) => {\r\n            if (plugin.rewriteRootURL) {\r\n                fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\r\n            }\r\n\r\n            if ((plugin as ISceneLoaderPlugin).importMesh) {\r\n                const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                const meshes: AbstractMesh[] = [];\r\n                const particleSystems: IParticleSystem[] = [];\r\n                const skeletons: Skeleton[] = [];\r\n\r\n                if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\r\n                    return;\r\n                }\r\n\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler(meshes, particleSystems, skeletons, [], [], [], [], []);\r\n            } else {\r\n                const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin\r\n                    .importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                    // eslint-disable-next-line github/no-then\r\n                    .then((result) => {\r\n                        scene.loadingPluginName = plugin.name;\r\n                        successHandler(\r\n                            result.meshes,\r\n                            result.particleSystems,\r\n                            result.skeletons,\r\n                            result.animationGroups,\r\n                            result.transformNodes,\r\n                            result.geometries,\r\n                            result.lights,\r\n                            result.spriteManagers\r\n                        );\r\n                    })\r\n                    // eslint-disable-next-line github/no-then\r\n                    .catch((error) => {\r\n                        errorHandler(error.message, error);\r\n                    });\r\n            }\r\n        },\r\n        progressHandler,\r\n        errorHandler,\r\n        disposeHandler,\r\n        pluginExtension,\r\n        name,\r\n        pluginOptions\r\n    );\r\n}\r\n\r\nasync function importMeshAsyncCoreAsync(\r\n    meshNames: string | readonly string[] | null | undefined,\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    scene?: Nullable<Scene>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<ISceneLoaderAsyncResult> {\r\n    return await new Promise((resolve, reject) => {\r\n        try {\r\n            importMeshAsync(\r\n                meshNames,\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {\r\n                    resolve({\r\n                        meshes: meshes,\r\n                        particleSystems: particleSystems,\r\n                        skeletons: skeletons,\r\n                        animationGroups: animationGroups,\r\n                        transformNodes: transformNodes,\r\n                        geometries: geometries,\r\n                        lights: lights,\r\n                        spriteManagers: spriteManagers,\r\n                    });\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension,\r\n                name,\r\n                pluginOptions\r\n                // eslint-disable-next-line github/no-then\r\n            ).catch(reject);\r\n        } catch (error) {\r\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\n// This is the core implementation of load scene\r\nasync function loadSceneImplAsync(\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    engine: Nullable<AbstractEngine> = EngineStore.LastCreatedEngine,\r\n    onSuccess: Nullable<(scene: Scene) => void> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<void> {\r\n    if (!engine) {\r\n        Tools.Error(\"No engine available\");\r\n        return;\r\n    }\r\n\r\n    await appendSceneImplAsync(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Load a scene\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns The loaded scene\r\n */\r\nexport async function LoadSceneAsync(source: SceneSource, engine: AbstractEngine, options?: LoadOptions): Promise<Scene> {\r\n    const { rootUrl = \"\", onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    return await loadSceneSharedAsync(rootUrl, source, engine, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Load a scene\r\n * @deprecated Please use {@link LoadSceneAsync} instead.\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns The loaded scene\r\n */\r\nexport async function loadSceneAsync(source: SceneSource, engine: AbstractEngine, options?: LoadOptions): Promise<Scene> {\r\n    return await LoadSceneAsync(source, engine, options);\r\n}\r\n\r\n// This function is shared between the new module level loadSceneAsync and the legacy SceneLoader.LoadAsync\r\nasync function loadSceneSharedAsync(\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    engine?: Nullable<AbstractEngine>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<Scene> {\r\n    return await new Promise((resolve, reject) => {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        loadSceneImplAsync(\r\n            rootUrl,\r\n            sceneFilename,\r\n            engine,\r\n            (scene) => {\r\n                resolve(scene);\r\n            },\r\n            onProgress,\r\n            (scene, message, exception) => {\r\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                reject(exception || new Error(message));\r\n            },\r\n            pluginExtension,\r\n            name,\r\n            pluginOptions\r\n        );\r\n    });\r\n}\r\n\r\n// This is the core implementation of append scene\r\nasync function appendSceneImplAsync(\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n    onSuccess: Nullable<(scene: Scene) => void> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>> {\r\n    if (!scene) {\r\n        Logger.Error(\"No scene available to append to\");\r\n        return null;\r\n    }\r\n\r\n    const fileInfo = GetFileInfo(rootUrl, sceneFilename);\r\n    if (!fileInfo) {\r\n        return null;\r\n    }\r\n\r\n    const loadingToken = {};\r\n    scene.addPendingData(loadingToken);\r\n\r\n    const disposeHandler = () => {\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    if (SceneLoaderFlags.ShowLoadingScreen && !showingLoadingScreen) {\r\n        showingLoadingScreen = true;\r\n        scene.getEngine().displayLoadingUI();\r\n        scene.executeWhenReady(() => {\r\n            scene.getEngine().hideLoadingUI();\r\n            showingLoadingScreen = false;\r\n        });\r\n    }\r\n\r\n    const errorHandler = (message?: string, exception?: any) => {\r\n        const errorMessage = formatErrorMessage(fileInfo, message, exception);\r\n\r\n        if (onError) {\r\n            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n        } else {\r\n            Logger.Error(errorMessage);\r\n            // should the exception be thrown?\r\n        }\r\n\r\n        disposeHandler();\r\n    };\r\n\r\n    const progressHandler = onProgress\r\n        ? (event: ISceneLoaderProgressEvent) => {\r\n              try {\r\n                  onProgress(event);\r\n              } catch (e) {\r\n                  errorHandler(\"Error in onProgress callback\", e);\r\n              }\r\n          }\r\n        : undefined;\r\n\r\n    const successHandler = () => {\r\n        if (onSuccess) {\r\n            try {\r\n                onSuccess(scene);\r\n            } catch (e) {\r\n                errorHandler(\"Error in onSuccess callback\", e);\r\n            }\r\n        }\r\n\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    return await loadDataAsync(\r\n        fileInfo,\r\n        scene,\r\n        (plugin, data) => {\r\n            if ((plugin as ISceneLoaderPlugin).load) {\r\n                const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\r\n                    return;\r\n                }\r\n\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler();\r\n            } else {\r\n                const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin\r\n                    .loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                    // eslint-disable-next-line github/no-then\r\n                    .then(() => {\r\n                        scene.loadingPluginName = plugin.name;\r\n                        successHandler();\r\n                    })\r\n                    // eslint-disable-next-line github/no-then\r\n                    .catch((error) => {\r\n                        errorHandler(error.message, error);\r\n                    });\r\n            }\r\n        },\r\n        progressHandler,\r\n        errorHandler,\r\n        disposeHandler,\r\n        pluginExtension,\r\n        name,\r\n        pluginOptions\r\n    );\r\n}\r\n\r\n/**\r\n * Append a scene\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of BABYLON.Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns A promise that resolves when the scene is appended\r\n */\r\nexport async function AppendSceneAsync(source: SceneSource, scene: Scene, options?: AppendOptions): Promise<void> {\r\n    const { rootUrl = \"\", onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    await appendSceneSharedAsync(rootUrl, source, scene, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Append a scene\r\n * @deprecated Please use {@link AppendSceneAsync} instead.\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of BABYLON.Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns A promise that resolves when the scene is appended\r\n */\r\nexport async function appendSceneAsync(source: SceneSource, scene: Scene, options?: AppendOptions): Promise<void> {\r\n    return await AppendSceneAsync(source, scene, options);\r\n}\r\n\r\n// This function is shared between the new module level appendSceneAsync and the legacy SceneLoader.AppendAsync\r\nasync function appendSceneSharedAsync(\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    scene?: Nullable<Scene>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<Scene> {\r\n    return await new Promise((resolve, reject) => {\r\n        try {\r\n            appendSceneImplAsync(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (scene) => {\r\n                    resolve(scene);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension,\r\n                name,\r\n                pluginOptions\r\n                // eslint-disable-next-line github/no-then\r\n            ).catch(reject);\r\n        } catch (error) {\r\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\n// This is the core implementation of load asset container\r\nasync function loadAssetContainerImplAsync(\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n    onSuccess: Nullable<(assets: AssetContainer) => void> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>> {\r\n    if (!scene) {\r\n        Logger.Error(\"No scene available to load asset container to\");\r\n        return null;\r\n    }\r\n\r\n    const fileInfo = GetFileInfo(rootUrl, sceneFilename);\r\n    if (!fileInfo) {\r\n        return null;\r\n    }\r\n\r\n    const loadingToken = {};\r\n    scene.addPendingData(loadingToken);\r\n\r\n    const disposeHandler = () => {\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    const errorHandler = (message?: string, exception?: any) => {\r\n        const errorMessage = formatErrorMessage(fileInfo, message, exception);\r\n\r\n        if (onError) {\r\n            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n        } else {\r\n            Logger.Error(errorMessage);\r\n            // should the exception be thrown?\r\n        }\r\n\r\n        disposeHandler();\r\n    };\r\n\r\n    const progressHandler = onProgress\r\n        ? (event: ISceneLoaderProgressEvent) => {\r\n              try {\r\n                  onProgress(event);\r\n              } catch (e) {\r\n                  errorHandler(\"Error in onProgress callback\", e);\r\n              }\r\n          }\r\n        : undefined;\r\n\r\n    const successHandler = (assets: AssetContainer) => {\r\n        if (onSuccess) {\r\n            try {\r\n                onSuccess(assets);\r\n            } catch (e) {\r\n                errorHandler(\"Error in onSuccess callback\", e);\r\n            }\r\n        }\r\n\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    return await loadDataAsync(\r\n        fileInfo,\r\n        scene,\r\n        (plugin, data) => {\r\n            if ((plugin as ISceneLoaderPlugin).loadAssetContainer) {\r\n                const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\r\n                if (!assetContainer) {\r\n                    return;\r\n                }\r\n                assetContainer.populateRootNodes();\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler(assetContainer);\r\n            } else if ((plugin as ISceneLoaderPluginAsync).loadAssetContainerAsync) {\r\n                const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin\r\n                    .loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                    // eslint-disable-next-line github/no-then\r\n                    .then((assetContainer) => {\r\n                        assetContainer.populateRootNodes();\r\n                        scene.loadingPluginName = plugin.name;\r\n                        successHandler(assetContainer);\r\n                    })\r\n                    // eslint-disable-next-line github/no-then\r\n                    .catch((error) => {\r\n                        errorHandler(error.message, error);\r\n                    });\r\n            } else {\r\n                errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\r\n            }\r\n        },\r\n        progressHandler,\r\n        errorHandler,\r\n        disposeHandler,\r\n        pluginExtension,\r\n        name,\r\n        pluginOptions\r\n    );\r\n}\r\n\r\n/**\r\n * Load a scene into an asset container\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns The loaded asset container\r\n */\r\nexport async function LoadAssetContainerAsync(source: SceneSource, scene: Scene, options?: LoadAssetContainerOptions): Promise<AssetContainer> {\r\n    const { rootUrl = \"\", onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    return await loadAssetContainerSharedAsync(rootUrl, source, scene, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Load a scene into an asset container\r\n * @deprecated Please use {@link LoadAssetContainerAsync} instead.\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns The loaded asset container\r\n */\r\nexport async function loadAssetContainerAsync(source: SceneSource, scene: Scene, options?: LoadAssetContainerOptions): Promise<AssetContainer> {\r\n    return await LoadAssetContainerAsync(source, scene, options);\r\n}\r\n\r\n// This function is shared between the new module level loadAssetContainerAsync and the legacy SceneLoader.LoadAssetContainerAsync\r\nasync function loadAssetContainerSharedAsync(\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    scene?: Nullable<Scene>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<AssetContainer> {\r\n    return await new Promise((resolve, reject) => {\r\n        try {\r\n            loadAssetContainerImplAsync(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (assets) => {\r\n                    resolve(assets);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension,\r\n                name,\r\n                pluginOptions\r\n                // eslint-disable-next-line github/no-then\r\n            ).catch(reject);\r\n        } catch (error) {\r\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\n// This is the core implementation of import animations\r\nasync function importAnimationsImplAsync(\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n    overwriteAnimations = true,\r\n    animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean,\r\n    targetConverter: Nullable<(target: any) => any> = null,\r\n    onSuccess: Nullable<(scene: Scene) => void> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<void> {\r\n    if (!scene) {\r\n        Logger.Error(\"No scene available to load animations to\");\r\n        return;\r\n    }\r\n\r\n    if (overwriteAnimations) {\r\n        // Reset, stop and dispose all animations before loading new ones\r\n        for (const animatable of scene.animatables) {\r\n            animatable.reset();\r\n        }\r\n        scene.stopAllAnimations();\r\n        const animationGroups = scene.animationGroups.slice();\r\n        for (const animationGroup of animationGroups) {\r\n            animationGroup.dispose();\r\n        }\r\n        const nodes = scene.getNodes();\r\n        for (const node of nodes) {\r\n            if (node.animations) {\r\n                node.animations = [];\r\n            }\r\n        }\r\n    } else {\r\n        switch (animationGroupLoadingMode as number) {\r\n            case SceneLoaderAnimationGroupLoadingMode.Clean:\r\n                const animationGroups = scene.animationGroups.slice();\r\n                for (const animationGroup of animationGroups) {\r\n                    animationGroup.dispose();\r\n                }\r\n                break;\r\n            case SceneLoaderAnimationGroupLoadingMode.Stop:\r\n                for (const animationGroup of scene.animationGroups) {\r\n                    animationGroup.stop();\r\n                }\r\n                break;\r\n            case SceneLoaderAnimationGroupLoadingMode.Sync:\r\n                for (const animationGroup of scene.animationGroups) {\r\n                    animationGroup.reset();\r\n                    animationGroup.restart();\r\n                }\r\n                break;\r\n            case SceneLoaderAnimationGroupLoadingMode.NoSync:\r\n                // nothing to do\r\n                break;\r\n            default:\r\n                Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\r\n                return;\r\n        }\r\n    }\r\n\r\n    const startingIndexForNewAnimatables = scene.animatables.length;\r\n\r\n    const onAssetContainerLoaded = (container: AssetContainer) => {\r\n        container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\r\n\r\n        container.dispose();\r\n\r\n        scene.onAnimationFileImportedObservable.notifyObservers(scene);\r\n\r\n        if (onSuccess) {\r\n            onSuccess(scene);\r\n        }\r\n    };\r\n\r\n    await loadAssetContainerImplAsync(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Import animations from a file into a scene\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of BABYLON.Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns A promise that resolves when the animations are imported\r\n */\r\nexport async function ImportAnimationsAsync(source: SceneSource, scene: Scene, options?: ImportAnimationsOptions): Promise<void> {\r\n    const { rootUrl = \"\", overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    await importAnimationsSharedAsync(rootUrl, source, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Import animations from a file into a scene\r\n * @deprecated Please use {@link ImportAnimationsAsync} instead.\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of BABYLON.Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns A promise that resolves when the animations are imported\r\n */\r\nexport async function importAnimationsAsync(source: SceneSource, scene: Scene, options?: ImportAnimationsOptions): Promise<void> {\r\n    return await ImportAnimationsAsync(source, scene, options);\r\n}\r\n\r\n// This function is shared between the new module level importAnimationsAsync and the legacy SceneLoader.ImportAnimationsAsync\r\nasync function importAnimationsSharedAsync(\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    scene?: Nullable<Scene>,\r\n    overwriteAnimations?: boolean,\r\n    animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode,\r\n    targetConverter?: Nullable<(target: any) => any>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<Scene> {\r\n    return await new Promise((resolve, reject) => {\r\n        try {\r\n            importAnimationsImplAsync(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                overwriteAnimations,\r\n                animationGroupLoadingMode,\r\n                targetConverter,\r\n                (scene) => {\r\n                    resolve(scene);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension,\r\n                name,\r\n                pluginOptions\r\n                // eslint-disable-next-line github/no-then\r\n            ).catch(reject);\r\n        } catch (error) {\r\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Class used to load scene from various file formats using registered plugins\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\r\n * @deprecated The module level functions are more efficient for bundler tree shaking and allow plugin options to be passed through. Future improvements to scene loading will primarily be in the module level functions. The SceneLoader class will remain available, but it will be beneficial to prefer the module level functions.\r\n * @see {@link ImportMeshAsync}, {@link LoadSceneAsync}, {@link AppendSceneAsync}, {@link ImportAnimationsAsync}, {@link LoadAssetContainerAsync}\r\n */\r\nexport class SceneLoader {\r\n    /**\r\n     * No logging while loading\r\n     */\r\n    public static readonly NO_LOGGING = Constants.SCENELOADER_NO_LOGGING;\r\n\r\n    /**\r\n     * Minimal logging while loading\r\n     */\r\n    public static readonly MINIMAL_LOGGING = Constants.SCENELOADER_MINIMAL_LOGGING;\r\n\r\n    /**\r\n     * Summary logging while loading\r\n     */\r\n    public static readonly SUMMARY_LOGGING = Constants.SCENELOADER_SUMMARY_LOGGING;\r\n\r\n    /**\r\n     * Detailed logging while loading\r\n     */\r\n    public static readonly DETAILED_LOGGING = Constants.SCENELOADER_DETAILED_LOGGING;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n     */\r\n    public static get ForceFullSceneLoadingForIncremental() {\r\n        return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\r\n    }\r\n\r\n    public static set ForceFullSceneLoadingForIncremental(value: boolean) {\r\n        SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n     */\r\n    public static get ShowLoadingScreen(): boolean {\r\n        return SceneLoaderFlags.ShowLoadingScreen;\r\n    }\r\n\r\n    public static set ShowLoadingScreen(value: boolean) {\r\n        SceneLoaderFlags.ShowLoadingScreen = value;\r\n    }\r\n\r\n    /**\r\n     * Defines the current logging level (while loading the scene)\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static get loggingLevel(): number {\r\n        return SceneLoaderFlags.loggingLevel;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static set loggingLevel(value: number) {\r\n        SceneLoaderFlags.loggingLevel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n     */\r\n    public static get CleanBoneMatrixWeights(): boolean {\r\n        return SceneLoaderFlags.CleanBoneMatrixWeights;\r\n    }\r\n\r\n    public static set CleanBoneMatrixWeights(value: boolean) {\r\n        SceneLoaderFlags.CleanBoneMatrixWeights = value;\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Event raised when a plugin is used to load a scene\r\n     */\r\n    public static readonly OnPluginActivatedObservable = onPluginActivatedObservable;\r\n\r\n    /**\r\n     * Gets the default plugin (used to load Babylon files)\r\n     * @returns the .babylon plugin\r\n     */\r\n    public static GetDefaultPlugin(): IRegisteredPlugin | undefined {\r\n        return getDefaultPlugin();\r\n    }\r\n\r\n    // Public functions\r\n\r\n    /**\r\n     * Gets a plugin that can load the given extension\r\n     * @param extension defines the extension to load\r\n     * @returns a plugin or null if none works\r\n     */\r\n    public static GetPluginForExtension(extension: string): ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory | undefined {\r\n        return getPluginForExtension(extension, true)?.plugin;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the given extension can be loaded\r\n     * @param extension defines the extension to load\r\n     * @returns true if the extension is supported\r\n     */\r\n    public static IsPluginForExtensionAvailable(extension: string): boolean {\r\n        return isPluginForExtensionAvailable(extension);\r\n    }\r\n\r\n    /**\r\n     * Adds a new plugin to the list of registered plugins\r\n     * @param plugin defines the plugin to add\r\n     */\r\n    public static RegisterPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory): void {\r\n        RegisterSceneLoaderPlugin(plugin);\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the name of the file, if the data is binary\r\n     * @param pluginOptions defines the options to use with the plugin\r\n     * @deprecated Please use the module level {@link ImportMeshAsync} instead\r\n     */\r\n    public static ImportMesh(\r\n        meshNames: string | readonly string[] | null | undefined,\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onSuccess?: Nullable<SceneLoaderSuccessCallback>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string,\r\n        pluginOptions?: PluginOptions\r\n    ): void {\r\n        // eslint-disable-next-line github/no-then\r\n        importMeshAsync(meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name, pluginOptions).catch((error) =>\r\n            onError?.(EngineStore.LastCreatedScene!, error?.message, error)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the name of the file\r\n     * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n     * @deprecated Please use the module level {@link ImportMeshAsync} instead\r\n     */\r\n    public static async ImportMeshAsync(\r\n        meshNames: string | readonly string[] | null | undefined,\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return await importMeshAsyncCoreAsync(meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @deprecated Please use the module level {@link LoadSceneAsync} instead\r\n     */\r\n    public static Load(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        engine?: Nullable<AbstractEngine>,\r\n        onSuccess?: Nullable<(scene: Scene) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ) {\r\n        // eslint-disable-next-line github/no-then\r\n        loadSceneImplAsync(rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension, name).catch((error) =>\r\n            onError?.(EngineStore.LastCreatedScene!, error?.message, error)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @returns The loaded scene\r\n     * @deprecated Please use the module level {@link LoadSceneAsync} instead\r\n     */\r\n    public static async LoadAsync(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        engine?: Nullable<AbstractEngine>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<Scene> {\r\n        return await loadSceneSharedAsync(rootUrl, sceneFilename, engine, onProgress, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the name of the file, if the data is binary\r\n     * @deprecated Please use the module level {@link AppendSceneAsync} instead\r\n     */\r\n    public static Append(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onSuccess?: Nullable<(scene: Scene) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ) {\r\n        // eslint-disable-next-line github/no-then\r\n        appendSceneImplAsync(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name).catch((error) =>\r\n            onError?.((scene ?? EngineStore.LastCreatedScene)!, error?.message, error)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the name of the file, if the data is binary\r\n     * @returns The given scene\r\n     * @deprecated Please use the module level {@link AppendSceneAsync} instead\r\n     */\r\n    public static async AppendAsync(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<Scene> {\r\n        return await appendSceneSharedAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @deprecated Please use the module level {@link LoadAssetContainerAsync} instead\r\n     */\r\n    public static LoadAssetContainer(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onSuccess?: Nullable<(assets: AssetContainer) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ) {\r\n        // eslint-disable-next-line github/no-then\r\n        loadAssetContainerImplAsync(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name).catch((error) =>\r\n            onError?.((scene ?? EngineStore.LastCreatedScene)!, error?.message, error)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\r\n     * @param scene is the instance of Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @returns The loaded asset container\r\n     * @deprecated Please use the module level {@link LoadAssetContainerAsync} instead\r\n     */\r\n    public static async LoadAssetContainerAsync(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<AssetContainer> {\r\n        return await loadAssetContainerSharedAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @deprecated Please use the module level {@link ImportAnimationsAsync} instead\r\n     */\r\n    public static ImportAnimations(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        overwriteAnimations?: boolean,\r\n        animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode,\r\n        targetConverter?: Nullable<(target: any) => any>,\r\n        onSuccess?: Nullable<(scene: Scene) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): void {\r\n        importAnimationsImplAsync(\r\n            rootUrl,\r\n            sceneFilename,\r\n            scene,\r\n            overwriteAnimations,\r\n            animationGroupLoadingMode,\r\n            targetConverter,\r\n            onSuccess,\r\n            onProgress,\r\n            onError,\r\n            pluginExtension,\r\n            name\r\n            // eslint-disable-next-line github/no-then\r\n        ).catch((error) => onError?.((scene ?? EngineStore.LastCreatedScene)!, error?.message, error));\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @returns the updated scene with imported animations\r\n     * @deprecated Please use the module level {@link ImportAnimationsAsync} instead\r\n     */\r\n    public static async ImportAnimationsAsync(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        overwriteAnimations?: boolean,\r\n        animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode,\r\n        targetConverter?: Nullable<(target: any) => any>,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        onSuccess?: Nullable<(scene: Scene) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<Scene> {\r\n        return await importAnimationsSharedAsync(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["SceneLoaderAnimationGroupLoadingMode", "_a", "request", "scene"]
}
