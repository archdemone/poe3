{
  "version": 3,
  "sources": ["../../../dev/core/src/Behaviors/Cameras/autoRotationBehavior.ts", "../../../dev/core/src/Behaviors/Cameras/bouncingBehavior.ts", "../../../dev/core/src/Behaviors/Cameras/framingBehavior.ts", "../../../dev/core/src/Cameras/targetCamera.ts", "../../../dev/core/src/Cameras/cameraInputsManager.ts", "../../../dev/core/src/Cameras/Inputs/BaseCameraPointersInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraPointersInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/arcRotateCameraInputsManager.ts", "../../../dev/core/src/Cameras/arcRotateCamera.ts"],
  "sourcesContent": ["import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n/**\r\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\r\n */\r\nexport class AutoRotationBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"AutoRotation\";\r\n    }\r\n\r\n    private _zoomStopsAnimation = false;\r\n    private _idleRotationSpeed = 0.05;\r\n    private _idleRotationWaitTime = 2000;\r\n    private _idleRotationSpinupTime = 2000;\r\n\r\n    /**\r\n     * Target alpha\r\n     */\r\n    public targetAlpha: Nullable<number> = null;\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the default speed at which the camera rotates around the model.\r\n     */\r\n    public set idleRotationSpeed(speed: number) {\r\n        this._idleRotationSpeed = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the default speed at which the camera rotates around the model.\r\n     */\r\n    public get idleRotationSpeed() {\r\n        return this._idleRotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public set idleRotationWaitTime(time: number) {\r\n        this._idleRotationWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public get idleRotationWaitTime() {\r\n        return this._idleRotationWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public set idleRotationSpinupTime(time: number) {\r\n        this._idleRotationSpinupTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public get idleRotationSpinupTime() {\r\n        return this._idleRotationSpinupTime;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the camera is currently rotating because of this behavior\r\n     */\r\n    public get rotationInProgress(): boolean {\r\n        return Math.abs(this._cameraRotationSpeed) > 0;\r\n    }\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastFrameTime: Nullable<number> = null;\r\n    private _lastInteractionTime = -Infinity;\r\n    private _cameraRotationSpeed: number = 0;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (this._reachTargetAlpha()) {\r\n                return;\r\n            }\r\n            const now = PrecisionDate.Now;\r\n            let dt = 0;\r\n            if (this._lastFrameTime != null) {\r\n                dt = now - this._lastFrameTime;\r\n            }\r\n            this._lastFrameTime = now;\r\n\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;\r\n            const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);\r\n            this._cameraRotationSpeed = this._idleRotationSpeed * scale;\r\n\r\n            // Step camera rotation by rotation speed\r\n            if (this._attachedCamera) {\r\n                this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1000);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        this._attachedCamera = null;\r\n        this._lastFrameTime = null;\r\n    }\r\n\r\n    /**\r\n     * Force-reset the last interaction time\r\n     * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`\r\n     */\r\n    public resetLastInteractionTime(customTime?: number): void {\r\n        this._lastInteractionTime = customTime ?? PrecisionDate.Now;\r\n    }\r\n\r\n    /**\r\n     * Returns true if camera alpha reaches the target alpha\r\n     * @returns true if camera alpha reaches the target alpha\r\n     */\r\n    private _reachTargetAlpha(): boolean {\r\n        if (this._attachedCamera && this.targetAlpha) {\r\n            return Math.abs(this._attachedCamera.alpha - this.targetAlpha) < Epsilon;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if user is scrolling.\r\n     * @returns true if user is scrolling.\r\n     */\r\n    private _userIsZooming(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n        return this._attachedCamera.inertialRadiusOffset !== 0;\r\n    }\r\n\r\n    private _lastFrameRadius = 0;\r\n    private _shouldAnimationStopForInteraction(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        let zoomHasHitLimit = false;\r\n        if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\r\n            zoomHasHitLimit = true;\r\n        }\r\n\r\n        // Update the record of previous radius - works as an approx. indicator of hitting radius limits\r\n        this._lastFrameRadius = this._attachedCamera.radius;\r\n        return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n        }\r\n    }\r\n\r\n    // Tools\r\n    private _userIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n}\r\n", "import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { BackEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Animatable } from \"../../Animations/animatable.core\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\r\n */\r\nexport class BouncingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Bouncing\";\r\n    }\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new BackEase(0.3);\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEOUT;\r\n\r\n    /**\r\n     * The duration of the animation, in milliseconds\r\n     */\r\n    public transitionDuration = 450;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when lower radius is reached\r\n     */\r\n    public lowerRadiusTransitionRange = 2;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when upper radius is reached\r\n     */\r\n    public upperRadiusTransitionRange = -2;\r\n\r\n    private _autoTransitionRange = false;\r\n\r\n    /**\r\n     * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     */\r\n    public get autoTransitionRange(): boolean {\r\n        return this._autoTransitionRange;\r\n    }\r\n\r\n    /**\r\n     * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     * Transition ranges will be set to 5% of the bounding box diagonal in world space\r\n     */\r\n    public set autoTransitionRange(value: boolean) {\r\n        if (this._autoTransitionRange === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoTransitionRange = value;\r\n\r\n        const camera = this._attachedCamera;\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((transformNode) => {\r\n                if (!transformNode) {\r\n                    return;\r\n                }\r\n\r\n                transformNode.computeWorldMatrix(true);\r\n                if ((transformNode as AbstractMesh).getBoundingInfo) {\r\n                    const diagonal = (transformNode as AbstractMesh).getBoundingInfo().diagonalLength;\r\n\r\n                    this.lowerRadiusTransitionRange = diagonal * 0.05;\r\n                    this.upperRadiusTransitionRange = diagonal * 0.05;\r\n                }\r\n            });\r\n        } else if (this._onMeshTargetChangedObserver) {\r\n            camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n    }\r\n\r\n    // Connection\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<TransformNode>>>;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (!this._attachedCamera) {\r\n                return;\r\n            }\r\n\r\n            // Add the bounce animation to the lower radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);\r\n            }\r\n\r\n            // Add the bounce animation to the upper radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Animations\r\n    private _radiusIsAnimating: boolean = false;\r\n    private _radiusBounceTransition: Nullable<Animation> = null;\r\n    private _animatables = new Array<Animatable>();\r\n    private _cachedWheelPrecision: number;\r\n\r\n    /**\r\n     * Checks if the camera radius is at the specified limit. Takes into account animation locks.\r\n     * @param radiusLimit The limit to check against.\r\n     * @returns Bool to indicate if at limit.\r\n     */\r\n    private _isRadiusAtLimit(radiusLimit: Nullable<number>): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Applies an animation to the radius of the camera, extending by the radiusDelta.\r\n     * @param radiusDelta The delta by which to animate to. Can be negative.\r\n     */\r\n    private _applyBoundRadiusAnimation(radiusDelta: number): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        if (!this._radiusBounceTransition) {\r\n            BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\r\n            this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\r\n        }\r\n        // Prevent zoom until bounce has completed\r\n        this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\r\n        this._attachedCamera.wheelPrecision = Infinity;\r\n        this._attachedCamera.inertialRadiusOffset = 0;\r\n\r\n        // Animate to the radius limit\r\n        this.stopAllAnimations();\r\n        this._radiusIsAnimating = true;\r\n        const animatable = Animation.TransitionTo(\r\n            \"radius\",\r\n            this._attachedCamera.radius + radiusDelta,\r\n            this._attachedCamera,\r\n            this._attachedCamera.getScene(),\r\n            60,\r\n            this._radiusBounceTransition,\r\n            this.transitionDuration,\r\n            () => this._clearAnimationLocks()\r\n        );\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the camera properties.\r\n     */\r\n    protected _clearAnimationLocks(): void {\r\n        this._radiusIsAnimating = false;\r\n\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n        while (this._animatables.length) {\r\n            this._animatables[0].onAnimationEnd = null;\r\n            this._animatables[0].stop();\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n}\r\n", "import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { ExponentialEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\n\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Animatable } from \"../../Animations/animatable.core\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\r\n */\r\nexport class FramingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Framing\";\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the animation to zoom on target mesh has ended\r\n     */\r\n    public onTargetFramingAnimationEndObservable = new Observable<void>();\r\n\r\n    private _mode = FramingBehavior.FitFrustumSidesMode;\r\n    private _radiusScale = 1.0;\r\n    private _positionScale = 0.5;\r\n    private _defaultElevation = 0.3;\r\n    private _elevationReturnTime = 1500;\r\n    private _elevationReturnWaitTime = 1000;\r\n    private _zoomStopsAnimation = false;\r\n    private _framingTime = 1500;\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new ExponentialEase();\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEINOUT;\r\n\r\n    /**\r\n     * Sets the current mode used by the behavior\r\n     */\r\n    public set mode(mode: number) {\r\n        this._mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Gets current mode used by the behavior.\r\n     */\r\n    public get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale applied to the radius (1 by default)\r\n     */\r\n    public set radiusScale(radius: number) {\r\n        this._radiusScale = radius;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale applied to the radius\r\n     */\r\n    public get radiusScale(): number {\r\n        return this._radiusScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public set positionScale(scale: number) {\r\n        this._positionScale = scale;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public get positionScale(): number {\r\n        return this._positionScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public set defaultElevation(elevation: number) {\r\n        this._defaultElevation = elevation;\r\n    }\r\n\r\n    /**\r\n     * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public get defaultElevation() {\r\n        return this._defaultElevation;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public set elevationReturnTime(speed: number) {\r\n        this._elevationReturnTime = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public get elevationReturnTime(): number {\r\n        return this._elevationReturnTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public set elevationReturnWaitTime(time: number) {\r\n        this._elevationReturnWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public get elevationReturnWaitTime(): number {\r\n        return this._elevationReturnWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public set framingTime(time: number) {\r\n        this._framingTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public get framingTime() {\r\n        return this._framingTime;\r\n    }\r\n\r\n    /**\r\n     * Define if the behavior should automatically change the configured\r\n     * camera limits and sensibilities.\r\n     */\r\n    public autoCorrectCameraLimitsAndSensibility = true;\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<TransformNode>>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastInteractionTime = -Infinity;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((transformNode) => {\r\n            if (transformNode && (transformNode as AbstractMesh).getBoundingInfo) {\r\n                this.zoomOnMesh(transformNode as AbstractMesh, undefined, () => {\r\n                    this.onTargetFramingAnimationEndObservable.notifyObservers();\r\n                });\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\r\n            // back to the default position after a given timeout\r\n            this._maintainCameraAboveGround();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Framing control\r\n    private _animatables = new Array<Animatable>();\r\n    private _betaIsAnimating = false;\r\n    private _betaTransition: Animation;\r\n    private _radiusTransition: Animation;\r\n    private _vectorTransition: Animation;\r\n\r\n    /**\r\n     * Targets the given mesh and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMesh(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given mesh with its children and updates zoom level accordingly.\r\n     * @param mesh The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshHierarchy(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getHierarchyBoundingVectors(true);\r\n        this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given meshes with their children and updates zoom level accordingly.\r\n     * @param meshes  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshesHierarchy(meshes: AbstractMesh[], focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\r\n            Vector3.CheckExtends(boundingInfo.min, min, max);\r\n            Vector3.CheckExtends(boundingInfo.max, min, max);\r\n        }\r\n\r\n        this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the bounding box info defined by its extends and updates zoom level accordingly.\r\n     * @param minimumWorld Determines the smaller position of the bounding box extend\r\n     * @param maximumWorld Determines the bigger position of the bounding box extend\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     * @returns true if the zoom was done\r\n     */\r\n    public zoomOnBoundingInfo(minimumWorld: Vector3, maximumWorld: Vector3, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): boolean {\r\n        let zoomTarget: Vector3;\r\n\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\r\n        const bottom = minimumWorld.y;\r\n        const top = maximumWorld.y;\r\n        const zoomTargetY = bottom + (top - bottom) * this._positionScale;\r\n        const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\r\n\r\n        if (!isFinite(zoomTargetY)) {\r\n            return false; // Abort mission as there is no target\r\n        }\r\n\r\n        if (focusOnOriginXZ) {\r\n            zoomTarget = new Vector3(0, zoomTargetY, 0);\r\n        } else {\r\n            const centerWorld = minimumWorld.add(radiusWorld);\r\n            zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\r\n        }\r\n\r\n        if (!this._vectorTransition) {\r\n            this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        this._betaIsAnimating = true;\r\n        let animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        // sets the radius and lower radius bounds\r\n        // Small delta ensures camera is not always at lower zoom limit.\r\n        let radius = 0;\r\n        if (this._mode === FramingBehavior.FitFrustumSidesMode) {\r\n            const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility) {\r\n                this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\r\n            }\r\n            radius = position;\r\n        } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\r\n                this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\r\n            }\r\n        }\r\n\r\n        // Set sensibilities\r\n        if (this.autoCorrectCameraLimitsAndSensibility) {\r\n            const extend = maximumWorld.subtract(minimumWorld).length();\r\n            this._attachedCamera.panningSensibility = 5000 / extend;\r\n            this._attachedCamera.wheelPrecision = 100 / radius;\r\n        }\r\n\r\n        // transition to new radius\r\n        if (!this._radiusTransition) {\r\n            this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {\r\n            this.stopAllAnimations();\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n\r\n            if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {\r\n                this._attachedCamera.storeState();\r\n            }\r\n        });\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Calculates the lowest radius for the camera based on the bounding box of the mesh.\r\n     * @param minimumWorld\r\n     * @param maximumWorld\r\n     * @returns The minimum distance from the primary mesh's center point at which the camera must be kept in order\r\n     *\t\t to fully enclose the mesh in the viewing frustum.\r\n     */\r\n    protected _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3): number {\r\n        const camera = this._attachedCamera;\r\n\r\n        if (!camera) {\r\n            return 0;\r\n        }\r\n\r\n        let distance = camera._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld, this._radiusScale);\r\n        if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            // Don't exceed the requested limit\r\n            distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\r\n        }\r\n\r\n        // Don't exceed the upper radius limit\r\n        if (camera.upperRadiusLimit) {\r\n            distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\r\n        }\r\n\r\n        return distance;\r\n    }\r\n\r\n    /**\r\n     * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\r\n     * is automatically returned to its default position (expected to be above ground plane).\r\n     */\r\n    private _maintainCameraAboveGround(): void {\r\n        if (this._elevationReturnTime < 0) {\r\n            return;\r\n        }\r\n\r\n        const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\r\n        const defaultBeta = Math.PI * 0.5 - this._defaultElevation;\r\n        const limitBeta = Math.PI * 0.5;\r\n\r\n        // Bring the camera back up if below the ground plane\r\n        if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\r\n            this._betaIsAnimating = true;\r\n\r\n            //Transition to new position\r\n            this.stopAllAnimations();\r\n\r\n            if (!this._betaTransition) {\r\n                this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n            }\r\n\r\n            const animatable = Animation.TransitionTo(\r\n                \"beta\",\r\n                defaultBeta,\r\n                this._attachedCamera,\r\n                this._attachedCamera.getScene(),\r\n                60,\r\n                this._betaTransition,\r\n                this._elevationReturnTime,\r\n                () => {\r\n                    this._clearAnimationLocks();\r\n                    this.stopAllAnimations();\r\n                }\r\n            );\r\n\r\n            if (animatable) {\r\n                this._animatables.push(animatable);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\r\n     */\r\n    private _clearAnimationLocks(): void {\r\n        this._betaIsAnimating = false;\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this.isUserIsMoving) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n            this.stopAllAnimations();\r\n            this._clearAnimationLocks();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n\r\n        while (this._animatables.length) {\r\n            if (this._animatables[0]) {\r\n                this._animatables[0].onAnimationEnd = null;\r\n                this._animatables[0].stop();\r\n            }\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the user is moving the camera\r\n     */\r\n    public get isUserIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * The camera can move all the way towards the mesh.\r\n     */\r\n    public static IgnoreBoundsSizeMode = 0;\r\n\r\n    /**\r\n     * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\r\n     */\r\n    public static FitFrustumSidesMode = 1;\r\n}\r\n", "import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Node } from \"../node\";\r\n\r\nNode.AddNodeConstructor(\"TargetCamera\", (name, scene) => {\r\n    return () => new TargetCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n// Temporary cache variables to avoid allocations.\r\nconst TmpMatrix = Matrix.Zero();\r\nconst TmpQuaternion = Quaternion.Identity();\r\n\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    @serialize()\r\n    public updateUpVectorFromRotation = false;\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation: Vector3;\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * @internal\r\n     * @experimental\r\n     * Can be used to change clamping behavior for inertia. Hook into onBeforeRenderObservable to change the value per-frame\r\n     */\r\n    public _panningEpsilon = Epsilon;\r\n    /**\r\n     * @internal\r\n     * @experimental\r\n     * Can be used to change clamping behavior for inertia. Hook into onBeforeRenderObservable to change the value per-frame\r\n     */\r\n    public _rotationEpsilon = Epsilon;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    protected readonly _currentTarget = Vector3.Zero();\r\n    protected _initialFocalDistance = 1;\r\n    protected readonly _viewMatrix = Matrix.Zero();\r\n\r\n    /** @internal */\r\n    public readonly _cameraTransformMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public readonly _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    protected readonly _referencePoint: Vector3;\r\n    protected readonly _transformedReferencePoint = Vector3.Zero();\r\n\r\n    protected readonly _deferredPositionUpdate = new Vector3();\r\n    protected readonly _deferredRotationQuaternionUpdate = new Quaternion();\r\n    protected readonly _deferredRotationUpdate = new Vector3();\r\n    protected _deferredUpdated = false;\r\n    protected _deferOnly: boolean = false;\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n\r\n        this._referencePoint = Vector3.Forward(this.getScene().useRightHandedSystem);\r\n\r\n        // Set the y component of the rotation to Math.PI in right-handed system for backwards compatibility.\r\n        this.rotation = new Vector3(0, this.getScene().useRightHandedSystem ? Math.PI : 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const worldForward = TmpVectors.Vector3[0];\r\n        const localForward = TmpVectors.Vector3[1];\r\n        localForward.set(0, 0, this._scene.useRightHandedSystem ? -1.0 : 1.0);\r\n        this.getDirectionToRef(localForward, worldForward);\r\n        worldForward.scaleInPlace(distance);\r\n        return this.globalPosition.add(worldForward);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            const lockedTarget = this.lockedTarget as AbstractMesh;\r\n            const m = lockedTarget.computeWorldMatrix();\r\n            // in some cases the absolute position resets externally, but doesn't update since the matrix is cached.\r\n            m.getTranslationToRef(lockedTarget.absolutePosition);\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public override storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @internal\r\n     */\r\n    public override _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public override _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @internal */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(this.position, target, Vector3.UpReadOnly, TmpMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(this.position, target, Vector3.UpReadOnly, TmpMatrix);\r\n        }\r\n        TmpMatrix.invert();\r\n\r\n        const rotationQuaternion = this.rotationQuaternion || TmpQuaternion;\r\n        Quaternion.FromRotationMatrixToRef(TmpMatrix, rotationQuaternion);\r\n\r\n        rotationQuaternion.toEulerAnglesToRef(this.rotation);\r\n\r\n        // Explicitly set z to 0 to match previous behavior.\r\n        this.rotation.z = 0;\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            return;\r\n        }\r\n        this._deferredPositionUpdate.addInPlace(this.cameraDirection);\r\n        if (!this._deferOnly) {\r\n            this.position.copyFrom(this._deferredPositionUpdate);\r\n        } else {\r\n            this._deferredUpdated = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public override _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = this.cameraRotation.x || this.cameraRotation.y;\r\n\r\n        this._deferredUpdated = false;\r\n        this._deferredRotationUpdate.copyFrom(this.rotation);\r\n        this._deferredPositionUpdate.copyFrom(this.position);\r\n        if (this.rotationQuaternion) {\r\n            this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);\r\n        }\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);\r\n            }\r\n\r\n            this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;\r\n            this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this._deferredRotationUpdate.x > limit) {\r\n                    this._deferredRotationUpdate.x = limit;\r\n                }\r\n                if (this._deferredRotationUpdate.x < -limit) {\r\n                    this._deferredRotationUpdate.x = -limit;\r\n                }\r\n            }\r\n\r\n            if (!this._deferOnly) {\r\n                this.rotation.copyFrom(this._deferredRotationUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this._deferredRotationUpdate.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(\r\n                        this._deferredRotationUpdate.y,\r\n                        this._deferredRotationUpdate.x,\r\n                        this._deferredRotationUpdate.z,\r\n                        this._deferredRotationQuaternionUpdate\r\n                    );\r\n                    if (!this._deferOnly) {\r\n                        this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                    } else {\r\n                        this._deferredUpdated = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const inertialPanningLimit = this.speed * this._panningEpsilon;\r\n        const inertialRotationLimit = this.speed * this._rotationEpsilon;\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < inertialPanningLimit) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < inertialPanningLimit) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < inertialPanningLimit) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < inertialRotationLimit) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < inertialRotationLimit) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(Vector3.UpReadOnly, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @internal */\r\n    public override _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, TmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(TmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public override createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n\r\n            rigCamera.mode = this.mode;\r\n            rigCamera.orthoLeft = this.orthoLeft;\r\n            rigCamera.orthoRight = this.orthoRight;\r\n            rigCamera.orthoTop = this.orthoTop;\r\n            rigCamera.orthoBottom = this.orthoBottom;\r\n\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var CameraInputTypes = {};\r\n\r\n/**\r\n * This is the contract to implement in order to create a new input class.\r\n * Inputs are dealing with listening to user actions and moving the camera accordingly.\r\n */\r\nexport interface ICameraInput<Tcamera extends Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    camera: Nullable<Tcamera>;\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    getSimpleName(): string;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    detachControl(): void;\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    checkInputs?: () => void;\r\n}\r\n\r\n/**\r\n * Represents a map of input types to input instance or input index to input instance.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface CameraInputsMap<Tcamera extends Camera> {\r\n    /**\r\n     * Accessor to the input by input type.\r\n     */\r\n    [name: string]: ICameraInput<Tcamera>;\r\n    /**\r\n     * Accessor to the input by input index.\r\n     */\r\n    [idx: number]: ICameraInput<Tcamera>;\r\n}\r\n\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class CameraInputsManager<Tcamera extends Camera> {\r\n    /**\r\n     * Defines the list of inputs attached to the camera.\r\n     */\r\n    public attached: CameraInputsMap<Tcamera>;\r\n\r\n    /**\r\n     * Defines the dom element the camera is collecting inputs from.\r\n     * This is null if the controls have not been attached.\r\n     */\r\n    public attachedToElement: boolean = false;\r\n\r\n    /**\r\n     * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public noPreventDefault: boolean;\r\n\r\n    /**\r\n     * Defined the camera the input manager belongs to.\r\n     */\r\n    public camera: Tcamera;\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs: () => void;\r\n\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager belongs to\r\n     */\r\n    constructor(camera: Tcamera) {\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param input Camera input method\r\n     */\r\n    public add(input: ICameraInput<Tcamera>): void {\r\n        const type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n\r\n        this.attached[type] = input;\r\n\r\n        input.camera = this.camera;\r\n\r\n        // for checkInputs, we are dynamically creating a function\r\n        // the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    public remove(inputToRemove: ICameraInput<Tcamera>): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    public removeByType(inputType: string): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addCheckInputs(fn: () => void) {\r\n        const current = this.checkInputs;\r\n        return () => {\r\n            current();\r\n            fn();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    public attachInput(input: ICameraInput<Tcamera>): void {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachElement(noPreventDefault: boolean = false): void {\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    public detachElement(disconnect = false): void {\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    public rebuildInputCheck(): void {\r\n        this.checkInputs = () => {};\r\n\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    public serialize(serializedCamera: any): void {\r\n        const inputs: { [key: string]: any } = {};\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            const res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n\r\n        serializedCamera.inputsmgr = inputs;\r\n    }\r\n\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    public parse(parsedCamera: any): void {\r\n        const parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n\r\n            for (const n in parsedInputs) {\r\n                const construct = (<any>CameraInputTypes)[n];\r\n                if (construct) {\r\n                    const parsedinput = parsedInputs[n];\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedinput,\r\n                        null\r\n                    );\r\n                    this.add(input);\r\n                }\r\n            }\r\n        } else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (const n in this.attached) {\r\n                const construct = (<any>CameraInputTypes)[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedCamera,\r\n                        null\r\n                    );\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo, PointerTouch } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\r\n     */\r\n    protected _altKey: boolean;\r\n    protected _ctrlKey: boolean;\r\n    protected _metaKey: boolean;\r\n    protected _shiftKey: boolean;\r\n\r\n    /**\r\n     * Which mouse buttons were pressed at time of last mouse event.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n     */\r\n    protected _buttonsPressed: number;\r\n\r\n    /**\r\n     * Which pointer ID is currently down (only for mouse events, not used for touch events)\r\n     */\r\n    private _currentMousePointerIdDown: number = -1;\r\n    private _contextMenuBind: EventListener;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n        let previousPinchSquaredDistance = 0;\r\n        let previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\r\n\r\n        this._pointA = null;\r\n        this._pointB = null;\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n\r\n        this._pointerInput = (p) => {\r\n            const evt = <IPointerEvent>p.event;\r\n            const isTouch = evt.pointerType === \"touch\";\r\n\r\n            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                return;\r\n            }\r\n\r\n            const srcElement = <HTMLElement>evt.target;\r\n\r\n            this._altKey = evt.altKey;\r\n            this._ctrlKey = evt.ctrlKey;\r\n            this._metaKey = evt.metaKey;\r\n            this._shiftKey = evt.shiftKey;\r\n            this._buttonsPressed = evt.buttons;\r\n\r\n            if (engine.isPointerLock) {\r\n                const offsetX = evt.movementX;\r\n                const offsetY = evt.movementY;\r\n\r\n                this.onTouch(null, offsetX, offsetY);\r\n                this._pointA = null;\r\n                this._pointB = null;\r\n            } else if (\r\n                p.type !== PointerEventTypes.POINTERDOWN &&\r\n                p.type !== PointerEventTypes.POINTERDOUBLETAP &&\r\n                isTouch &&\r\n                this._pointA?.pointerId !== evt.pointerId &&\r\n                this._pointB?.pointerId !== evt.pointerId\r\n            ) {\r\n                return; // If we get a non-down event for a touch that we're not tracking, ignore it\r\n            } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentMousePointerIdDown === -1 || isTouch)) {\r\n                try {\r\n                    srcElement?.setPointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error. Execution will continue.\r\n                }\r\n\r\n                if (this._pointA === null) {\r\n                    this._pointA = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                        button: evt.button,\r\n                    };\r\n                } else if (this._pointB === null) {\r\n                    this._pointB = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                        button: evt.button,\r\n                    };\r\n                } else {\r\n                    return; // We are already tracking two pointers so ignore this one\r\n                }\r\n\r\n                if (this._currentMousePointerIdDown === -1 && !isTouch) {\r\n                    this._currentMousePointerIdDown = evt.pointerId;\r\n                }\r\n                this.onButtonDown(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                    if (element) {\r\n                        element.focus();\r\n                    }\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                this.onDoubleTap(evt.pointerType);\r\n            } else if (p.type === PointerEventTypes.POINTERUP && (this._currentMousePointerIdDown === evt.pointerId || isTouch)) {\r\n                try {\r\n                    srcElement?.releasePointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error.\r\n                }\r\n\r\n                if (!isTouch) {\r\n                    this._pointB = null; // Mouse and pen are mono pointer\r\n                }\r\n\r\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\r\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\r\n                //when changing orientation while pinching camera,\r\n                //one pointer stay pressed forever if we don't release all pointers\r\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\r\n                if (engine._badOS) {\r\n                    this._pointA = this._pointB = null;\r\n                } else {\r\n                    //only remove the impacted pointer in case of multitouch allowing on most\r\n                    //platforms switching from rotate to zoom and pan seamlessly.\r\n                    if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\r\n                        this._pointA = this._pointB;\r\n                        this._pointB = null;\r\n                    } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\r\n                        this._pointB = null;\r\n                    } else {\r\n                        this._pointA = this._pointB = null;\r\n                    }\r\n                }\r\n\r\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\r\n                    // Previous pinch data is populated but a button has been lifted\r\n                    // so pinch has ended.\r\n                    this.onMultiTouch(\r\n                        this._pointA,\r\n                        this._pointB,\r\n                        previousPinchSquaredDistance,\r\n                        0, // pinchSquaredDistance\r\n                        previousMultiTouchPanPosition,\r\n                        null // multiTouchPanPosition\r\n                    );\r\n                    previousPinchSquaredDistance = 0;\r\n                    previousMultiTouchPanPosition = null;\r\n                }\r\n\r\n                this._currentMousePointerIdDown = -1;\r\n                this.onButtonUp(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                // One button down\r\n                if (this._pointA && this._pointB === null) {\r\n                    const offsetX = evt.clientX - this._pointA.x;\r\n                    const offsetY = evt.clientY - this._pointA.y;\r\n                    this._pointA.x = evt.clientX;\r\n                    this._pointA.y = evt.clientY;\r\n                    this.onTouch(this._pointA, offsetX, offsetY);\r\n                }\r\n                // Two buttons down: pinch\r\n                else if (this._pointA && this._pointB) {\r\n                    const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\r\n                    ed.x = evt.clientX;\r\n                    ed.y = evt.clientY;\r\n                    const distX = this._pointA.x - this._pointB.x;\r\n                    const distY = this._pointA.y - this._pointB.y;\r\n                    const pinchSquaredDistance = distX * distX + distY * distY;\r\n                    const multiTouchPanPosition = {\r\n                        x: (this._pointA.x + this._pointB.x) / 2,\r\n                        y: (this._pointA.y + this._pointB.y) / 2,\r\n                        pointerId: evt.pointerId,\r\n                        type: p.type,\r\n                    };\r\n\r\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\r\n                    previousPinchSquaredDistance = pinchSquaredDistance;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(\r\n                this._pointerInput,\r\n                PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP\r\n            );\r\n\r\n        this._onLostFocus = () => {\r\n            this._pointA = this._pointB = null;\r\n            previousPinchSquaredDistance = 0;\r\n            previousMultiTouchPanPosition = null;\r\n            this.onLostFocus();\r\n        };\r\n\r\n        this._contextMenuBind = (evt: Event) => this.onContextMenu(evt as PointerEvent);\r\n\r\n        if (element) {\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\r\n        }\r\n\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            Tools.RegisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._onLostFocus) {\r\n            const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                Tools.UnregisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n            }\r\n        }\r\n\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n\r\n            if (this._contextMenuBind) {\r\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\r\n                if (inputElement) {\r\n                    inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n                }\r\n            }\r\n\r\n            this._onLostFocus = null;\r\n        }\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n        this._currentMousePointerIdDown = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"pointers\";\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n     * @param type type of event\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onDoubleTap(type: string) {}\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * Override this method to provide functionality.\r\n     * @param point The current position of the pointer\r\n     * @param offsetX The offsetX of the pointer when the event occurred\r\n     * @param offsetY The offsetY of the pointer when the event occurred\r\n     */\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     * @param _pointA First point in the pair\r\n     * @param _pointB Second point in the pair\r\n     * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)\r\n     * @param pinchSquaredDistance Sqr Distance between the points this time\r\n     * @param previousMultiTouchPanPosition Previous center point between the points\r\n     * @param multiTouchPanPosition Current center point between the points\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onMultiTouch(\r\n        _pointA: Nullable<PointerTouch>,\r\n        _pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {}\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt the event to be handled\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonDown(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonUp(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     * Override this method to provide functionality.\r\n     */\r\n    public onLostFocus(): void {}\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _pointA: Nullable<PointerTouch>;\r\n    private _pointB: Nullable<PointerTouch>;\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * The minimum radius used for pinch, to avoid radius lock at 0\r\n     */\r\n    public static MinimumRadiusForPinch: number = 0.001;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public override buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 12.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\r\n    @serialize()\r\n    public useNaturalPinchZoom: boolean = false;\r\n\r\n    /**\r\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\r\n     */\r\n    @serialize()\r\n    public pinchZoom: boolean = true;\r\n\r\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 1000.0;\r\n\r\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanning: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanAndZoom: boolean = true;\r\n\r\n    /**\r\n     * Revers pinch action direction.\r\n     */\r\n    public pinchInwards = true;\r\n\r\n    private _isPanClick: boolean = false;\r\n    private _twoFingerActivityCount: number = 0;\r\n    private _isPinching: boolean = false;\r\n\r\n    /**\r\n     * Move camera from multi touch panning positions.\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    private _computeMultiTouchPanning(previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void {\r\n        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n            this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n            this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move camera from pinch zoom distances.\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     */\r\n    private _computePinchZoom(previousPinchSquaredDistance: number, pinchSquaredDistance: number): void {\r\n        const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\r\n        if (this.useNaturalPinchZoom) {\r\n            this.camera.radius = (radius * Math.sqrt(previousPinchSquaredDistance)) / Math.sqrt(pinchSquaredDistance);\r\n        } else if (this.pinchDeltaPercentage) {\r\n            this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\r\n        } else {\r\n            this.camera.inertialRadiusOffset +=\r\n                (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                ((this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * @param point current touch point\r\n     * @param offsetX offset on X\r\n     * @param offsetY offset on Y\r\n     */\r\n    public override onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        if (this.panningSensibility !== 0 && ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        } else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    public override onDoubleTap() {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * @param pointA point A\r\n     * @param pointB point B\r\n     * @param previousPinchSquaredDistance distance between points in previous pinch\r\n     * @param pinchSquaredDistance distance between points in current pinch\r\n     * @param previousMultiTouchPanPosition multi-touch position in previous step\r\n     * @param multiTouchPanPosition multi-touch position in current step\r\n     */\r\n    public override onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n\r\n        // Zoom and panning enabled together\r\n        if (this.multiTouchPanAndZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom and panning enabled but only one at a time\r\n        } else if (this.multiTouchPanning && this.pinchZoom) {\r\n            this._twoFingerActivityCount++;\r\n\r\n            if (\r\n                this._isPinching ||\r\n                (this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance)\r\n            ) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            } else {\r\n                // Pause between pinch starting and moving implies not a zoom event. Pan instead.\r\n                this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n            }\r\n\r\n            // Panning enabled, zoom disabled\r\n        } else if (this.multiTouchPanning) {\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom enabled, panning disabled\r\n        } else if (this.pinchZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * @param evt Defines the event to track\r\n     */\r\n    public override onButtonDown(evt: IPointerEvent): void {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public override onButtonUp(_evt: IPointerEvent): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    public override onLostFocus(): void {\r\n        this._isPanClick = false;\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\n\r\n/**\r\n * Manage the keyboard inputs to control the movement of an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraKeyboardMoveInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the up action (increase alpha)\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the down action (decrease alpha)\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the left action (increase beta)\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the right action (decrease beta)\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the reset action.\r\n     * Those keys reset the camera to its last stored state (with the method camera.storeState())\r\n     */\r\n    @serialize()\r\n    public keysReset = [220];\r\n\r\n    /**\r\n     * Defines the panning sensibility of the inputs.\r\n     * (How fast is the camera panning)\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 50.0;\r\n\r\n    /**\r\n     * Defines the zooming sensibility of the inputs.\r\n     * (How fast is the camera zooming)\r\n     */\r\n    @serialize()\r\n    public zoomingSensibility: number = 25.0;\r\n\r\n    /**\r\n     * Defines whether maintaining the alt key down switch the movement mode from\r\n     * orientation to zoom.\r\n     */\r\n    @serialize()\r\n    public useAltToZoom: boolean = true;\r\n\r\n    /**\r\n     * Rotation speed of the camera\r\n     */\r\n    @serialize()\r\n    public angularSpeed = 0.01;\r\n\r\n    private _keys = new Array<number>();\r\n    private _ctrlPressed: boolean;\r\n    private _altPressed: boolean;\r\n    private _onCanvasBlurObserver: Nullable<Observer<AbstractEngine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: AbstractEngine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // was there a second variable defined?\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    this._ctrlPressed = evt.ctrlKey;\r\n                    this._altPressed = evt.altKey;\r\n\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX -= 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY += 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset += 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX += 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY -= 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysReset.indexOf(keyCode) !== -1) {\r\n                    if (camera.useInputToRestoreState) {\r\n                        camera.restoreState();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraKeyboardMoveInput\"] = ArcRotateCameraKeyboardMoveInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Clamp } from \"../../Maths/math.scalar.functions\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Firefox uses a different scheme to report scroll distances to other\r\n * browsers. Rather than use complicated methods to calculate the exact\r\n * multiple we need to apply, let's just cheat and use a constant.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n */\r\nconst FfMultiplier = 40;\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public zoomToMouseLocation = false;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    /**\r\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\r\n     */\r\n    public customComputeDeltaFromMouseWheel: Nullable<(wheelDelta: number, input: ArcRotateCameraMouseWheelInput, event: IWheelEvent) => number> = null;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _hitPlane: Nullable<Plane>;\r\n    private _viewOffset: Vector3 = new Vector3(0, 0, 0);\r\n    private _globalOffset: Vector3 = new Vector3(0, 0, 0);\r\n\r\n    protected _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta: number, radius: number) {\r\n        let delta = 0;\r\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        } else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? FfMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            const wheelDelta = -(event.deltaY * platformScale);\r\n\r\n            if (this.customComputeDeltaFromMouseWheel) {\r\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\r\n            } else {\r\n                if (this.wheelDeltaPercentage) {\r\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\r\n\r\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                    // this will stop multiple scroll events zooming in from adding too much inertia\r\n                    if (delta > 0) {\r\n                        let estimatedTargetRadius = this.camera.radius;\r\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\r\n                        for (let i = 0; i < 20; i++) {\r\n                            // 20 iterations should be enough to converge\r\n                            if (estimatedTargetRadius <= targetInertia) {\r\n                                // We do not want a negative radius, so we break out of the loop\r\n                                break;\r\n                            }\r\n                            if (Math.abs(targetInertia * this.camera.inertia) < 0.001) {\r\n                                // We do not want to go below a certain threshold, so we break out of the loop\r\n                                break;\r\n                            }\r\n                            estimatedTargetRadius -= targetInertia;\r\n                            targetInertia *= this.camera.inertia;\r\n                        }\r\n                        estimatedTargetRadius = Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                    }\r\n                } else {\r\n                    delta = wheelDelta / (this.wheelPrecision * 40);\r\n                }\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.zoomToMouseLocation) {\r\n                    // If we are zooming to the mouse location, then we need to get the hit plane at the start of the zoom gesture if it doesn't exist\r\n                    // The hit plane is normally calculated after the first motion and each time there's motion so if we don't do this first,\r\n                    // the first zoom will be to the center of the screen\r\n                    if (!this._hitPlane) {\r\n                        this._updateHitPlane();\r\n                    }\r\n\r\n                    this._zoomToMouse(delta);\r\n                } else {\r\n                    this.camera.inertialRadiusOffset += delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n\r\n        if (this.zoomToMouseLocation) {\r\n            this._inertialPanning.setAll(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (!this.zoomToMouseLocation) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\r\n        if (motion) {\r\n            // if zooming is still happening as a result of inertia, then we also need to update\r\n            // the hit plane.\r\n            this._updateHitPlane();\r\n\r\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\r\n            // uses a different panningInertia which could cause this panning to get out of sync with\r\n            // the zooming, and for this to work they must be exactly in sync.\r\n            camera.target.addInPlace(this._inertialPanning);\r\n            this._inertialPanning.scaleInPlace(camera.inertia);\r\n            this._zeroIfClose(this._inertialPanning);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    private _updateHitPlane() {\r\n        const camera = this.camera;\r\n        const direction = camera.target.subtract(camera.position);\r\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\r\n    }\r\n\r\n    // Get position on the hit plane\r\n    private _getPosition(): Vector3 {\r\n        const camera = this.camera;\r\n        const scene = camera.getScene();\r\n\r\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\r\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\r\n        // a vector defining where we want to zoom to.\r\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\r\n        // Since the camera is the origin of the picking ray, we need to offset it by the camera's offset manually\r\n        // Because the offset is in view space, we need to convert it to world space first\r\n        if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {\r\n            this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);\r\n            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n            this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);\r\n            ray.origin.addInPlace(this._globalOffset);\r\n        }\r\n\r\n        let distance = 0;\r\n        if (this._hitPlane) {\r\n            distance = ray.intersectsPlane(this._hitPlane) ?? 0;\r\n        }\r\n\r\n        // not using this ray again, so modifying its vectors here is fine\r\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\r\n    }\r\n\r\n    private _inertialPanning: Vector3 = Vector3.Zero();\r\n\r\n    private _zoomToMouse(delta: number) {\r\n        const camera = this.camera;\r\n        const inertiaComp = 1 - camera.inertia;\r\n        if (camera.lowerRadiusLimit) {\r\n            const lowerLimit = camera.lowerRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\r\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n        if (camera.upperRadiusLimit) {\r\n            const upperLimit = camera.upperRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\r\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n\r\n        const zoomDistance = delta / inertiaComp;\r\n        const ratio = zoomDistance / camera.radius;\r\n        const vec = this._getPosition();\r\n\r\n        // Now this vector tells us how much we also need to pan the camera\r\n        // so the targeted mouse location becomes the center of zooming.\r\n\r\n        const directionToZoomLocation = TmpVectors.Vector3[6];\r\n        vec.subtractToRef(camera.target, directionToZoomLocation);\r\n        directionToZoomLocation.scaleInPlace(ratio);\r\n        directionToZoomLocation.scaleInPlace(inertiaComp);\r\n        this._inertialPanning.addInPlace(directionToZoomLocation);\r\n\r\n        camera.inertialRadiusOffset += delta;\r\n    }\r\n\r\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\r\n    private _zeroIfClose(vec: Vector3) {\r\n        if (Math.abs(vec.x) < Epsilon) {\r\n            vec.x = 0;\r\n        }\r\n        if (Math.abs(vec.y) < Epsilon) {\r\n            vec.y = 0;\r\n        }\r\n        if (Math.abs(vec.z) < Epsilon) {\r\n            vec.z = 0;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n", "import type { ArcRotateCamera } from \"./arcRotateCamera\";\r\nimport { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { CameraInputsManager } from \"../Cameras/cameraInputsManager\";\r\n\r\n/**\r\n * Default Inputs manager for the ArcRotateCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> {\r\n    /**\r\n     * Instantiates a new ArcRotateCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: ArcRotateCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addMouseWheel(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraMouseWheelInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add pointers input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addPointers(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraPointersInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addKeyboard(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n}\r\n", "import { serialize, serializeAsVector3, serializeAsMeshReference, serializeAsVector2 } from \"../Misc/decorators\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, TmpVectors, Quaternion } from \"../Maths/math.vector\";\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { AutoRotationBehavior } from \"../Behaviors/Cameras/autoRotationBehavior\";\r\nimport { BouncingBehavior } from \"../Behaviors/Cameras/bouncingBehavior\";\r\nimport { FramingBehavior } from \"../Behaviors/Cameras/framingBehavior\";\r\nimport { Camera } from \"./camera\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport type { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport type { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport type { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { ArcRotateCameraInputsManager } from \"../Cameras/arcRotateCameraInputsManager\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\n\r\nNode.AddNodeConstructor(\"ArcRotateCamera\", (name, scene) => {\r\n    return () => new ArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * Computes the alpha angle based on the source position and the target position.\r\n * @param offset The directional offset between the source position and the target position\r\n * @returns The alpha angle in radians\r\n */\r\nexport function ComputeAlpha(offset: Vector3): number {\r\n    // Default alpha to /2 to handle the edge case where x and z are both zero (when looking along up axis)\r\n    let alpha = Math.PI / 2;\r\n    if (!(offset.x === 0 && offset.z === 0)) {\r\n        alpha = Math.acos(offset.x / Math.sqrt(Math.pow(offset.x, 2) + Math.pow(offset.z, 2)));\r\n    }\r\n\r\n    if (offset.z < 0) {\r\n        alpha = 2 * Math.PI - alpha;\r\n    }\r\n\r\n    return alpha;\r\n}\r\n\r\n/**\r\n * Computes the beta angle based on the source position and the target position.\r\n * @param verticalOffset The y value of the directional offset between the source position and the target position\r\n * @param radius The distance between the source position and the target position\r\n * @returns The beta angle in radians\r\n */\r\nexport function ComputeBeta(verticalOffset: number, radius: number): number {\r\n    return Math.acos(verticalOffset / radius);\r\n}\r\n\r\n// Returns the value if not NaN, otherwise returns the fallback value.\r\nfunction CheckNaN(value: number, fallback: number): number {\r\n    return isNaN(value) ? fallback : value;\r\n}\r\n\r\n/**\r\n * This represents an orbital type of camera.\r\n *\r\n * This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.\r\n * Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#arc-rotate-camera\r\n */\r\nexport class ArcRotateCamera extends TargetCamera {\r\n    /**\r\n     * Defines the rotation angle of the camera along the longitudinal axis.\r\n     */\r\n    @serialize()\r\n    public alpha: number;\r\n\r\n    /**\r\n     * Defines the rotation angle of the camera along the latitudinal axis.\r\n     */\r\n    @serialize()\r\n    public beta: number;\r\n\r\n    /**\r\n     * Defines the radius of the camera from its target point.\r\n     */\r\n    @serialize()\r\n    public radius: number;\r\n\r\n    /**\r\n     * Defines an override value to use as the parameter to setTarget.\r\n     * This allows the parameter to be specified when animating the target (e.g. using FramingBehavior).\r\n     */\r\n    @serialize()\r\n    public overrideCloneAlphaBetaRadius: Nullable<boolean>;\r\n\r\n    @serializeAsVector3(\"target\")\r\n    protected _target: Vector3;\r\n    @serializeAsMeshReference(\"targetHost\")\r\n    protected _targetHost: Nullable<TransformNode>;\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it from the radius distance.\r\n     */\r\n    public override get target(): Vector3 {\r\n        return this._target;\r\n    }\r\n    public override set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Defines the target transform node of the camera.\r\n     * The camera looks towards it from the radius distance.\r\n     * Please note that setting a target host will disable panning.\r\n     */\r\n    public get targetHost(): Nullable<TransformNode> {\r\n        return this._targetHost;\r\n    }\r\n    public set targetHost(value: Nullable<TransformNode>) {\r\n        if (value) {\r\n            this.setTarget(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public override getTarget(): Vector3 {\r\n        return this.target;\r\n    }\r\n\r\n    /**\r\n     * Define the current local position of the camera in the scene\r\n     */\r\n    public override get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    public override set position(newPosition: Vector3) {\r\n        this.setPosition(newPosition);\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected _upToYMatrix: Matrix;\r\n    protected _yToUpMatrix: Matrix;\r\n\r\n    /**\r\n     * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())\r\n     * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.\r\n     * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.\r\n     */\r\n    override set upVector(vec: Vector3) {\r\n        if (!this._upToYMatrix) {\r\n            this._yToUpMatrix = new Matrix();\r\n            this._upToYMatrix = new Matrix();\r\n\r\n            this._upVector = Vector3.Zero();\r\n        }\r\n\r\n        vec.normalize();\r\n        this._upVector.copyFrom(vec);\r\n        this.setMatUp();\r\n    }\r\n\r\n    override get upVector() {\r\n        return this._upVector;\r\n    }\r\n\r\n    /**\r\n     * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.\r\n     */\r\n    public setMatUp() {\r\n        // from y-up to custom-up (used in _getViewMatrix)\r\n        Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._yToUpMatrix);\r\n\r\n        // from custom-up to y-up (used in rebuildAnglesAndRadius)\r\n        Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);\r\n    }\r\n\r\n    /**\r\n     * Current inertia value on the longitudinal axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialAlphaOffset = 0;\r\n\r\n    /**\r\n     * Current inertia value on the latitudinal axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialBetaOffset = 0;\r\n\r\n    /**\r\n     * Current inertia value on the radius axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialRadiusOffset = 0;\r\n\r\n    /**\r\n     * Minimum allowed angle on the longitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerAlphaLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed angle on the longitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperAlphaLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Minimum allowed angle on the latitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerBetaLimit: Nullable<number> = 0.01;\r\n\r\n    /**\r\n     * Maximum allowed angle on the latitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperBetaLimit: Nullable<number> = Math.PI - 0.01;\r\n\r\n    /**\r\n     * Minimum allowed distance of the camera to the target (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed distance of the camera to the target (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Minimum allowed vertical target position of the camera.\r\n     * Use this setting in combination with `upperRadiusLimit` to set a global limit for the Cameras vertical position.\r\n     */\r\n    @serialize()\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public lowerTargetYLimit: number = -Infinity;\r\n\r\n    /**\r\n     * Defines the current inertia value used during panning of the camera along the X axis.\r\n     */\r\n    @serialize()\r\n    public inertialPanningX: number = 0;\r\n\r\n    /**\r\n     * Defines the current inertia value used during panning of the camera along the Y axis.\r\n     */\r\n    @serialize()\r\n    public inertialPanningY: number = 0;\r\n\r\n    /**\r\n     * Defines the distance used to consider the camera in pan mode vs pinch/zoom.\r\n     * Basically if your fingers moves away from more than this distance you will be considered\r\n     * in pinch mode.\r\n     */\r\n    @serialize()\r\n    public pinchToPanMaxDistance: number = 20;\r\n\r\n    /**\r\n     * Defines the maximum distance the camera can pan.\r\n     * This could help keeping the camera always in your scene.\r\n     */\r\n    @serialize()\r\n    public panningDistanceLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Defines the target of the camera before panning.\r\n     */\r\n    @serializeAsVector3()\r\n    public panningOriginTarget: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Defines the value of the inertia used during panning.\r\n     * 0 would mean stop inertia and one would mean no deceleration at all.\r\n     */\r\n    @serialize()\r\n    public panningInertia = 0.9;\r\n\r\n    //-- begin properties for backward compatibility for inputs\r\n\r\n    /**\r\n     * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.\r\n     */\r\n    public get angularSensibilityX(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.angularSensibilityX;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set angularSensibilityX(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.angularSensibilityX = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.\r\n     */\r\n    public get angularSensibilityY(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.angularSensibilityY;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set angularSensibilityY(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.angularSensibilityY = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    public get pinchPrecision(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.pinchPrecision;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set pinchPrecision(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.pinchPrecision = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.\r\n     * It will be used instead of pinchPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\r\n     */\r\n    public get pinchDeltaPercentage(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.pinchDeltaPercentage;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set pinchDeltaPercentage(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.pinchDeltaPercentage = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer use natural pinch zoom to override the pinch precision\r\n     * and pinch delta percentage.\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     */\r\n    public get useNaturalPinchZoom(): boolean {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.useNaturalPinchZoom;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public set useNaturalPinchZoom(value: boolean) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.useNaturalPinchZoom = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    public get panningSensibility(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.panningSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set panningSensibility(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.panningSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    public get wheelPrecision(): number {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.wheelPrecision;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set wheelPrecision(value: number) {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.wheelPrecision = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public get zoomToMouseLocation(): boolean {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.zoomToMouseLocation;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public set zoomToMouseLocation(value: boolean) {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.zoomToMouseLocation = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.\r\n     * It will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel zoom is used.\r\n     */\r\n    public get wheelDeltaPercentage(): number {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.wheelDeltaPercentage;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set wheelDeltaPercentage(value: number) {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.wheelDeltaPercentage = value;\r\n        }\r\n    }\r\n\r\n    //-- end properties for backward compatibility for inputs\r\n\r\n    /**\r\n     * Defines how much the radius should be scaled while zooming on a particular mesh (through the zoomOn function)\r\n     */\r\n    @serialize()\r\n    public zoomOnFactor = 1;\r\n\r\n    /**\r\n     * Defines a screen offset for the camera position.\r\n     */\r\n    @serializeAsVector2()\r\n    public targetScreenOffset = Vector2.Zero();\r\n\r\n    /**\r\n     * Allows the camera to be completely reversed.\r\n     * If false the camera can not arrive upside down.\r\n     */\r\n    @serialize()\r\n    public allowUpsideDown = true;\r\n\r\n    /**\r\n     * Define if double tap/click is used to restore the previously saved state of the camera.\r\n     */\r\n    @serialize()\r\n    public useInputToRestoreState = true;\r\n\r\n    /**\r\n     * Factor for restoring information interpolation. default is 0 = off. Any value \\< 0 or \\> 1 will disable interpolation.\r\n     */\r\n    @serialize()\r\n    public restoreStateInterpolationFactor = 0;\r\n\r\n    private _currentInterpolationFactor = 0;\r\n\r\n    /** @internal */\r\n    public override _viewMatrix = new Matrix();\r\n    /** @internal */\r\n    public _useCtrlForPanning: boolean;\r\n    /** @internal */\r\n    public _panningMouseButton: number;\r\n\r\n    /**\r\n     * Defines the input associated to the camera.\r\n     */\r\n    public override inputs: ArcRotateCameraInputsManager;\r\n\r\n    /** @internal */\r\n    public override _reset: () => void;\r\n\r\n    /**\r\n     * Defines the allowed panning axis.\r\n     */\r\n    public panningAxis: Vector3 = new Vector3(1, 1, 0);\r\n    protected _transformedDirection: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * Defines if camera will eliminate transform on y axis.\r\n     */\r\n    public mapPanning: boolean = false;\r\n\r\n    // Behaviors\r\n    private _bouncingBehavior: Nullable<BouncingBehavior>;\r\n\r\n    // This is redundant with all _goal* properties being NaN, but we track it anyway because we check for active interpolation in the hot path.\r\n    private _isInterpolating = false;\r\n\r\n    /**\r\n     * If true, indicates the camera is currently interpolating to a new pose.\r\n     */\r\n    public get isInterpolating(): boolean {\r\n        return this._isInterpolating;\r\n    }\r\n\r\n    /**\r\n     * Gets the bouncing behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\r\n     */\r\n    public get bouncingBehavior(): Nullable<BouncingBehavior> {\r\n        return this._bouncingBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the bouncing behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\r\n     */\r\n    public get useBouncingBehavior(): boolean {\r\n        return this._bouncingBehavior != null;\r\n    }\r\n\r\n    public set useBouncingBehavior(value: boolean) {\r\n        if (value === this.useBouncingBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._bouncingBehavior = new BouncingBehavior();\r\n            this.addBehavior(this._bouncingBehavior);\r\n        } else if (this._bouncingBehavior) {\r\n            this.removeBehavior(this._bouncingBehavior);\r\n            this._bouncingBehavior = null;\r\n        }\r\n    }\r\n\r\n    private _framingBehavior: Nullable<FramingBehavior>;\r\n\r\n    /**\r\n     * Gets the framing behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\r\n     */\r\n    public get framingBehavior(): Nullable<FramingBehavior> {\r\n        return this._framingBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the framing behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\r\n     */\r\n    public get useFramingBehavior(): boolean {\r\n        return this._framingBehavior != null;\r\n    }\r\n\r\n    public set useFramingBehavior(value: boolean) {\r\n        if (value === this.useFramingBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._framingBehavior = new FramingBehavior();\r\n            this.addBehavior(this._framingBehavior);\r\n        } else if (this._framingBehavior) {\r\n            this.removeBehavior(this._framingBehavior);\r\n            this._framingBehavior = null;\r\n        }\r\n    }\r\n\r\n    private _autoRotationBehavior: Nullable<AutoRotationBehavior>;\r\n\r\n    /**\r\n     * Gets the auto rotation behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\r\n     */\r\n    public get autoRotationBehavior(): Nullable<AutoRotationBehavior> {\r\n        return this._autoRotationBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the auto rotation behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\r\n     */\r\n    public get useAutoRotationBehavior(): boolean {\r\n        return this._autoRotationBehavior != null;\r\n    }\r\n\r\n    public set useAutoRotationBehavior(value: boolean) {\r\n        if (value === this.useAutoRotationBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._autoRotationBehavior = new AutoRotationBehavior();\r\n            this.addBehavior(this._autoRotationBehavior);\r\n        } else if (this._autoRotationBehavior) {\r\n            this.removeBehavior(this._autoRotationBehavior);\r\n            this._autoRotationBehavior = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable triggered when the transform node target has been changed on the camera.\r\n     */\r\n    public onMeshTargetChangedObservable = new Observable<Nullable<TransformNode>>();\r\n\r\n    /**\r\n     * Event raised when the camera is colliding with a mesh.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    /**\r\n     * Defines whether the camera should check collision with the objects oh the scene.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#how-can-i-do-this-\r\n     */\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Defines the collision radius of the camera.\r\n     * This simulates a sphere around the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    public collisionRadius = new Vector3(0.5, 0.5, 0.5);\r\n\r\n    protected _collider: Collider;\r\n    protected _previousPosition = Vector3.Zero();\r\n    protected _collisionVelocity = Vector3.Zero();\r\n    protected _newPosition = Vector3.Zero();\r\n    protected _previousAlpha: number;\r\n    protected _previousBeta: number;\r\n    protected _previousRadius: number;\r\n    //due to async collision inspection\r\n    protected _collisionTriggered: boolean;\r\n\r\n    protected _targetBoundingCenter: Nullable<Vector3>;\r\n\r\n    private _computationVector: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Instantiates a new ArcRotateCamera in a given scene\r\n     * @param name Defines the name of the camera\r\n     * @param alpha Defines the camera rotation along the longitudinal axis\r\n     * @param beta Defines the camera rotation along the latitudinal axis\r\n     * @param radius Defines the camera distance from its target\r\n     * @param target Defines the camera target\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive);\r\n\r\n        this._target = Vector3.Zero();\r\n        if (target) {\r\n            this.setTarget(target);\r\n        }\r\n\r\n        this.alpha = alpha;\r\n        this.beta = beta;\r\n        this.radius = radius;\r\n\r\n        this.getViewMatrix();\r\n        this.inputs = new ArcRotateCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouseWheel().addPointers();\r\n    }\r\n\r\n    // Cache\r\n    /** @internal */\r\n    public override _initCache(): void {\r\n        super._initCache();\r\n        this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.alpha = undefined;\r\n        this._cache.beta = undefined;\r\n        this._cache.radius = undefined;\r\n        this._cache.targetScreenOffset = Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        this._cache._target.copyFrom(this._getTargetPosition());\r\n        this._cache.alpha = this.alpha;\r\n        this._cache.beta = this.beta;\r\n        this._cache.radius = this.radius;\r\n        this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);\r\n    }\r\n\r\n    protected _getTargetPosition(): Vector3 {\r\n        if (this._targetHost && this._targetHost.getAbsolutePosition) {\r\n            const pos: Vector3 = this._targetHost.getAbsolutePosition();\r\n            if (this._targetBoundingCenter) {\r\n                pos.addToRef(this._targetBoundingCenter, this._target);\r\n            } else {\r\n                this._target.copyFrom(pos);\r\n            }\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        if (lockedTargetPosition) {\r\n            return lockedTargetPosition;\r\n        }\r\n\r\n        return this._target;\r\n    }\r\n\r\n    private _storedAlpha: number;\r\n    private _storedBeta: number;\r\n    private _storedRadius: number;\r\n    private _storedTarget: Vector3;\r\n    private _storedTargetScreenOffset: Vector2;\r\n\r\n    private _goalAlpha = NaN;\r\n    private _goalBeta = NaN;\r\n    private _goalRadius = NaN;\r\n    private readonly _goalTarget = new Vector3(NaN, NaN, NaN);\r\n    private readonly _goalTargetScreenOffset = new Vector2(NaN, NaN);\r\n\r\n    /**\r\n     * Stores the current state of the camera (alpha, beta, radius and target)\r\n     * @returns the camera itself\r\n     */\r\n    public override storeState(): Camera {\r\n        this._storedAlpha = this.alpha;\r\n        this._storedBeta = this.beta;\r\n        this._storedRadius = this.radius;\r\n        this._storedTarget = this._getTargetPosition().clone();\r\n        this._storedTargetScreenOffset = this.targetScreenOffset.clone();\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Restored camera state. You must call storeState() first\r\n     */\r\n    public override _restoreStateValues(): boolean {\r\n        if (this.hasStateStored() && this.restoreStateInterpolationFactor > Epsilon && this.restoreStateInterpolationFactor < 1) {\r\n            this.interpolateTo(this._storedAlpha, this._storedBeta, this._storedRadius, this._storedTarget, this._storedTargetScreenOffset, this.restoreStateInterpolationFactor);\r\n            return true;\r\n        }\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.setTarget(this._storedTarget.clone());\r\n        this.alpha = this._storedAlpha;\r\n        this.beta = this._storedBeta;\r\n        this.radius = this._storedRadius;\r\n        this.targetScreenOffset = this._storedTargetScreenOffset.clone();\r\n\r\n        this.inertialAlphaOffset = 0;\r\n        this.inertialBetaOffset = 0;\r\n        this.inertialRadiusOffset = 0;\r\n        this.inertialPanningX = 0;\r\n        this.inertialPanningY = 0;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Stops any in-progress interpolation.\r\n     */\r\n    public stopInterpolation(): void {\r\n        this._goalAlpha = NaN;\r\n        this._goalBeta = NaN;\r\n        this._goalRadius = NaN;\r\n        this._goalTarget.set(NaN, NaN, NaN);\r\n        this._goalTargetScreenOffset.set(NaN, NaN);\r\n    }\r\n\r\n    /**\r\n     * Interpolates the camera to a goal state.\r\n     * @param alpha Defines the goal alpha.\r\n     * @param beta Defines the goal beta.\r\n     * @param radius Defines the goal radius.\r\n     * @param target Defines the goal target.\r\n     * @param targetScreenOffset Defines the goal target screen offset.\r\n     * @param interpolationFactor A value  between 0 and 1 that determines the speed of the interpolation.\r\n     * @remarks Passing undefined for any of the parameters will use the current value (effectively stopping any in-progress interpolation for that parameter).\r\n     *          Passing NaN will not start or stop any interpolation for that parameter (effectively allowing multiple interpolations of different parameters to overlap).\r\n     */\r\n    public interpolateTo(\r\n        alpha = this.alpha,\r\n        beta = this.beta,\r\n        radius = this.radius,\r\n        target = this.target,\r\n        targetScreenOffset = this.targetScreenOffset,\r\n        interpolationFactor?: number\r\n    ): void {\r\n        this.inertialAlphaOffset = 0;\r\n        this.inertialBetaOffset = 0;\r\n        this.inertialRadiusOffset = 0;\r\n        this.inertialPanningX = 0;\r\n        this.inertialPanningY = 0;\r\n\r\n        if (interpolationFactor != null) {\r\n            this._currentInterpolationFactor = interpolationFactor;\r\n        } else if (this.restoreStateInterpolationFactor !== 0) {\r\n            this._currentInterpolationFactor = this.restoreStateInterpolationFactor;\r\n        } else {\r\n            this._currentInterpolationFactor = 0.1;\r\n        }\r\n\r\n        // If NaN is passed in for a goal value, keep the current goal value.\r\n        this._goalAlpha = CheckNaN(alpha, this._goalAlpha);\r\n        this._goalBeta = CheckNaN(beta, this._goalBeta);\r\n        this._goalRadius = CheckNaN(radius, this._goalRadius);\r\n        this._goalTarget.set(CheckNaN(target.x, this._goalTarget.x), CheckNaN(target.y, this._goalTarget.y), CheckNaN(target.z, this._goalTarget.z));\r\n        this._goalTargetScreenOffset.set(CheckNaN(targetScreenOffset.x, this._goalTargetScreenOffset.x), CheckNaN(targetScreenOffset.y, this._goalTargetScreenOffset.y));\r\n\r\n        this._goalAlpha = Clamp(this._goalAlpha, this.lowerAlphaLimit ?? -Infinity, this.upperAlphaLimit ?? Infinity);\r\n        this._goalBeta = Clamp(this._goalBeta, this.lowerBetaLimit ?? -Infinity, this.upperBetaLimit ?? Infinity);\r\n        this._goalRadius = Clamp(this._goalRadius, this.lowerRadiusLimit ?? -Infinity, this.upperRadiusLimit ?? Infinity);\r\n        this._goalTarget.y = Clamp(this._goalTarget.y, this.lowerTargetYLimit ?? -Infinity, Infinity);\r\n\r\n        this._isInterpolating = true;\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public override _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._cache._target.equals(this._getTargetPosition()) &&\r\n            this._cache.alpha === this.alpha &&\r\n            this._cache.beta === this.beta &&\r\n            this._cache.radius === this.radius &&\r\n            this._cache.targetScreenOffset.equals(this.targetScreenOffset)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public override attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public override attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     */\r\n    public override attachControl(noPreventDefault: boolean, useCtrlForPanning: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     */\r\n    public override attachControl(ignored: any, noPreventDefault: boolean, useCtrlForPanning: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     * @param panningMouseButton Defines whether panning is allowed through mouse click button\r\n     */\r\n    public override attachControl(noPreventDefault: boolean, useCtrlForPanning: boolean, panningMouseButton: number): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     * @param panningMouseButton Defines whether panning is allowed through mouse click button\r\n     */\r\n    public override attachControl(ignored: any, noPreventDefault?: boolean, useCtrlForPanning: boolean | number = true, panningMouseButton: number = 2): void {\r\n        const args = arguments;\r\n\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(args);\r\n        this._useCtrlForPanning = useCtrlForPanning as boolean;\r\n        this._panningMouseButton = panningMouseButton;\r\n        // backwards compatibility\r\n        if (typeof args[0] === \"boolean\") {\r\n            if (args.length > 1) {\r\n                this._useCtrlForPanning = args[1];\r\n            }\r\n            if (args.length > 2) {\r\n                this._panningMouseButton = args[2];\r\n            }\r\n        }\r\n\r\n        this.inputs.attachElement(noPreventDefault);\r\n\r\n        this._reset = () => {\r\n            this.inertialAlphaOffset = 0;\r\n            this.inertialBetaOffset = 0;\r\n            this.inertialRadiusOffset = 0;\r\n            this.inertialPanningX = 0;\r\n            this.inertialPanningY = 0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public override detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        if (this._reset) {\r\n            this._reset();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public override _checkInputs(): void {\r\n        //if (async) collision inspection was triggered, don't update the camera's position - until the collision callback was called.\r\n        if (this._collisionTriggered) {\r\n            return;\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n        let hasUserInteractions = false;\r\n\r\n        const inertialPanningLimit = this.speed * this._panningEpsilon;\r\n        const inertialRotationLimit = this.speed * this._rotationEpsilon;\r\n\r\n        // Inertia\r\n        if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {\r\n            hasUserInteractions = true;\r\n\r\n            const directionModifier = this.invertRotation ? -1 : 1;\r\n            const handednessMultiplier = this._calculateHandednessMultiplier();\r\n            let inertialAlphaOffset = this.inertialAlphaOffset * handednessMultiplier;\r\n\r\n            if (this.beta < 0) {\r\n                inertialAlphaOffset *= -1;\r\n            }\r\n\r\n            this.alpha += inertialAlphaOffset * directionModifier;\r\n            this.beta += this.inertialBetaOffset * directionModifier;\r\n\r\n            this.radius -= this.inertialRadiusOffset;\r\n            this.inertialAlphaOffset *= this.inertia;\r\n            this.inertialBetaOffset *= this.inertia;\r\n            this.inertialRadiusOffset *= this.inertia;\r\n            if (Math.abs(this.inertialAlphaOffset) < inertialRotationLimit) {\r\n                this.inertialAlphaOffset = 0;\r\n            }\r\n            if (Math.abs(this.inertialBetaOffset) < inertialRotationLimit) {\r\n                this.inertialBetaOffset = 0;\r\n            }\r\n            if (Math.abs(this.inertialRadiusOffset) < inertialRotationLimit) {\r\n                this.inertialRadiusOffset = 0;\r\n            }\r\n        }\r\n\r\n        // Panning inertia\r\n        if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {\r\n            hasUserInteractions = true;\r\n\r\n            const localDirection = new Vector3(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);\r\n\r\n            this._viewMatrix.invertToRef(this._cameraTransformMatrix);\r\n            localDirection.multiplyInPlace(this.panningAxis);\r\n            Vector3.TransformNormalToRef(localDirection, this._cameraTransformMatrix, this._transformedDirection);\r\n\r\n            // If mapPanning is enabled, we need to take the upVector into account and\r\n            // make sure we're not panning in the y direction\r\n            if (this.mapPanning) {\r\n                const up = this.upVector;\r\n                const right = Vector3.CrossToRef(this._transformedDirection, up, this._transformedDirection);\r\n                Vector3.CrossToRef(up, right, this._transformedDirection);\r\n            } else if (!this.panningAxis.y) {\r\n                this._transformedDirection.y = 0;\r\n            }\r\n\r\n            if (!this._targetHost) {\r\n                if (this.panningDistanceLimit) {\r\n                    this._transformedDirection.addInPlace(this._target);\r\n                    const distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);\r\n                    if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {\r\n                        this._target.copyFrom(this._transformedDirection);\r\n                    }\r\n                } else {\r\n                    if (this.parent) {\r\n                        const m = TmpVectors.Matrix[0];\r\n                        this.parent.getWorldMatrix().getRotationMatrixToRef(m);\r\n                        m.transposeToRef(m);\r\n                        Vector3.TransformCoordinatesToRef(this._transformedDirection, m, this._transformedDirection);\r\n                    }\r\n                    this._target.addInPlace(this._transformedDirection);\r\n                }\r\n            }\r\n\r\n            this.inertialPanningX *= this.panningInertia;\r\n            this.inertialPanningY *= this.panningInertia;\r\n\r\n            if (Math.abs(this.inertialPanningX) < inertialPanningLimit) {\r\n                this.inertialPanningX = 0;\r\n            }\r\n            if (Math.abs(this.inertialPanningY) < inertialPanningLimit) {\r\n                this.inertialPanningY = 0;\r\n            }\r\n        }\r\n\r\n        if (hasUserInteractions) {\r\n            this.stopInterpolation();\r\n        } else if (this._isInterpolating) {\r\n            let isInterpolating = false;\r\n            const dt = this._scene.getEngine().getDeltaTime() / 1000;\r\n            const t = 1 - Math.pow(2, -dt / this._currentInterpolationFactor);\r\n\r\n            // NOTE: If the goal is NaN, it means we are not interpolating to a new value, so we can use the current value. Hence the calls to checkNaN.\r\n\r\n            // Get the goal radius immediately as we'll need it for determining interpolation termination for the target.\r\n            const goalRadius = CheckNaN(this._goalRadius, this.radius);\r\n\r\n            // Interpolate the target if we haven't reached the goal yet.\r\n            if (!isNaN(this._goalTarget.x) || !isNaN(this._goalTarget.y) || !isNaN(this._goalTarget.z)) {\r\n                const goalTarget = TmpVectors.Vector3[0].set(\r\n                    CheckNaN(this._goalTarget.x, this._target.x),\r\n                    CheckNaN(this._goalTarget.y, this._target.y),\r\n                    CheckNaN(this._goalTarget.z, this._target.z)\r\n                );\r\n                Vector3.LerpToRef(this.target, goalTarget, t, this._target);\r\n\r\n                // Terminate the target interpolation if we the target is close relative to the radius.\r\n                // This is when visually (regardless of scale) the target appears close to its final goal position.\r\n                if ((Vector3.Distance(this.target, goalTarget) * 10) / goalRadius < Epsilon) {\r\n                    this._goalTarget.set(NaN, NaN, NaN);\r\n                    this.target.copyFrom(goalTarget);\r\n                    // Call setTarget to trigger side effects like onMeshTargetChangedObservable.\r\n                    // NOTE: We pass in true for allowSamePosition because we already checked that the goal target is different from the current target,\r\n                    // but since we are updating the existing target Vector3 instance, it will otherwise look like the value has not changed.\r\n                    this.setTarget(this.target, false, true, true);\r\n                } else {\r\n                    isInterpolating = true;\r\n                }\r\n            }\r\n\r\n            // Interpolate the rotation if we haven't reached the goal yet.\r\n            if (!isNaN(this._goalAlpha) || !isNaN(this._goalBeta)) {\r\n                // Using quaternion for smoother interpolation (and no Euler angles modulo)\r\n                const goalRotation = Quaternion.RotationAlphaBetaGammaToRef(\r\n                    CheckNaN(this._goalAlpha, this.alpha),\r\n                    CheckNaN(this._goalBeta, this.beta),\r\n                    0,\r\n                    TmpVectors.Quaternion[0]\r\n                );\r\n                const currentRotation = Quaternion.RotationAlphaBetaGammaToRef(this.alpha, this.beta, 0, TmpVectors.Quaternion[1]);\r\n                const newRotation = Quaternion.SlerpToRef(currentRotation, goalRotation, t, TmpVectors.Quaternion[2]);\r\n                newRotation.normalize();\r\n                const newAlphaBetaGamma = newRotation.toAlphaBetaGammaToRef(TmpVectors.Vector3[0]);\r\n                this.alpha = newAlphaBetaGamma.x;\r\n                this.beta = newAlphaBetaGamma.y;\r\n\r\n                // Terminate the rotation interpolation when the rotation appears visually close to the final goal rotation.\r\n                if (newRotation.isApprox(goalRotation, Epsilon / 5)) {\r\n                    this._goalAlpha = NaN;\r\n                    this._goalBeta = NaN;\r\n                    const goalAlphaBetaGamma = goalRotation.toAlphaBetaGammaToRef(TmpVectors.Vector3[0]);\r\n                    this.alpha = goalAlphaBetaGamma.x;\r\n                    this.beta = goalAlphaBetaGamma.y;\r\n                } else {\r\n                    isInterpolating = true;\r\n                }\r\n            }\r\n\r\n            // Interpolate the radius if we haven't reached the goal yet.\r\n            if (!isNaN(this._goalRadius)) {\r\n                this.radius += (goalRadius - this.radius) * t;\r\n\r\n                // Terminate the radius interpolation when we are 99.9% of the way to the goal radius, at which point it is visually indistinguishable from the goal.\r\n                if (Math.abs(goalRadius / this.radius - 1) < Epsilon) {\r\n                    this._goalRadius = NaN;\r\n                    this.radius = goalRadius;\r\n                } else {\r\n                    isInterpolating = true;\r\n                }\r\n            }\r\n\r\n            // Interpolate the target screen offset if we haven't reached the goal yet.\r\n            if (!isNaN(this._goalTargetScreenOffset.x) || !isNaN(this._goalTargetScreenOffset.y)) {\r\n                const goalTargetScreenOffset = TmpVectors.Vector2[0].set(\r\n                    CheckNaN(this._goalTargetScreenOffset.x, this.targetScreenOffset.x),\r\n                    CheckNaN(this._goalTargetScreenOffset.y, this.targetScreenOffset.y)\r\n                );\r\n                Vector2.LerpToRef(this.targetScreenOffset, goalTargetScreenOffset, t, this.targetScreenOffset);\r\n\r\n                // Terminate the target screen offset interpolation when the target screen offset appears visually close to the final goal target screen offset.\r\n                if (Vector2.Distance(this.targetScreenOffset, goalTargetScreenOffset) < Epsilon) {\r\n                    this._goalTargetScreenOffset.set(NaN, NaN);\r\n                    this.targetScreenOffset.copyFrom(goalTargetScreenOffset);\r\n                } else {\r\n                    isInterpolating = true;\r\n                }\r\n            }\r\n\r\n            this._isInterpolating = isInterpolating;\r\n        }\r\n\r\n        // Limits\r\n        this._checkLimits();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _checkLimits() {\r\n        if (this.lowerBetaLimit === null || this.lowerBetaLimit === undefined) {\r\n            if (this.allowUpsideDown && this.beta > Math.PI) {\r\n                this.beta = this.beta - 2 * Math.PI;\r\n            }\r\n        } else {\r\n            if (this.beta < this.lowerBetaLimit) {\r\n                this.beta = this.lowerBetaLimit;\r\n            }\r\n        }\r\n\r\n        if (this.upperBetaLimit === null || this.upperBetaLimit === undefined) {\r\n            if (this.allowUpsideDown && this.beta < -Math.PI) {\r\n                this.beta = this.beta + 2 * Math.PI;\r\n            }\r\n        } else {\r\n            if (this.beta > this.upperBetaLimit) {\r\n                this.beta = this.upperBetaLimit;\r\n            }\r\n        }\r\n\r\n        if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {\r\n            this.alpha = this.lowerAlphaLimit;\r\n        }\r\n        if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {\r\n            this.alpha = this.upperAlphaLimit;\r\n        }\r\n\r\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\r\n            this.radius = this.lowerRadiusLimit;\r\n            this.inertialRadiusOffset = 0;\r\n        }\r\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\r\n            this.radius = this.upperRadiusLimit;\r\n            this.inertialRadiusOffset = 0;\r\n        }\r\n\r\n        this.target.y = Math.max(this.target.y, this.lowerTargetYLimit);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds angles (alpha, beta) and radius from the give position and target\r\n     */\r\n    public rebuildAnglesAndRadius(): void {\r\n        this._position.subtractToRef(this._getTargetPosition(), this._computationVector);\r\n\r\n        // need to rotate to Y up equivalent if up vector not Axis.Y\r\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\r\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);\r\n        }\r\n\r\n        this.radius = this._computationVector.length();\r\n\r\n        if (this.radius === 0) {\r\n            this.radius = 0.0001; // Just to avoid division by zero\r\n        }\r\n\r\n        // Alpha and Beta\r\n        const previousAlpha = this.alpha;\r\n        this.alpha = ComputeAlpha(this._computationVector);\r\n        this.beta = ComputeBeta(this._computationVector.y, this.radius);\r\n\r\n        // Calculate the number of revolutions between the new and old alpha values.\r\n        const alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2.0 * Math.PI));\r\n        // Adjust alpha so that its numerical representation is the closest one to the old value.\r\n        this.alpha += alphaCorrectionTurns * 2.0 * Math.PI;\r\n\r\n        this._checkLimits();\r\n    }\r\n\r\n    /**\r\n     * Use a position to define the current camera related information like alpha, beta and radius\r\n     * @param position Defines the position to set the camera at\r\n     */\r\n    public setPosition(position: Vector3): void {\r\n        if (this._position.equals(position)) {\r\n            return;\r\n        }\r\n        this._position.copyFrom(position);\r\n\r\n        this.rebuildAnglesAndRadius();\r\n    }\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * This will automatically adapt alpha beta and radius to fit within the new target.\r\n     * Please note that setting a target as a mesh will disable panning.\r\n     * @param target Defines the new target as a Vector or a transform node\r\n     * @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center\r\n     * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)\r\n     * @param cloneAlphaBetaRadius If true, replicate the current setup (alpha, beta, radius) on the new target\r\n     */\r\n    public override setTarget(target: TransformNode | Vector3, toBoundingCenter = false, allowSamePosition = false, cloneAlphaBetaRadius = false): void {\r\n        cloneAlphaBetaRadius = this.overrideCloneAlphaBetaRadius ?? cloneAlphaBetaRadius;\r\n\r\n        if ((target as TransformNode).computeWorldMatrix) {\r\n            if (toBoundingCenter && (<any>target).getBoundingInfo) {\r\n                this._targetBoundingCenter = (<any>target).getBoundingInfo().boundingBox.centerWorld.clone();\r\n            } else {\r\n                this._targetBoundingCenter = null;\r\n            }\r\n            (<TransformNode>target).computeWorldMatrix();\r\n            this._targetHost = <TransformNode>target;\r\n            this._target = this._getTargetPosition();\r\n\r\n            this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);\r\n        } else {\r\n            const newTarget = <Vector3>target;\r\n            const currentTarget = this._getTargetPosition();\r\n            if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {\r\n                return;\r\n            }\r\n            this._targetHost = null;\r\n            this._target = newTarget;\r\n            this._targetBoundingCenter = null;\r\n            this.onMeshTargetChangedObservable.notifyObservers(null);\r\n        }\r\n\r\n        if (!cloneAlphaBetaRadius) {\r\n            this.rebuildAnglesAndRadius();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public override _getViewMatrix(): Matrix {\r\n        // Compute\r\n        const cosa = Math.cos(this.alpha);\r\n        const sina = Math.sin(this.alpha);\r\n        const cosb = Math.cos(this.beta);\r\n        let sinb = Math.sin(this.beta);\r\n\r\n        if (sinb === 0) {\r\n            sinb = 0.0001;\r\n        }\r\n\r\n        if (this.radius === 0) {\r\n            this.radius = 0.0001; // Just to avoid division by zero\r\n        }\r\n\r\n        const target = this._getTargetPosition();\r\n        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\r\n\r\n        // Rotate according to up vector\r\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\r\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._yToUpMatrix, this._computationVector);\r\n        }\r\n\r\n        target.addToRef(this._computationVector, this._newPosition);\r\n        if (this.getScene().collisionsEnabled && this.checkCollisions) {\r\n            const coordinator = this.getScene().collisionCoordinator;\r\n            if (!this._collider) {\r\n                this._collider = coordinator.createCollider();\r\n            }\r\n            this._collider._radius = this.collisionRadius;\r\n            this._newPosition.subtractToRef(this._position, this._collisionVelocity);\r\n            this._collisionTriggered = true;\r\n            coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n        } else {\r\n            this._position.copyFrom(this._newPosition);\r\n\r\n            let up = this.upVector;\r\n            if (this.allowUpsideDown && sinb < 0) {\r\n                up = up.negate();\r\n            }\r\n\r\n            this._computeViewMatrix(this._position, target, up);\r\n\r\n            this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\r\n            this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\r\n        }\r\n        this._currentTarget.copyFrom(target);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        if (!collidedMesh) {\r\n            this._previousPosition.copyFrom(this._position);\r\n        } else {\r\n            this.setPosition(newPosition);\r\n\r\n            if (this.onCollide) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n\r\n        // Recompute because of constraints\r\n        const cosa = Math.cos(this.alpha);\r\n        const sina = Math.sin(this.alpha);\r\n        const cosb = Math.cos(this.beta);\r\n        let sinb = Math.sin(this.beta);\r\n\r\n        if (sinb === 0) {\r\n            sinb = 0.0001;\r\n        }\r\n\r\n        const target = this._getTargetPosition();\r\n        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\r\n        target.addToRef(this._computationVector, this._newPosition);\r\n        this._position.copyFrom(this._newPosition);\r\n\r\n        let up = this.upVector;\r\n        if (this.allowUpsideDown && this.beta < 0) {\r\n            up = up.clone();\r\n            up = up.negate();\r\n        }\r\n\r\n        this._computeViewMatrix(this._position, target, up);\r\n        this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\r\n        this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\r\n\r\n        this._collisionTriggered = false;\r\n    };\r\n\r\n    /**\r\n     * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.\r\n     * @param meshes Defines the mesh to zoom on\r\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n     */\r\n    public zoomOn(meshes?: AbstractMesh[], doNotUpdateMaxZ = false): void {\r\n        meshes = meshes || this.getScene().meshes;\r\n\r\n        const minMaxVector = Mesh.MinMax(meshes);\r\n        let distance = this._calculateLowerRadiusFromModelBoundingSphere(minMaxVector.min, minMaxVector.max);\r\n\r\n        // If there are defined limits, we need to take them into account\r\n        distance = Math.max(Math.min(distance, this.upperRadiusLimit || Number.MAX_VALUE), this.lowerRadiusLimit || 0);\r\n        this.radius = distance * this.zoomOnFactor;\r\n\r\n        if (this.mode === Camera.ORTHOGRAPHIC_CAMERA) {\r\n            const aspectRatio = this.getScene().getEngine().getAspectRatio(this);\r\n            const orthoExtent = (distance * this.zoomOnFactor) / 2;\r\n            this.orthoLeft = -orthoExtent * aspectRatio;\r\n            this.orthoRight = orthoExtent * aspectRatio;\r\n            this.orthoBottom = -orthoExtent;\r\n            this.orthoTop = orthoExtent;\r\n        }\r\n\r\n        this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance: distance }, doNotUpdateMaxZ);\r\n    }\r\n\r\n    /**\r\n     * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.\r\n     * The target will be changed but the radius\r\n     * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on\r\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n     */\r\n    public focusOn(meshesOrMinMaxVectorAndDistance: AbstractMesh[] | { min: Vector3; max: Vector3; distance: number }, doNotUpdateMaxZ = false): void {\r\n        let meshesOrMinMaxVector: { min: Vector3; max: Vector3 };\r\n        let distance: number;\r\n\r\n        if ((<any>meshesOrMinMaxVectorAndDistance).min === undefined) {\r\n            // meshes\r\n            const meshes = <AbstractMesh[]>meshesOrMinMaxVectorAndDistance || this.getScene().meshes;\r\n            meshesOrMinMaxVector = Mesh.MinMax(meshes);\r\n            distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);\r\n        } else {\r\n            //minMaxVector and distance\r\n            const minMaxVectorAndDistance = <any>meshesOrMinMaxVectorAndDistance;\r\n            meshesOrMinMaxVector = minMaxVectorAndDistance;\r\n            distance = minMaxVectorAndDistance.distance;\r\n        }\r\n\r\n        this._target = Mesh.Center(meshesOrMinMaxVector);\r\n\r\n        if (!doNotUpdateMaxZ) {\r\n            this.maxZ = distance * 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     * Override Camera.createRigCamera\r\n     * @param name the name of the camera\r\n     * @param cameraIndex the index of the camera in the rig cameras array\r\n     */\r\n    public override createRigCamera(name: string, cameraIndex: number): Camera {\r\n        let alphaShift: number = 0;\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n            case Camera.RIG_MODE_VR:\r\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);\r\n                break;\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);\r\n                break;\r\n        }\r\n        const rigCam = new ArcRotateCamera(name, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());\r\n        rigCam._cameraRigParams = {};\r\n        rigCam.isRigCamera = true;\r\n        rigCam.rigParent = this;\r\n        rigCam.upVector = this.upVector;\r\n\r\n        rigCam.mode = this.mode;\r\n        rigCam.orthoLeft = this.orthoLeft;\r\n        rigCam.orthoRight = this.orthoRight;\r\n        rigCam.orthoBottom = this.orthoBottom;\r\n        rigCam.orthoTop = this.orthoTop;\r\n\r\n        return rigCam;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @override\r\n     * Override Camera._updateRigCameras\r\n     */\r\n    public override _updateRigCameras() {\r\n        const camLeft = <ArcRotateCamera>this._rigCameras[0];\r\n        const camRight = <ArcRotateCamera>this._rigCameras[1];\r\n\r\n        camLeft.beta = camRight.beta = this.beta;\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n            case Camera.RIG_MODE_VR:\r\n                camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\r\n                camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\r\n                break;\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n                camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\r\n                camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3, radiusScale: number = 1): number {\r\n        const boxVectorGlobalDiagonal = Vector3.Distance(minimumWorld, maximumWorld);\r\n\r\n        // Get aspect ratio in order to calculate frustum slope\r\n        const engine = this.getScene().getEngine();\r\n        const aspectRatio = engine.getAspectRatio(this);\r\n        const frustumSlopeY = Math.tan(this.fov / 2);\r\n        const frustumSlopeX = frustumSlopeY * aspectRatio;\r\n\r\n        // Formula for setting distance\r\n        // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)\r\n        const radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;\r\n\r\n        // Horizon distance\r\n        const radius = radiusWithoutFraming * radiusScale;\r\n        const distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlopeX * frustumSlopeX));\r\n        const distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlopeY * frustumSlopeY));\r\n        return Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public override dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"ArcRotateCamera\";\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.ArcRotateCamera\", ArcRotateCamera);\r\n"],
  "mappings": "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",
  "names": ["target"]
}
