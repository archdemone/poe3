{
  "version": 3,
  "sources": ["../../../dev/core/src/Engines/Extensions/engine.transformFeedback.ts", "../../../dev/core/src/Shaders/ShadersInclude/clipPlaneFragmentDeclaration2.ts", "../../../dev/core/src/Shaders/gpuRenderParticles.fragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/clipPlaneVertexDeclaration2.ts", "../../../dev/core/src/Shaders/gpuRenderParticles.vertex.ts", "../../../dev/core/src/Particles/gpuParticleSystem.ts"],
  "sourcesContent": ["import type { Nullable } from \"../../types\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\n\r\n/** @internal */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var _forceTransformFeedbackToBundle = true;\r\n\r\ndeclare module \"../../Engines/engine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Engine {\r\n        /**\r\n         * Creates a webGL transform feedback object\r\n         * Please makes sure to check webGLVersion property to check if you are running webGL 2+\r\n         * @returns the webGL transform feedback object\r\n         */\r\n        createTransformFeedback(): WebGLTransformFeedback;\r\n\r\n        /**\r\n         * Delete a webGL transform feedback object\r\n         * @param value defines the webGL transform feedback object to delete\r\n         */\r\n        deleteTransformFeedback(value: WebGLTransformFeedback): void;\r\n\r\n        /**\r\n         * Bind a webGL transform feedback object to the webgl context\r\n         * @param value defines the webGL transform feedback object to bind\r\n         */\r\n        bindTransformFeedback(value: Nullable<WebGLTransformFeedback>): void;\r\n\r\n        /**\r\n         * Begins a transform feedback operation\r\n         * @param usePoints defines if points or triangles must be used\r\n         */\r\n        beginTransformFeedback(usePoints: boolean): void;\r\n\r\n        /**\r\n         * Ends a transform feedback operation\r\n         */\r\n        endTransformFeedback(): void;\r\n\r\n        /**\r\n         * Specify the varyings to use with transform feedback\r\n         * @param program defines the associated webGL program\r\n         * @param value defines the list of strings representing the varying names\r\n         */\r\n        setTranformFeedbackVaryings(program: WebGLProgram, value: string[]): void;\r\n\r\n        /**\r\n         * Bind a webGL buffer for a transform feedback operation\r\n         * @param value defines the webGL buffer to bind\r\n         */\r\n        bindTransformFeedbackBuffer(value: Nullable<DataBuffer>): void;\r\n\r\n        /**\r\n         * Read data back from the bound transform feedback buffer\r\n         * @param target defines the webGL buffer to write to\r\n         */\r\n        readTransformFeedbackBuffer(target: ArrayBufferView): void;\r\n    }\r\n}\r\n\r\nEngine.prototype.createTransformFeedback = function (): WebGLTransformFeedback {\r\n    const transformFeedback = this._gl.createTransformFeedback();\r\n    if (!transformFeedback) {\r\n        throw new Error(\"Unable to create Transform Feedback\");\r\n    }\r\n    return transformFeedback;\r\n};\r\n\r\nEngine.prototype.deleteTransformFeedback = function (value: WebGLTransformFeedback): void {\r\n    this._gl.deleteTransformFeedback(value);\r\n};\r\n\r\nEngine.prototype.bindTransformFeedback = function (value: Nullable<WebGLTransformFeedback>): void {\r\n    this._gl.bindTransformFeedback(this._gl.TRANSFORM_FEEDBACK, value);\r\n};\r\n\r\nEngine.prototype.beginTransformFeedback = function (usePoints: boolean = true): void {\r\n    this._gl.beginTransformFeedback(usePoints ? this._gl.POINTS : this._gl.TRIANGLES);\r\n};\r\n\r\nEngine.prototype.endTransformFeedback = function (): void {\r\n    this._gl.endTransformFeedback();\r\n};\r\n\r\nEngine.prototype.setTranformFeedbackVaryings = function (program: WebGLProgram, value: string[]): void {\r\n    this._gl.transformFeedbackVaryings(program, value, this._gl.INTERLEAVED_ATTRIBS);\r\n};\r\n\r\nEngine.prototype.bindTransformFeedbackBuffer = function (value: Nullable<DataBuffer>): void {\r\n    this._gl.bindBufferBase(this._gl.TRANSFORM_FEEDBACK_BUFFER, 0, value ? value.underlyingResource : null);\r\n};\r\n\r\nEngine.prototype.readTransformFeedbackBuffer = function (target: ArrayBufferView): void {\r\n    this._gl.getBufferSubData(this._gl.TRANSFORM_FEEDBACK_BUFFER, 0, target);\r\n};\r\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneFragmentDeclaration2\";\nconst shader = `#ifdef CLIPPLANE\nin float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nin float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nin float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nin float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nin float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nin float fClipDistance6;\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const clipPlaneFragmentDeclaration2 = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration2\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\n\nconst name = \"gpuRenderParticlesPixelShader\";\nconst shader = `precision highp float;\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nuniform sampler2D diffuseSampler;varying vec2 vUV;varying vec4 vColor;\n#include<clipPlaneFragmentDeclaration2> \n#include<imageProcessingDeclaration>\n#include<logDepthDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\n#include<fogFragmentDeclaration>\nvoid main() {\n#include<clipPlaneFragment> \nvec4 textureColor=texture2D(diffuseSampler,vUV);gl_FragColor=textureColor*vColor;\n#ifdef BLENDMULTIPLYMODE\nfloat alpha=vColor.a*textureColor.a;gl_FragColor.rgb=gl_FragColor.rgb*alpha+vec3(1.0)*(1.0-alpha);\n#endif \n#include<logDepthFragment>\n#include<fogFragment>(color,gl_FragColor)\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ngl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);\n#else\n#ifdef IMAGEPROCESSING\ngl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);gl_FragColor=applyImageProcessing(gl_FragColor);\n#endif\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gpuRenderParticlesPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneVertexDeclaration2\";\nconst shader = `#ifdef CLIPPLANE\nuniform vec4 vClipPlane;out float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;out float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;out float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;out float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;out float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;out float fClipDistance6;\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const clipPlaneVertexDeclaration2 = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration2\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"gpuRenderParticlesVertexShader\";\nconst shader = `precision highp float;uniform mat4 view;uniform mat4 projection;uniform vec2 translationPivot;uniform vec3 worldOffset;\n#ifdef LOCAL\nuniform mat4 emitterWM;\n#endif\nattribute vec3 position;attribute float age;attribute float life;attribute vec3 size;\n#ifndef BILLBOARD\nattribute vec3 initialDirection;\n#endif\n#ifdef BILLBOARDSTRETCHED\nattribute vec3 direction;\n#endif\nattribute float angle;\n#ifdef ANIMATESHEET\nattribute float cellIndex;\n#endif\nattribute vec2 offset;attribute vec2 uv;varying vec2 vUV;varying vec4 vColor;varying vec3 vPositionW;\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\nuniform mat4 invView;\n#endif\n#include<clipPlaneVertexDeclaration2>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\n#ifdef COLORGRADIENTS\nuniform sampler2D colorGradientSampler;\n#else\nuniform vec4 colorDead;attribute vec4 color;\n#endif\n#ifdef ANIMATESHEET\nuniform vec3 sheetInfos;\n#endif\n#ifdef BILLBOARD\nuniform vec3 eyePosition;\n#endif\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {vec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));vec3 zaxis=normalize(cross(yaxis,xaxis));vec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);vec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);vec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);mat3 rotMatrix= mat3(row0,row1,row2);vec3 alignedCorner=rotMatrix*rotatedCorner;\n#ifdef LOCAL\nreturn ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;\n#else\nreturn (position+worldOffset)+alignedCorner;\n#endif\n}\n#ifdef BILLBOARDSTRETCHED\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {vec3 normalizedToCamera=normalize(toCamera);vec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));vec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));vec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);vec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);vec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);mat3 rotMatrix= mat3(row0,row1,row2);vec3 alignedCorner=rotMatrix*rotatedCorner;\n#ifdef LOCAL\nreturn ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;\n#else\nreturn (position+worldOffset)+alignedCorner;\n#endif\n}\n#endif\nvoid main() {\n#ifdef ANIMATESHEET\nfloat rowOffset=floor(cellIndex/sheetInfos.z);float columnOffset=cellIndex-rowOffset*sheetInfos.z;vec2 uvScale=sheetInfos.xy;vec2 uvOffset=vec2(uv.x ,1.0-uv.y);vUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\n#else\nvUV=uv;\n#endif\nfloat ratio=min(1.0,age/life);\n#ifdef COLORGRADIENTS\nvColor=texture2D(colorGradientSampler,vec2(ratio,0));\n#else\nvColor=color*vec4(1.0-ratio)+colorDead*vec4(ratio);\n#endif\nvec2 cornerPos=(offset-translationPivot)*size.yz*size.x;\n#ifdef BILLBOARD\nvec4 rotatedCorner;rotatedCorner.w=0.;\n#ifdef BILLBOARDY\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.y=0.;rotatedCorner.xz+=translationPivot;vec3 yaxis=(position+worldOffset)-eyePosition;yaxis.y=0.;vPositionW=rotate(normalize(yaxis),rotatedCorner.xyz);vec4 viewPosition=(view*vec4(vPositionW,1.0));\n#elif defined(BILLBOARDSTRETCHED)\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;rotatedCorner.xy+=translationPivot;vec3 toCamera=(position+worldOffset)-eyePosition;vPositionW=rotateAlign(toCamera,rotatedCorner.xyz);vec4 viewPosition=(view*vec4(vPositionW,1.0));\n#else\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;rotatedCorner.xy+=translationPivot;\n#ifdef LOCAL\nvec4 viewPosition=view*vec4(((emitterWM*vec4(position,1.0)).xyz+worldOffset),1.0)+rotatedCorner;\n#else\nvec4 viewPosition=view*vec4((position+worldOffset),1.0)+rotatedCorner;\n#endif\nvPositionW=(invView*viewPosition).xyz;\n#endif\n#else\nvec3 rotatedCorner;rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=0.;rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.xz+=translationPivot;vec3 yaxis=normalize(initialDirection);vPositionW=rotate(yaxis,rotatedCorner);vec4 viewPosition=view*vec4(vPositionW,1.0);\n#endif\ngl_Position=projection*viewPosition;\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6) || defined(FOG)\nvec4 worldPos=vec4(vPositionW,1.0);\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gpuRenderParticlesVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Immutable, Nullable, float, DataArray } from \"../types\";\r\nimport type { Color3Gradient, IValueGradient } from \"../Misc/gradients\";\r\nimport { FactorGradient, ColorGradient, GradientHelper } from \"../Misc/gradients\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color4, TmpColors } from \"../Maths/math.color\";\r\nimport { Lerp } from \"../Maths/math.scalar.functions\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\n\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\r\nimport { ParticleSystem } from \"./particleSystem\";\r\nimport { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { CustomParticleEmitter } from \"./EmitterTypes/customParticleEmitter\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { IGPUParticleSystemPlatform } from \"./IGPUParticleSystemPlatform\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport { AddClipPlaneUniforms, BindClipPlane, PrepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\nimport { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\nimport \"../Engines/Extensions/engine.transformFeedback\";\r\n\r\nimport \"../Shaders/gpuRenderParticles.fragment\";\r\nimport \"../Shaders/gpuRenderParticles.vertex\";\r\nimport { BindFogParameters, BindLogDepth } from \"../Materials/materialHelper.functions\";\r\nimport type { PointParticleEmitter } from \"./EmitterTypes/pointParticleEmitter\";\r\nimport type { HemisphericParticleEmitter } from \"./EmitterTypes/hemisphericParticleEmitter\";\r\nimport type { SphereDirectedParticleEmitter, SphereParticleEmitter } from \"./EmitterTypes/sphereParticleEmitter\";\r\nimport type { CylinderDirectedParticleEmitter, CylinderParticleEmitter } from \"./EmitterTypes/cylinderParticleEmitter\";\r\nimport type { ConeDirectedParticleEmitter, ConeParticleEmitter } from \"./EmitterTypes/coneParticleEmitter\";\r\nimport {\r\n    CreateConeEmitter,\r\n    CreateCylinderEmitter,\r\n    CreateDirectedCylinderEmitter,\r\n    CreateDirectedSphereEmitter,\r\n    CreateDirectedConeEmitter,\r\n    CreateHemisphericEmitter,\r\n    CreatePointEmitter,\r\n    CreateSphereEmitter,\r\n} from \"./particleSystem.functions\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\n\r\n/**\r\n * This represents a GPU particle system in Babylon\r\n * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data\r\n * @see https://www.babylonjs-playground.com/#PU4WYI#4\r\n */\r\nexport class GPUParticleSystem extends BaseParticleSystem implements IDisposable, IParticleSystem, IAnimatable {\r\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\r\n    public override layerMask: number = 0x0fffffff;\r\n\r\n    private _capacity: number;\r\n    private _maxActiveParticleCount: number;\r\n    private _currentActiveCount: number;\r\n    private _accumulatedCount = 0;\r\n    private _updateBuffer: UniformBufferEffectCommonAccessor;\r\n\r\n    private _buffer0: Buffer;\r\n    private _buffer1: Buffer;\r\n    private _spriteBuffer: Buffer;\r\n    private _renderVertexBuffers: Array<{ [key: string]: VertexBuffer }> = [];\r\n    private _linesIndexBufferUseInstancing: Nullable<DataBuffer>;\r\n\r\n    private _targetIndex = 0;\r\n    private _sourceBuffer: Buffer;\r\n    private _targetBuffer: Buffer;\r\n\r\n    private _currentRenderId = -1;\r\n    private _currentRenderingCameraUniqueId = -1;\r\n    private _started = false;\r\n    private _stopped = false;\r\n\r\n    private _timeDelta = 0;\r\n\r\n    /** @internal */\r\n    public _randomTexture: RawTexture;\r\n    /** @internal */\r\n    public _randomTexture2: RawTexture;\r\n\r\n    /** Indicates that the update of particles is done in the animate function (and not in render). Default: false */\r\n    public updateInAnimate = false;\r\n\r\n    private _attributesStrideSize: number;\r\n    private _cachedUpdateDefines: string;\r\n\r\n    private _randomTextureSize: number;\r\n    private _actualFrame = 0;\r\n    private _drawWrappers: { [blendMode: number]: DrawWrapper };\r\n    private _customWrappers: { [blendMode: number]: Nullable<DrawWrapper> };\r\n\r\n    private readonly _rawTextureWidth = 256;\r\n\r\n    private _platform: IGPUParticleSystemPlatform;\r\n    private _rebuildingAfterContextLost = false;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the GPU particles can be rendered on current browser\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        if (!EngineStore.LastCreatedEngine) {\r\n            return false;\r\n        }\r\n        const caps = EngineStore.LastCreatedEngine.getCaps();\r\n\r\n        return caps.supportTransformFeedbacks || caps.supportComputeShaders;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the system is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<IParticleSystem>();\r\n    /**\r\n     * An event triggered when the system is stopped\r\n     */\r\n    public onStoppedObservable = new Observable<IParticleSystem>();\r\n\r\n    /**\r\n     * An event triggered when the system is started\r\n     */\r\n    public onStartedObservable = new Observable<IParticleSystem>();\r\n\r\n    private _createIndexBuffer() {\r\n        this._linesIndexBufferUseInstancing = this._engine.createIndexBuffer(new Uint32Array([0, 1, 1, 3, 3, 2, 2, 0, 0, 3]), undefined, \"GPUParticleSystemLinesIndexBuffer\");\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum number of particles active at the same time.\r\n     * @returns The max number of active particles.\r\n     */\r\n    public getCapacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    /**\r\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\r\n     * to override the particles.\r\n     */\r\n    public override forceDepthWrite = false;\r\n\r\n    /**\r\n     * Gets or set the number of active particles\r\n     * The value cannot be greater than \"capacity\" (if it is, it will be limited to \"capacity\").\r\n     */\r\n    public get maxActiveParticleCount(): number {\r\n        return this._maxActiveParticleCount;\r\n    }\r\n\r\n    public set maxActiveParticleCount(value: number) {\r\n        this._maxActiveParticleCount = Math.min(value, this._capacity);\r\n    }\r\n\r\n    /**\r\n     * Gets or set the number of active particles\r\n     * @deprecated Please use maxActiveParticleCount instead.\r\n     */\r\n    public get activeParticleCount(): number {\r\n        return this.maxActiveParticleCount;\r\n    }\r\n\r\n    public set activeParticleCount(value: number) {\r\n        this.maxActiveParticleCount = value;\r\n    }\r\n\r\n    private _preWarmDone = false;\r\n\r\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space.\r\n     */\r\n    public isLocal = false;\r\n\r\n    /** Indicates that the particle system is GPU based */\r\n    public readonly isGPU = true;\r\n\r\n    /** Gets or sets a matrix to use to compute projection */\r\n    public defaultProjectionMatrix: Matrix;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the particle system\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Creates a Point Emitter for the particle system (emits directly from the emitter position)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @returns the emitter\r\n     */\r\n    public override createPointEmitter(direction1: Vector3, direction2: Vector3): PointParticleEmitter {\r\n        const particleEmitter = CreatePointEmitter(direction1, direction2);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)\r\n     * @param radius The radius of the hemisphere to emit from\r\n     * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     * @returns the emitter\r\n     */\r\n    public override createHemisphericEmitter(radius = 1, radiusRange = 1): HemisphericParticleEmitter {\r\n        const particleEmitter = CreateHemisphericEmitter(radius, radiusRange);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Sphere Emitter for the particle system (emits along the sphere radius)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     * @returns the emitter\r\n     */\r\n    public override createSphereEmitter(radius = 1, radiusRange = 1): SphereParticleEmitter {\r\n        const particleEmitter = CreateSphereEmitter(radius, radiusRange);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     * @returns the emitter\r\n     */\r\n    public override createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)): SphereDirectedParticleEmitter {\r\n        const particleEmitter = CreateDirectedSphereEmitter(radius, direction1, direction2);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)\r\n     * @param radius The radius of the emission cylinder\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius\r\n     * @param directionRandomizer How much to randomize the particle direction [0-1]\r\n     * @returns the emitter\r\n     */\r\n    public override createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0): CylinderParticleEmitter {\r\n        const particleEmitter = CreateCylinderEmitter(radius, height, radiusRange, directionRandomizer);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the cylinder to emit from\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     * @returns the emitter\r\n     */\r\n    public override createDirectedCylinderEmitter(\r\n        radius = 1,\r\n        height = 1,\r\n        radiusRange = 1,\r\n        direction1 = new Vector3(0, 1.0, 0),\r\n        direction2 = new Vector3(0, 1.0, 0)\r\n    ): CylinderDirectedParticleEmitter {\r\n        const particleEmitter = CreateDirectedCylinderEmitter(radius, height, radiusRange, direction1, direction2);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)\r\n     * @param radius The radius of the cone to emit from\r\n     * @param angle The base angle of the cone\r\n     * @returns the emitter\r\n     */\r\n    public override createConeEmitter(radius = 1, angle = Math.PI / 4): ConeParticleEmitter {\r\n        const particleEmitter = CreateConeEmitter(radius, angle);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    public override createDirectedConeEmitter(\r\n        radius = 1,\r\n        angle = Math.PI / 4,\r\n        direction1 = new Vector3(0, 1.0, 0),\r\n        direction2 = new Vector3(0, 1.0, 0)\r\n    ): ConeDirectedParticleEmitter {\r\n        const particleEmitter = CreateDirectedConeEmitter(radius, angle, direction1, direction2);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     * @returns the emitter\r\n     */\r\n    public override createBoxEmitter(direction1: Vector3, direction2: Vector3, minEmitBox: Vector3, maxEmitBox: Vector3): BoxParticleEmitter {\r\n        const particleEmitter = new BoxParticleEmitter();\r\n        this.particleEmitterType = particleEmitter;\r\n        this.direction1 = direction1;\r\n        this.direction2 = direction2;\r\n        this.minEmitBox = minEmitBox;\r\n        this.maxEmitBox = maxEmitBox;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /** Flow map */\r\n\r\n    /** @internal */\r\n    public _flowMap: Nullable<Texture> = null;\r\n\r\n    /**\r\n     * The strength of the flow map\r\n     */\r\n    public flowMapStrength = 1.0;\r\n\r\n    /** Gets or sets the current flow map */\r\n    public get flowMap(): Nullable<Texture> {\r\n        return this._flowMap;\r\n    }\r\n\r\n    public set flowMap(value: Nullable<Texture>) {\r\n        if (this._flowMap === value) {\r\n            return;\r\n        }\r\n\r\n        this._flowMap = value;\r\n    }\r\n\r\n    /**\r\n     * Is this system ready to be used/rendered\r\n     * @returns true if the system is ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (\r\n            !this.emitter ||\r\n            (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady()) ||\r\n            (this._flowMap && !this._flowMap.isReady()) ||\r\n            !this.particleTexture ||\r\n            !this.particleTexture.isReady() ||\r\n            this._rebuildingAfterContextLost\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n            if (!this._getWrapper(this.blendMode).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect!.isReady()) {\r\n                return false;\r\n            }\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (!this._platform.isUpdateBufferCreated()) {\r\n            this._recreateUpdateEffect();\r\n            return false;\r\n        }\r\n\r\n        return this._platform.isUpdateBufferReady();\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n     * @returns True if it has been started, otherwise false.\r\n     */\r\n    public isStarted(): boolean {\r\n        return this._started;\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)\r\n     * @returns True if it has been stopped, otherwise false.\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the system is stopping\r\n     * @returns true if the system is currently stopping\r\n     */\r\n    public isStopping() {\r\n        return false; // Stop is immediate on GPU\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles active at the same time.\r\n     * @returns The number of active particles.\r\n     */\r\n    public getActiveCount() {\r\n        return this._currentActiveCount;\r\n    }\r\n\r\n    /**\r\n     * Starts the particle system and begins to emit\r\n     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n     */\r\n    public start(delay = this.startDelay): void {\r\n        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\r\n        }\r\n        if (delay) {\r\n            setTimeout(() => {\r\n                this.start(0);\r\n            }, delay);\r\n            return;\r\n        }\r\n        this._started = true;\r\n        this._stopped = false;\r\n        this._actualFrame = 0;\r\n        this._preWarmDone = false;\r\n\r\n        // Animations\r\n        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\r\n            this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the particle system.\r\n     */\r\n    public stop(): void {\r\n        if (this._stopped) {\r\n            return;\r\n        }\r\n\r\n        this.onStoppedObservable.notifyObservers(this);\r\n\r\n        this._stopped = true;\r\n    }\r\n\r\n    /**\r\n     * Remove all active particles\r\n     */\r\n    public reset(): void {\r\n        this._releaseBuffers();\r\n        this._platform.releaseVertexBuffers();\r\n        this._currentActiveCount = 0;\r\n        this._targetIndex = 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"GPUParticleSystem\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"GPUParticleSystem\";\r\n    }\r\n\r\n    /**\r\n     * Gets the custom effect used to render the particles\r\n     * @param blendMode Blend mode for which the effect should be retrieved\r\n     * @returns The effect\r\n     */\r\n    public getCustomEffect(blendMode: number = 0): Nullable<Effect> {\r\n        return this._customWrappers[blendMode]?.effect ?? this._customWrappers[0]!.effect;\r\n    }\r\n\r\n    private _getCustomDrawWrapper(blendMode: number = 0): Nullable<DrawWrapper> {\r\n        return this._customWrappers[blendMode] ?? this._customWrappers[0];\r\n    }\r\n\r\n    /**\r\n     * Sets the custom effect used to render the particles\r\n     * @param effect The effect to set\r\n     * @param blendMode Blend mode for which the effect should be set\r\n     */\r\n    public setCustomEffect(effect: Nullable<Effect>, blendMode: number = 0) {\r\n        this._customWrappers[blendMode] = new DrawWrapper(this._engine);\r\n        this._customWrappers[blendMode].effect = effect;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _onBeforeDrawParticlesObservable: Nullable<Observable<Nullable<Effect>>> = null;\r\n\r\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\r\n    public get onBeforeDrawParticlesObservable(): Observable<Nullable<Effect>> {\r\n        if (!this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable = new Observable<Nullable<Effect>>();\r\n        }\r\n\r\n        return this._onBeforeDrawParticlesObservable;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\r\n    public get vertexShaderName(): string {\r\n        return \"gpuRenderParticles\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffers used by the particle system\r\n     * Should be called after render() has been called for the current frame so that the buffers returned are the ones that have been updated\r\n     * in the current frame (there's a ping-pong between two sets of buffers - for a given frame, one set is used as the source and the other as the destination)\r\n     */\r\n    public get vertexBuffers(): Immutable<{ [key: string]: VertexBuffer }> {\r\n        // We return the other buffers than those corresponding to this._targetIndex because it is assumed vertexBuffers will be called in the current frame\r\n        // after render() has been called, meaning that the buffers have already been swapped and this._targetIndex points to the buffers that will be updated\r\n        // in the next frame (and which are the sources in this frame) and (this._targetIndex ^ 1) points to the buffers that have been updated this frame\r\n        // (and that will be the source buffers in the next frame)\r\n        return this._renderVertexBuffers[this._targetIndex ^ 1];\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer used by the particle system (null for GPU particle systems)\r\n     */\r\n    public get indexBuffer(): Nullable<DataBuffer> {\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _colorGradientsTexture: RawTexture;\r\n\r\n    protected override _removeGradientAndTexture(gradient: number, gradients: Nullable<IValueGradient[]>, texture: RawTexture): BaseParticleSystem {\r\n        super._removeGradientAndTexture(gradient, gradients, texture);\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color1 defines the color to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addColorGradient(gradient: number, color1: Color4): GPUParticleSystem {\r\n        if (!this._colorGradients) {\r\n            this._colorGradients = [];\r\n        }\r\n\r\n        const colorGradient = new ColorGradient(gradient, color1);\r\n        this._colorGradients.push(colorGradient);\r\n\r\n        this._refreshColorGradient(true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    private _refreshColorGradient(reorder = false) {\r\n        if (this._colorGradients) {\r\n            if (reorder) {\r\n                this._colorGradients.sort((a, b) => {\r\n                    if (a.gradient < b.gradient) {\r\n                        return -1;\r\n                    } else if (a.gradient > b.gradient) {\r\n                        return 1;\r\n                    }\r\n\r\n                    return 0;\r\n                });\r\n            }\r\n\r\n            if (this._colorGradientsTexture) {\r\n                this._colorGradientsTexture.dispose();\r\n                (<any>this._colorGradientsTexture) = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Force the system to rebuild all gradients that need to be resync */\r\n    public forceRefreshGradients() {\r\n        this._refreshColorGradient();\r\n        this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\");\r\n        this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\r\n        this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\");\r\n        this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\r\n        this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\");\r\n\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);\r\n        (<any>this._colorGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     */\r\n    public resetDrawCache(): void {\r\n        for (const blendMode in this._drawWrappers) {\r\n            const drawWrapper = this._drawWrappers[blendMode];\r\n            drawWrapper.drawContext?.reset();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _angularSpeedGradientsTexture: RawTexture;\r\n    /** @internal */\r\n    public _sizeGradientsTexture: RawTexture;\r\n    /** @internal */\r\n    public _velocityGradientsTexture: RawTexture;\r\n    /** @internal */\r\n    public _limitVelocityGradientsTexture: RawTexture;\r\n    /** @internal */\r\n    public _dragGradientsTexture: RawTexture;\r\n\r\n    private _addFactorGradient(factorGradients: FactorGradient[], gradient: number, factor: number) {\r\n        const valueGradient = new FactorGradient(gradient, factor);\r\n        factorGradients.push(valueGradient);\r\n\r\n        this._releaseBuffers();\r\n    }\r\n\r\n    /**\r\n     * Adds a new size gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the size factor to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addSizeGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._sizeGradients) {\r\n            this._sizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._sizeGradients, gradient, factor);\r\n\r\n        this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeSizeGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);\r\n        (<any>this._sizeGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _refreshFactorGradient(factorGradients: Nullable<FactorGradient[]>, textureName: string, reorder = false) {\r\n        if (!factorGradients) {\r\n            return;\r\n        }\r\n\r\n        if (reorder) {\r\n            factorGradients.sort((a, b) => {\r\n                if (a.gradient < b.gradient) {\r\n                    return -1;\r\n                } else if (a.gradient > b.gradient) {\r\n                    return 1;\r\n                }\r\n\r\n                return 0;\r\n            });\r\n        }\r\n\r\n        const that = this as any;\r\n        if (that[textureName]) {\r\n            that[textureName].dispose();\r\n            that[textureName] = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new angular speed gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the angular speed to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addAngularSpeedGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._angularSpeedGradients) {\r\n            this._angularSpeedGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._angularSpeedGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific angular speed gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAngularSpeedGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);\r\n        (<any>this._angularSpeedGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the velocity to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addVelocityGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._velocityGradients) {\r\n            this._velocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._velocityGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeVelocityGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);\r\n        (<any>this._velocityGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new limit velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the limit velocity value to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addLimitVelocityGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._limitVelocityGradients) {\r\n            this._limitVelocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._limitVelocityGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific limit velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLimitVelocityGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);\r\n        (<any>this._limitVelocityGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new drag gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the drag value to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addDragGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._dragGradients) {\r\n            this._dragGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._dragGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific drag gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeDragGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);\r\n        (<any>this._dragGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addEmitRateGradient(): IParticleSystem {\r\n        // Do nothing as emit rate is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeEmitRateGradient(): IParticleSystem {\r\n        // Do nothing as emit rate is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addStartSizeGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeStartSizeGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addColorRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addAlphaRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeAlphaRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addRampGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeRampGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the list of ramp gradients\r\n     */\r\n    public getRampGradients(): Nullable<Array<Color3Gradient>> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\r\n     */\r\n    public get useRampGradients(): boolean {\r\n        //Not supported by GPUParticleSystem\r\n        return false;\r\n    }\r\n\r\n    public set useRampGradients(value: boolean) {\r\n        //Not supported by GPUParticleSystem\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addLifeTimeGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeLifeTimeGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a GPU particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     * @param options The options used to create the system\r\n     * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n     * @param customEffect a custom effect used to change the way particles are rendered by default\r\n     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: Partial<{\r\n            capacity: number;\r\n            randomTextureSize: number;\r\n        }>,\r\n        sceneOrEngine: Scene | AbstractEngine,\r\n        customEffect: Nullable<Effect> = null,\r\n        isAnimationSheetEnabled: boolean = false\r\n    ) {\r\n        super(name);\r\n\r\n        if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\r\n            this._scene = (sceneOrEngine as Scene) || EngineStore.LastCreatedScene;\r\n            this._engine = this._scene.getEngine();\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.particleSystems.push(this);\r\n        } else {\r\n            this._engine = sceneOrEngine as AbstractEngine;\r\n            this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\r\n        }\r\n\r\n        if (this._engine.getCaps().supportComputeShaders) {\r\n            if (!GetClass(\"BABYLON.ComputeShaderParticleSystem\")) {\r\n                throw new Error(\"The ComputeShaderParticleSystem class is not available! Make sure you have imported it.\");\r\n            }\r\n            this._platform = new (GetClass(\"BABYLON.ComputeShaderParticleSystem\"))(this, this._engine);\r\n        } else {\r\n            if (!GetClass(\"BABYLON.WebGL2ParticleSystem\")) {\r\n                throw new Error(\"The WebGL2ParticleSystem class is not available! Make sure you have imported it.\");\r\n            }\r\n            this._platform = new (GetClass(\"BABYLON.WebGL2ParticleSystem\"))(this, this._engine);\r\n        }\r\n\r\n        this._customWrappers = { 0: new DrawWrapper(this._engine) };\r\n        this._customWrappers[0]!.effect = customEffect;\r\n\r\n        this._drawWrappers = { 0: new DrawWrapper(this._engine) };\r\n        if (this._drawWrappers[0].drawContext) {\r\n            this._drawWrappers[0].drawContext.useInstancing = true;\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        options = options ?? {};\r\n\r\n        if (!options.randomTextureSize) {\r\n            delete options.randomTextureSize;\r\n        }\r\n\r\n        const fullOptions = {\r\n            capacity: 50000,\r\n            randomTextureSize: this._engine.getCaps().maxTextureSize,\r\n            ...options,\r\n        };\r\n\r\n        const optionsAsNumber = <number>options;\r\n        if (isFinite(optionsAsNumber)) {\r\n            fullOptions.capacity = optionsAsNumber;\r\n        }\r\n\r\n        this._capacity = fullOptions.capacity;\r\n        this._maxActiveParticleCount = fullOptions.capacity;\r\n        this._currentActiveCount = 0;\r\n        this._isAnimationSheetEnabled = isAnimationSheetEnabled;\r\n\r\n        this.particleEmitterType = new BoxParticleEmitter();\r\n\r\n        // Random data\r\n        const maxTextureSize = Math.min(this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);\r\n        let d = [];\r\n        for (let i = 0; i < maxTextureSize; ++i) {\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n        }\r\n        this._randomTexture = new RawTexture(\r\n            new Float32Array(d),\r\n            maxTextureSize,\r\n            1,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            false,\r\n            false,\r\n            Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            Constants.TEXTURETYPE_FLOAT\r\n        );\r\n        this._randomTexture.name = \"GPUParticleSystem_random1\";\r\n        this._randomTexture.wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n        this._randomTexture.wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n        d = [];\r\n        for (let i = 0; i < maxTextureSize; ++i) {\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n        }\r\n        this._randomTexture2 = new RawTexture(\r\n            new Float32Array(d),\r\n            maxTextureSize,\r\n            1,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            false,\r\n            false,\r\n            Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            Constants.TEXTURETYPE_FLOAT\r\n        );\r\n        this._randomTexture2.name = \"GPUParticleSystem_random2\";\r\n        this._randomTexture2.wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n        this._randomTexture2.wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n        this._randomTextureSize = maxTextureSize;\r\n    }\r\n\r\n    protected override _reset() {\r\n        this._releaseBuffers();\r\n    }\r\n\r\n    private _createVertexBuffers(updateBuffer: Buffer, renderBuffer: Buffer, spriteSource: Buffer): void {\r\n        const renderVertexBuffers: { [key: string]: VertexBuffer } = {};\r\n        renderVertexBuffers[\"position\"] = renderBuffer.createVertexBuffer(\"position\", 0, 3, this._attributesStrideSize, true);\r\n        let offset = 3;\r\n        renderVertexBuffers[\"age\"] = renderBuffer.createVertexBuffer(\"age\", offset, 1, this._attributesStrideSize, true);\r\n        offset += 1;\r\n        renderVertexBuffers[\"size\"] = renderBuffer.createVertexBuffer(\"size\", offset, 3, this._attributesStrideSize, true);\r\n        offset += 3;\r\n        renderVertexBuffers[\"life\"] = renderBuffer.createVertexBuffer(\"life\", offset, 1, this._attributesStrideSize, true);\r\n        offset += 1;\r\n        offset += 4; // seed\r\n        if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\r\n            renderVertexBuffers[\"direction\"] = renderBuffer.createVertexBuffer(\"direction\", offset, 3, this._attributesStrideSize, true);\r\n        }\r\n        offset += 3; // direction\r\n        if (this._platform.alignDataInBuffer) {\r\n            offset += 1;\r\n        }\r\n\r\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        if (!this._colorGradientsTexture) {\r\n            renderVertexBuffers[\"color\"] = renderBuffer.createVertexBuffer(\"color\", offset, 4, this._attributesStrideSize, true);\r\n            offset += 4;\r\n        }\r\n\r\n        if (!this._isBillboardBased) {\r\n            renderVertexBuffers[\"initialDirection\"] = renderBuffer.createVertexBuffer(\"initialDirection\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            renderVertexBuffers[\"noiseCoordinates1\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates1\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n            renderVertexBuffers[\"noiseCoordinates2\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates2\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        renderVertexBuffers[\"angle\"] = renderBuffer.createVertexBuffer(\"angle\", offset, 1, this._attributesStrideSize, true);\r\n        if (this._angularSpeedGradientsTexture) {\r\n            offset++;\r\n        } else {\r\n            offset += 2;\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            renderVertexBuffers[\"cellIndex\"] = renderBuffer.createVertexBuffer(\"cellIndex\", offset, 1, this._attributesStrideSize, true);\r\n            offset += 1;\r\n            if (this.spriteRandomStartCell) {\r\n                renderVertexBuffers[\"cellStartOffset\"] = renderBuffer.createVertexBuffer(\"cellStartOffset\", offset, 1, this._attributesStrideSize, true);\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        renderVertexBuffers[\"offset\"] = spriteSource.createVertexBuffer(\"offset\", 0, 2);\r\n        renderVertexBuffers[\"uv\"] = spriteSource.createVertexBuffer(\"uv\", 2, 2);\r\n\r\n        this._renderVertexBuffers.push(renderVertexBuffers);\r\n\r\n        this._platform.createVertexBuffers(updateBuffer, renderVertexBuffers);\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    private _initialize(force = false): void {\r\n        if (this._buffer0 && !force) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        const data: float[] = [];\r\n\r\n        this._attributesStrideSize = 21;\r\n        this._targetIndex = 0;\r\n\r\n        if (this._platform.alignDataInBuffer) {\r\n            this._attributesStrideSize += 1;\r\n        }\r\n\r\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\r\n            this._attributesStrideSize += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (!this.isBillboardBased) {\r\n            this._attributesStrideSize += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            this._attributesStrideSize -= 4;\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            this._attributesStrideSize -= 1;\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._attributesStrideSize += 1;\r\n            if (this.spriteRandomStartCell) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            this._attributesStrideSize += 6;\r\n            if (this._platform.alignDataInBuffer) {\r\n                this._attributesStrideSize += 2;\r\n            }\r\n        }\r\n\r\n        if (this._platform.alignDataInBuffer) {\r\n            this._attributesStrideSize += 3 - ((this._attributesStrideSize + 3) & 3); // round to multiple of 4\r\n        }\r\n\r\n        const usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        let offset = 0;\r\n        for (let particleIndex = 0; particleIndex < this._capacity; particleIndex++) {\r\n            // position\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n\r\n            // Age\r\n            data.push(0.0); // create the particle as a dead one to create a new one at start\r\n\r\n            // Size\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n\r\n            // life\r\n            data.push(0.0);\r\n\r\n            // Seed\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n\r\n            // direction\r\n            if (usingCustomEmitter) {\r\n                (this.particleEmitterType as CustomParticleEmitter).particleDestinationGenerator(particleIndex, null, tmpVector);\r\n                data.push(tmpVector.x);\r\n                data.push(tmpVector.y);\r\n                data.push(tmpVector.z);\r\n            } else {\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n            }\r\n\r\n            if (this._platform.alignDataInBuffer) {\r\n                data.push(0.0); // dummy0\r\n            }\r\n\r\n            offset += 16; // position, age, size, life, seed, direction, dummy0\r\n\r\n            if (usingCustomEmitter) {\r\n                (this.particleEmitterType as CustomParticleEmitter).particlePositionGenerator(particleIndex, null, tmpVector);\r\n                data.push(tmpVector.x);\r\n                data.push(tmpVector.y);\r\n                data.push(tmpVector.z);\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy1\r\n                }\r\n                offset += 4;\r\n            }\r\n\r\n            if (!this._colorGradientsTexture) {\r\n                // color\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                offset += 4;\r\n            }\r\n\r\n            if (!this.isBillboardBased) {\r\n                // initialDirection\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy2\r\n                }\r\n                offset += 4;\r\n            }\r\n\r\n            if (this.noiseTexture) {\r\n                // Random coordinates for reading into noise texture\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy3\r\n                }\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy4\r\n                }\r\n                offset += 8;\r\n            }\r\n\r\n            // angle\r\n            data.push(0.0);\r\n            offset += 1;\r\n\r\n            if (!this._angularSpeedGradientsTexture) {\r\n                data.push(0.0);\r\n                offset += 1;\r\n            }\r\n\r\n            if (this._isAnimationSheetEnabled) {\r\n                data.push(0.0);\r\n                offset += 1;\r\n                if (this.spriteRandomStartCell) {\r\n                    data.push(0.0);\r\n                    offset += 1;\r\n                }\r\n            }\r\n\r\n            if (this._platform.alignDataInBuffer) {\r\n                let numDummies = 3 - ((offset + 3) & 3);\r\n                offset += numDummies;\r\n                while (numDummies-- > 0) {\r\n                    data.push(0.0);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Sprite data\r\n        const spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, 0.5, -0.5, 1, 0, -0.5, -0.5, 0, 0]);\r\n\r\n        const bufferData1: DataArray | DataBuffer = this._platform.createParticleBuffer(data);\r\n        const bufferData2: DataArray | DataBuffer = this._platform.createParticleBuffer(data);\r\n\r\n        // Buffers\r\n        this._buffer0 = new Buffer(engine, bufferData1, false, this._attributesStrideSize);\r\n        this._buffer1 = new Buffer(engine, bufferData2, false, this._attributesStrideSize);\r\n        this._spriteBuffer = new Buffer(engine, spriteData, false, 4);\r\n\r\n        // Update & Render vertex buffers\r\n        this._renderVertexBuffers = [];\r\n        this._createVertexBuffers(this._buffer0, this._buffer1, this._spriteBuffer);\r\n        this._createVertexBuffers(this._buffer1, this._buffer0, this._spriteBuffer);\r\n\r\n        // Links\r\n        this._sourceBuffer = this._buffer0;\r\n        this._targetBuffer = this._buffer1;\r\n    }\r\n\r\n    /** @internal */\r\n    public _recreateUpdateEffect() {\r\n        this._createColorGradientTexture();\r\n        this._createSizeGradientTexture();\r\n        this._createAngularSpeedGradientTexture();\r\n        this._createVelocityGradientTexture();\r\n        this._createLimitVelocityGradientTexture();\r\n        this._createDragGradientTexture();\r\n\r\n        let defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : \"\";\r\n\r\n        if (this._isBillboardBased) {\r\n            defines += \"\\n#define BILLBOARD\";\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            defines += \"\\n#define COLORGRADIENTS\";\r\n        }\r\n\r\n        if (this._sizeGradientsTexture) {\r\n            defines += \"\\n#define SIZEGRADIENTS\";\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            defines += \"\\n#define ANGULARSPEEDGRADIENTS\";\r\n        }\r\n\r\n        if (this._velocityGradientsTexture) {\r\n            defines += \"\\n#define VELOCITYGRADIENTS\";\r\n        }\r\n\r\n        if (this._limitVelocityGradientsTexture) {\r\n            defines += \"\\n#define LIMITVELOCITYGRADIENTS\";\r\n        }\r\n\r\n        if (this._dragGradientsTexture) {\r\n            defines += \"\\n#define DRAGGRADIENTS\";\r\n        }\r\n\r\n        if (this._flowMap) {\r\n            defines += \"\\n#define FLOWMAP\";\r\n        }\r\n\r\n        if (this.isAnimationSheetEnabled) {\r\n            defines += \"\\n#define ANIMATESHEET\";\r\n            if (this.spriteRandomStartCell) {\r\n                defines += \"\\n#define ANIMATESHEETRANDOMSTART\";\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            defines += \"\\n#define NOISE\";\r\n        }\r\n\r\n        if (this.isLocal) {\r\n            defines += \"\\n#define LOCAL\";\r\n        }\r\n\r\n        if (this._platform.isUpdateBufferCreated() && this._cachedUpdateDefines === defines) {\r\n            return this._platform.isUpdateBufferReady();\r\n        }\r\n\r\n        this._cachedUpdateDefines = defines;\r\n        this._updateBuffer = this._platform.createUpdateBuffer(defines);\r\n\r\n        return this._platform.isUpdateBufferReady();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getWrapper(blendMode: number): DrawWrapper {\r\n        const customWrapper = this._getCustomDrawWrapper(blendMode);\r\n\r\n        if (customWrapper?.effect) {\r\n            return customWrapper;\r\n        }\r\n\r\n        const defines: Array<string> = [];\r\n\r\n        this.fillDefines(defines, blendMode);\r\n\r\n        // Effect\r\n        let drawWrapper = this._drawWrappers[blendMode];\r\n        if (!drawWrapper) {\r\n            drawWrapper = new DrawWrapper(this._engine);\r\n            if (drawWrapper.drawContext) {\r\n                drawWrapper.drawContext.useInstancing = true;\r\n            }\r\n            this._drawWrappers[blendMode] = drawWrapper;\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n        if (drawWrapper.defines !== join) {\r\n            const attributes: Array<string> = [];\r\n            const uniforms: Array<string> = [];\r\n            const samplers: Array<string> = [];\r\n\r\n            this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);\r\n\r\n            drawWrapper.setEffect(this._engine.createEffect(\"gpuRenderParticles\", attributes, uniforms, samplers, join), join);\r\n        }\r\n\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetAttributeNamesOrOptions(hasColorGradients = false, isAnimationSheetEnabled = false, isBillboardBased = false, isBillboardStretched = false): string[] {\r\n        const attributeNamesOrOptions = [VertexBuffer.PositionKind, \"age\", \"life\", \"size\", \"angle\"];\r\n\r\n        if (!hasColorGradients) {\r\n            attributeNamesOrOptions.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            attributeNamesOrOptions.push(\"cellIndex\");\r\n        }\r\n\r\n        if (!isBillboardBased) {\r\n            attributeNamesOrOptions.push(\"initialDirection\");\r\n        }\r\n\r\n        if (isBillboardStretched) {\r\n            attributeNamesOrOptions.push(\"direction\");\r\n        }\r\n\r\n        attributeNamesOrOptions.push(\"offset\", VertexBuffer.UVKind);\r\n\r\n        return attributeNamesOrOptions;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false, applyFog = false): string[] {\r\n        const effectCreationOption = [\"emitterWM\", \"worldOffset\", \"view\", \"projection\", \"colorDead\", \"invView\", \"translationPivot\", \"eyePosition\"];\r\n        AddClipPlaneUniforms(effectCreationOption);\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            effectCreationOption.push(\"sheetInfos\");\r\n        }\r\n        if (useLogarithmicDepth) {\r\n            effectCreationOption.push(\"logarithmicDepthConstant\");\r\n        }\r\n\r\n        if (applyFog) {\r\n            effectCreationOption.push(\"vFogInfos\");\r\n            effectCreationOption.push(\"vFogColor\");\r\n        }\r\n\r\n        return effectCreationOption;\r\n    }\r\n\r\n    /**\r\n     * Fill the defines array according to the current settings of the particle system\r\n     * @param defines Array to be updated\r\n     * @param blendMode blend mode to take into account when updating the array\r\n     * @param fillImageProcessing fills the image processing defines\r\n     */\r\n    public fillDefines(defines: Array<string>, blendMode: number = 0, fillImageProcessing: boolean = true): void {\r\n        if (this._scene) {\r\n            PrepareStringDefinesForClipPlanes(this, this._scene, defines);\r\n            if (this.applyFog && this._scene.fogEnabled && this._scene.fogMode !== Scene.FOGMODE_NONE) {\r\n                defines.push(\"#define FOG\");\r\n            }\r\n        }\r\n\r\n        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\r\n            defines.push(\"#define BLENDMULTIPLYMODE\");\r\n        }\r\n\r\n        if (this.isLocal) {\r\n            defines.push(\"#define LOCAL\");\r\n        }\r\n\r\n        if (this.useLogarithmicDepth) {\r\n            defines.push(\"#define LOGARITHMICDEPTH\");\r\n        }\r\n\r\n        if (this._isBillboardBased) {\r\n            defines.push(\"#define BILLBOARD\");\r\n\r\n            switch (this.billboardMode) {\r\n                case ParticleSystem.BILLBOARDMODE_Y:\r\n                    defines.push(\"#define BILLBOARDY\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_STRETCHED:\r\n                    defines.push(\"#define BILLBOARDSTRETCHED\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_ALL:\r\n                    defines.push(\"#define BILLBOARDMODE_ALL\");\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            defines.push(\"#define COLORGRADIENTS\");\r\n        }\r\n\r\n        if (this.isAnimationSheetEnabled) {\r\n            defines.push(\"#define ANIMATESHEET\");\r\n        }\r\n\r\n        if (fillImageProcessing && this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\r\n            defines.push(\"\" + this._imageProcessingConfigurationDefines.toString());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n     * @param uniforms Uniforms array to fill\r\n     * @param attributes Attributes array to fill\r\n     * @param samplers Samplers array to fill\r\n     */\r\n    public fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>) {\r\n        attributes.push(\r\n            ...GPUParticleSystem._GetAttributeNamesOrOptions(\r\n                !!this._colorGradientsTexture,\r\n                this._isAnimationSheetEnabled,\r\n                this._isBillboardBased,\r\n                this._isBillboardBased && this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED\r\n            )\r\n        );\r\n\r\n        uniforms.push(...GPUParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth, this.applyFog));\r\n\r\n        samplers.push(\"diffuseSampler\", \"colorGradientSampler\");\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n     * @param preWarm defines if we are in the pre-warmimg phase\r\n     */\r\n    public animate(preWarm = false): void {\r\n        this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);\r\n        this._actualFrame += this._timeDelta;\r\n\r\n        if (!this._stopped) {\r\n            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\r\n                this.stop();\r\n            }\r\n        }\r\n\r\n        if (this.updateInAnimate) {\r\n            this._update();\r\n        }\r\n    }\r\n\r\n    private _createFactorGradientTexture(factorGradients: Nullable<IValueGradient[]>, textureName: string) {\r\n        const texture: RawTexture = (<any>this)[textureName];\r\n\r\n        if (!factorGradients || !factorGradients.length || texture) {\r\n            return;\r\n        }\r\n\r\n        const data = new Float32Array(this._rawTextureWidth);\r\n\r\n        for (let x = 0; x < this._rawTextureWidth; x++) {\r\n            const ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, factorGradients, (currentGradient, nextGradient, scale) => {\r\n                data[x] = Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n            });\r\n        }\r\n\r\n        (<any>this)[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n        (<any>this)[textureName].name = textureName.substring(1);\r\n    }\r\n\r\n    private _createSizeGradientTexture() {\r\n        this._createFactorGradientTexture(this._sizeGradients, \"_sizeGradientsTexture\");\r\n    }\r\n\r\n    private _createAngularSpeedGradientTexture() {\r\n        this._createFactorGradientTexture(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\r\n    }\r\n\r\n    private _createVelocityGradientTexture() {\r\n        this._createFactorGradientTexture(this._velocityGradients, \"_velocityGradientsTexture\");\r\n    }\r\n\r\n    private _createLimitVelocityGradientTexture() {\r\n        this._createFactorGradientTexture(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\r\n    }\r\n\r\n    private _createDragGradientTexture() {\r\n        this._createFactorGradientTexture(this._dragGradients, \"_dragGradientsTexture\");\r\n    }\r\n\r\n    private _createColorGradientTexture() {\r\n        if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {\r\n            return;\r\n        }\r\n\r\n        const data = new Uint8Array(this._rawTextureWidth * 4);\r\n        const tmpColor = TmpColors.Color4[0];\r\n\r\n        for (let x = 0; x < this._rawTextureWidth; x++) {\r\n            const ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\r\n                Color4.LerpToRef((<ColorGradient>currentGradient).color1, (<ColorGradient>nextGradient).color1, scale, tmpColor);\r\n                data[x * 4] = tmpColor.r * 255;\r\n                data[x * 4 + 1] = tmpColor.g * 255;\r\n                data[x * 4 + 2] = tmpColor.b * 255;\r\n                data[x * 4 + 3] = tmpColor.a * 255;\r\n            });\r\n        }\r\n\r\n        this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n        this._colorGradientsTexture.name = \"colorGradients\";\r\n    }\r\n\r\n    private _render(blendMode: number, emitterWM: Matrix): number {\r\n        // Enable render effect\r\n        const drawWrapper = this._getWrapper(blendMode);\r\n        const effect = drawWrapper.effect!;\r\n\r\n        this._engine.enableEffect(drawWrapper);\r\n        const viewMatrix = this._scene?.getViewMatrix() || Matrix.IdentityReadOnly;\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", this.defaultProjectionMatrix ?? this._scene!.getProjectionMatrix());\r\n        effect.setTexture(\"diffuseSampler\", this.particleTexture);\r\n        effect.setVector2(\"translationPivot\", this.translationPivot);\r\n        const worldOffset = this.worldOffset.subtractToRef(this._scene?.floatingOriginOffset || Vector3.ZeroReadOnly, TmpVectors.Vector3[0]);\r\n        effect.setVector3(\"worldOffset\", worldOffset);\r\n        if (this.isLocal) {\r\n            effect.setMatrix(\"emitterWM\", emitterWM);\r\n        }\r\n        if (this._colorGradientsTexture) {\r\n            effect.setTexture(\"colorGradientSampler\", this._colorGradientsTexture);\r\n        } else {\r\n            effect.setDirectColor4(\"colorDead\", this.colorDead);\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled && this.particleTexture) {\r\n            const baseSize = this.particleTexture.getBaseSize();\r\n            effect.setFloat3(\"sheetInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);\r\n        }\r\n\r\n        if (this._isBillboardBased && this._scene) {\r\n            const camera = this._scene.activeCamera!;\r\n            effect.setVector3(\"eyePosition\", camera.globalPosition);\r\n        }\r\n\r\n        const defines = effect.defines;\r\n\r\n        if (this._scene) {\r\n            BindClipPlane(effect, this, this._scene);\r\n\r\n            if (this.applyFog) {\r\n                BindFogParameters(this._scene, undefined, effect);\r\n            }\r\n        }\r\n\r\n        if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\r\n            const invView = viewMatrix.clone();\r\n            invView.invert();\r\n            effect.setMatrix(\"invView\", invView);\r\n        }\r\n\r\n        // Log. depth\r\n        if (this.useLogarithmicDepth && this._scene) {\r\n            BindLogDepth(defines, effect, this._scene);\r\n        }\r\n\r\n        // image processing\r\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n            this._imageProcessingConfiguration.bind(effect);\r\n        }\r\n\r\n        // Draw order\r\n        this._setEngineBasedOnBlendMode(blendMode);\r\n\r\n        // Bind source VAO\r\n        this._platform.bindDrawBuffers(this._targetIndex, effect, this._scene?.forceWireframe ? this._linesIndexBufferUseInstancing : null);\r\n\r\n        if (this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable.notifyObservers(effect);\r\n        }\r\n\r\n        // Render\r\n        if (this._scene?.forceWireframe) {\r\n            this._engine.drawElementsType(Constants.MATERIAL_LineStripDrawMode, 0, 10, this._currentActiveCount);\r\n        } else {\r\n            this._engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, this._currentActiveCount);\r\n        }\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n\r\n        if (this._scene?.forceWireframe) {\r\n            this._engine.unbindInstanceAttributes();\r\n        }\r\n\r\n        return this._currentActiveCount;\r\n    }\r\n\r\n    /** @internal */\r\n    public _update(emitterWM?: Matrix): void {\r\n        if (!this.emitter || !this._targetBuffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._recreateUpdateEffect() || this._rebuildingAfterContextLost) {\r\n            return;\r\n        }\r\n\r\n        if (!emitterWM) {\r\n            if ((<AbstractMesh>this.emitter).position) {\r\n                const emitterMesh = <AbstractMesh>this.emitter;\r\n                emitterWM = emitterMesh.getWorldMatrix();\r\n            } else {\r\n                const emitterPosition = <Vector3>this.emitter;\r\n                emitterWM = TmpVectors.Matrix[0];\r\n                Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);\r\n            }\r\n        }\r\n\r\n        const engine = this._engine as Engine;\r\n        const depthWriteState = engine.getDepthWrite();\r\n        engine.setDepthWrite(false);\r\n\r\n        this._platform.preUpdateParticleBuffer();\r\n\r\n        this._updateBuffer.setFloat(\"currentCount\", this._currentActiveCount);\r\n        this._updateBuffer.setFloat(\"timeDelta\", this._timeDelta);\r\n        this._updateBuffer.setFloat(\"stopFactor\", this._stopped ? 0 : 1);\r\n        this._updateBuffer.setInt(\"randomTextureSize\", this._randomTextureSize);\r\n        this._updateBuffer.setFloat2(\"lifeTime\", this.minLifeTime, this.maxLifeTime);\r\n        this._updateBuffer.setFloat2(\"emitPower\", this.minEmitPower, this.maxEmitPower);\r\n        if (!this._colorGradientsTexture) {\r\n            this._updateBuffer.setDirectColor4(\"color1\", this.color1);\r\n            this._updateBuffer.setDirectColor4(\"color2\", this.color2);\r\n        }\r\n        this._updateBuffer.setFloat2(\"sizeRange\", this.minSize, this.maxSize);\r\n        this._updateBuffer.setFloat4(\"scaleRange\", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);\r\n        this._updateBuffer.setFloat4(\"angleRange\", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);\r\n        this._updateBuffer.setVector3(\"gravity\", this.gravity);\r\n        if (this._limitVelocityGradientsTexture) {\r\n            this._updateBuffer.setFloat(\"limitVelocityDamping\", this.limitVelocityDamping);\r\n        }\r\n        if (this.particleEmitterType) {\r\n            this.particleEmitterType.applyToShader(this._updateBuffer);\r\n        }\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._updateBuffer.setFloat4(\"cellInfos\", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed, this.spriteCellLoop ? 1 : 0);\r\n        }\r\n        if (this.noiseTexture) {\r\n            this._updateBuffer.setVector3(\"noiseStrength\", this.noiseStrength);\r\n        }\r\n        if (this._flowMap) {\r\n            const scene = this.getScene()!;\r\n            this._updateBuffer.setFloat(\"flowMapStrength\", this.flowMapStrength);\r\n            this._updateBuffer.setMatrix(\"flowMapProjection\", scene.getTransformMatrix());\r\n        }\r\n\r\n        if (!this.isLocal) {\r\n            this._updateBuffer.setMatrix(\"emitterWM\", emitterWM);\r\n        }\r\n\r\n        this._platform.updateParticleBuffer(this._targetIndex, this._targetBuffer, this._currentActiveCount);\r\n\r\n        // Switch VAOs\r\n        this._targetIndex++;\r\n        if (this._targetIndex === 2) {\r\n            this._targetIndex = 0;\r\n        }\r\n\r\n        // Switch buffers\r\n        const tmpBuffer = this._sourceBuffer;\r\n        this._sourceBuffer = this._targetBuffer;\r\n        this._targetBuffer = tmpBuffer;\r\n\r\n        engine.setDepthWrite(depthWriteState);\r\n    }\r\n\r\n    /**\r\n     * Renders the particle system in its current state\r\n     * @param preWarm defines if the system should only update the particles but not render them\r\n     * @param forceUpdateOnly if true, force to only update the particles and never display them (meaning, even if preWarm=false, when forceUpdateOnly=true the particles won't be displayed)\r\n     * @returns the current number of particles\r\n     */\r\n    public render(preWarm = false, forceUpdateOnly = false): number {\r\n        if (!this._started) {\r\n            return 0;\r\n        }\r\n\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n\r\n        if (!preWarm && this._scene) {\r\n            if (!this._preWarmDone && this.preWarmCycles) {\r\n                for (let index = 0; index < this.preWarmCycles; index++) {\r\n                    this.animate(true);\r\n                    this.render(true, true);\r\n                }\r\n\r\n                this._preWarmDone = true;\r\n            }\r\n\r\n            if (\r\n                this._currentRenderId === this._scene.getRenderId() &&\r\n                (!this._scene.activeCamera || (this._scene.activeCamera && this._currentRenderingCameraUniqueId === this._scene.activeCamera.uniqueId))\r\n            ) {\r\n                return 0;\r\n            }\r\n\r\n            this._currentRenderId = this._scene.getRenderId();\r\n            if (this._scene.activeCamera) {\r\n                this._currentRenderingCameraUniqueId = this._scene.activeCamera.uniqueId;\r\n            }\r\n        }\r\n\r\n        // Get everything ready to render\r\n        this._initialize();\r\n\r\n        if (this.manualEmitCount > -1) {\r\n            this._accumulatedCount += this.manualEmitCount;\r\n            this.manualEmitCount = 0;\r\n        } else {\r\n            this._accumulatedCount += this.emitRate * this._timeDelta;\r\n        }\r\n        if (this._accumulatedCount >= 1) {\r\n            const intPart = this._accumulatedCount | 0;\r\n            this._accumulatedCount -= intPart;\r\n            this._currentActiveCount += intPart;\r\n        }\r\n\r\n        this._currentActiveCount = Math.min(this._maxActiveParticleCount, this._currentActiveCount);\r\n\r\n        if (!this._currentActiveCount) {\r\n            return 0;\r\n        }\r\n\r\n        // Enable update effect\r\n        let emitterWM: Matrix;\r\n        if ((<AbstractMesh>this.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>this.emitter;\r\n            emitterWM = emitterMesh.getWorldMatrix();\r\n        } else {\r\n            const emitterPosition = <Vector3>this.emitter;\r\n            emitterWM = TmpVectors.Matrix[0];\r\n            Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);\r\n        }\r\n\r\n        const engine = this._engine as Engine;\r\n\r\n        if (!this.updateInAnimate) {\r\n            this._update(emitterWM);\r\n        }\r\n\r\n        let outparticles = 0;\r\n        if (!preWarm && !forceUpdateOnly) {\r\n            engine.setState(false);\r\n\r\n            if (this.forceDepthWrite) {\r\n                engine.setDepthWrite(true);\r\n            }\r\n\r\n            if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n                outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY, emitterWM) + this._render(ParticleSystem.BLENDMODE_ADD, emitterWM);\r\n            } else {\r\n                outparticles = this._render(this.blendMode, emitterWM);\r\n            }\r\n\r\n            this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        return outparticles;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the particle system\r\n     */\r\n    public rebuild(): void {\r\n        const checkUpdateEffect = () => {\r\n            if (!this._recreateUpdateEffect() || !this._platform.isUpdateBufferReady()) {\r\n                setTimeout(checkUpdateEffect, 10);\r\n            } else {\r\n                this._initialize(true);\r\n                this._rebuildingAfterContextLost = false;\r\n            }\r\n        };\r\n\r\n        this._createIndexBuffer();\r\n\r\n        this._cachedUpdateDefines = \"\";\r\n        this._platform.contextLost();\r\n        this._rebuildingAfterContextLost = true;\r\n\r\n        checkUpdateEffect();\r\n    }\r\n\r\n    private _releaseBuffers() {\r\n        if (this._buffer0) {\r\n            this._buffer0.dispose();\r\n            (<any>this._buffer0) = null;\r\n        }\r\n        if (this._buffer1) {\r\n            this._buffer1.dispose();\r\n            (<any>this._buffer1) = null;\r\n        }\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            (<any>this._spriteBuffer) = null;\r\n        }\r\n        this._platform.releaseBuffers();\r\n    }\r\n\r\n    /**\r\n     * Disposes the particle system and free the associated resources\r\n     * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\r\n     */\r\n    public dispose(disposeTexture = true): void {\r\n        for (const blendMode in this._drawWrappers) {\r\n            const drawWrapper = this._drawWrappers[blendMode];\r\n            drawWrapper.dispose();\r\n        }\r\n\r\n        this._drawWrappers = {};\r\n\r\n        if (this._scene) {\r\n            const index = this._scene.particleSystems.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene.particleSystems.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._releaseBuffers();\r\n        this._platform.releaseVertexBuffers();\r\n\r\n        for (let i = 0; i < this._renderVertexBuffers.length; ++i) {\r\n            const rvb = this._renderVertexBuffers[i];\r\n            for (const key in rvb) {\r\n                rvb[key].dispose();\r\n            }\r\n        }\r\n\r\n        this._renderVertexBuffers = [];\r\n\r\n        if (this._colorGradientsTexture) {\r\n            this._colorGradientsTexture.dispose();\r\n            (<any>this._colorGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._sizeGradientsTexture) {\r\n            this._sizeGradientsTexture.dispose();\r\n            (<any>this._sizeGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            this._angularSpeedGradientsTexture.dispose();\r\n            (<any>this._angularSpeedGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._velocityGradientsTexture) {\r\n            this._velocityGradientsTexture.dispose();\r\n            (<any>this._velocityGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._limitVelocityGradientsTexture) {\r\n            this._limitVelocityGradientsTexture.dispose();\r\n            (<any>this._limitVelocityGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._dragGradientsTexture) {\r\n            this._dragGradientsTexture.dispose();\r\n            (<any>this._dragGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._randomTexture) {\r\n            this._randomTexture.dispose();\r\n            (<any>this._randomTexture) = null;\r\n        }\r\n\r\n        if (this._randomTexture2) {\r\n            this._randomTexture2.dispose();\r\n            (<any>this._randomTexture2) = null;\r\n        }\r\n\r\n        if (disposeTexture && this.particleTexture) {\r\n            this.particleTexture.dispose();\r\n            this.particleTexture = null;\r\n        }\r\n\r\n        if (disposeTexture && this.noiseTexture) {\r\n            this.noiseTexture.dispose();\r\n            this.noiseTexture = null;\r\n        }\r\n\r\n        // Callback\r\n        this.onStoppedObservable.clear();\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n    /**\r\n     * Clones the particle system.\r\n     * @param name The name of the cloned object\r\n     * @param newEmitter The new emitter to use\r\n     * @param cloneTexture Also clone the textures if true\r\n     * @returns the cloned particle system\r\n     */\r\n    public clone(name: string, newEmitter: any, cloneTexture = false): GPUParticleSystem {\r\n        const custom = { ...this._customWrappers };\r\n        let program: any = null;\r\n        const engine = this._engine as any;\r\n        if (engine.createEffectForParticles) {\r\n            if (this.customShader != null) {\r\n                program = this.customShader;\r\n                const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n                custom[0] = engine.createEffectForParticles(\r\n                    program.shaderPath.fragmentElement,\r\n                    program.shaderOptions.uniforms,\r\n                    program.shaderOptions.samplers,\r\n                    defines,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    this\r\n                );\r\n            }\r\n        }\r\n\r\n        const serialization = this.serialize(cloneTexture);\r\n        const result = GPUParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\r\n        result.name = name;\r\n        result.customShader = program;\r\n        result._customWrappers = custom;\r\n\r\n        if (newEmitter === undefined) {\r\n            newEmitter = this.emitter;\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            result.noiseTexture = this.noiseTexture.clone();\r\n        }\r\n\r\n        result.emitter = newEmitter;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        ParticleSystem._Serialize(serializationObject, this, serializeTexture);\r\n\r\n        serializationObject.activeParticleCount = this.activeParticleCount;\r\n        serializationObject.randomTextureSize = this._randomTextureSize;\r\n        serializationObject.customShader = this.customShader;\r\n\r\n        serializationObject.preventAutoStart = this.preventAutoStart;\r\n        serializationObject.worldOffset = this.worldOffset.asArray();\r\n\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a GPU particle system.\r\n     * @param parsedParticleSystem The JSON object to parse\r\n     * @param sceneOrEngine The scene or the engine to create the particle system in\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns the parsed GPU particle system\r\n     */\r\n    public static Parse(parsedParticleSystem: any, sceneOrEngine: Scene | AbstractEngine, rootUrl: string, doNotStart = false, capacity?: number): GPUParticleSystem {\r\n        const name = parsedParticleSystem.name;\r\n        let engine: AbstractEngine;\r\n        let scene: Nullable<Scene>;\r\n\r\n        if (sceneOrEngine instanceof AbstractEngine) {\r\n            engine = sceneOrEngine;\r\n        } else {\r\n            scene = sceneOrEngine;\r\n            engine = scene.getEngine();\r\n        }\r\n\r\n        const particleSystem = new GPUParticleSystem(\r\n            name,\r\n            { capacity: capacity || parsedParticleSystem.capacity, randomTextureSize: parsedParticleSystem.randomTextureSize },\r\n            sceneOrEngine,\r\n            null,\r\n            parsedParticleSystem.isAnimationSheetEnabled\r\n        );\r\n        particleSystem._rootUrl = rootUrl;\r\n\r\n        if (parsedParticleSystem.customShader && (engine as any).createEffectForParticles) {\r\n            const program = parsedParticleSystem.customShader;\r\n            const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n            const custom: Nullable<Effect> = (engine as any).createEffectForParticles(\r\n                program.shaderPath.fragmentElement,\r\n                program.shaderOptions.uniforms,\r\n                program.shaderOptions.samplers,\r\n                defines,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                particleSystem\r\n            );\r\n            particleSystem.setCustomEffect(custom, 0);\r\n            particleSystem.customShader = program;\r\n        }\r\n\r\n        if (parsedParticleSystem.id) {\r\n            particleSystem.id = parsedParticleSystem.id;\r\n        }\r\n\r\n        if (parsedParticleSystem.activeParticleCount) {\r\n            particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;\r\n        }\r\n\r\n        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\r\n\r\n        if (parsedParticleSystem.worldOffset) {\r\n            particleSystem.worldOffset = Vector3.FromArray(parsedParticleSystem.worldOffset);\r\n        }\r\n\r\n        // Auto start\r\n        if (parsedParticleSystem.preventAutoStart) {\r\n            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\r\n        }\r\n\r\n        if (parsedParticleSystem.metadata) {\r\n            particleSystem.metadata = parsedParticleSystem.metadata;\r\n        }\r\n\r\n        if (!doNotStart && !particleSystem.preventAutoStart) {\r\n            particleSystem.start();\r\n        }\r\n\r\n        return particleSystem;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["name", "shader", "name", "shader", "name", "shader", "name"]
}
