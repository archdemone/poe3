import {
  CustomParticleEmitter
} from "./chunk-EGDANSF7.js";
import {
  ShaderStore
} from "./chunk-FX6MN5HL.js";
import {
  RegisterClass
} from "./chunk-S7NDMBDF.js";

// node_modules/@babylonjs/core/Materials/uniformBufferEffectCommonAccessor.js
var UniformBufferEffectCommonAccessor = class {
  _isUbo(uboOrEffect) {
    return uboOrEffect.addUniform !== void 0;
  }
  constructor(uboOrEffect) {
    if (this._isUbo(uboOrEffect)) {
      this.setMatrix3x3 = uboOrEffect.updateMatrix3x3.bind(uboOrEffect);
      this.setMatrix2x2 = uboOrEffect.updateMatrix2x2.bind(uboOrEffect);
      this.setFloat = uboOrEffect.updateFloat.bind(uboOrEffect);
      this.setFloat2 = uboOrEffect.updateFloat2.bind(uboOrEffect);
      this.setFloat3 = uboOrEffect.updateFloat3.bind(uboOrEffect);
      this.setFloat4 = uboOrEffect.updateFloat4.bind(uboOrEffect);
      this.setFloatArray = uboOrEffect.updateFloatArray.bind(uboOrEffect);
      this.setArray = uboOrEffect.updateArray.bind(uboOrEffect);
      this.setIntArray = uboOrEffect.updateIntArray.bind(uboOrEffect);
      this.setMatrix = uboOrEffect.updateMatrix.bind(uboOrEffect);
      this.setMatrices = uboOrEffect.updateMatrices.bind(uboOrEffect);
      this.setVector3 = uboOrEffect.updateVector3.bind(uboOrEffect);
      this.setVector4 = uboOrEffect.updateVector4.bind(uboOrEffect);
      this.setColor3 = uboOrEffect.updateColor3.bind(uboOrEffect);
      this.setColor4 = uboOrEffect.updateColor4.bind(uboOrEffect);
      this.setDirectColor4 = uboOrEffect.updateDirectColor4.bind(uboOrEffect);
      this.setInt = uboOrEffect.updateInt.bind(uboOrEffect);
      this.setInt2 = uboOrEffect.updateInt2.bind(uboOrEffect);
      this.setInt3 = uboOrEffect.updateInt3.bind(uboOrEffect);
      this.setInt4 = uboOrEffect.updateInt4.bind(uboOrEffect);
    } else {
      this.setMatrix3x3 = uboOrEffect.setMatrix3x3.bind(uboOrEffect);
      this.setMatrix2x2 = uboOrEffect.setMatrix2x2.bind(uboOrEffect);
      this.setFloat = uboOrEffect.setFloat.bind(uboOrEffect);
      this.setFloat2 = uboOrEffect.setFloat2.bind(uboOrEffect);
      this.setFloat3 = uboOrEffect.setFloat3.bind(uboOrEffect);
      this.setFloat4 = uboOrEffect.setFloat4.bind(uboOrEffect);
      this.setFloatArray = uboOrEffect.setFloatArray.bind(uboOrEffect);
      this.setArray = uboOrEffect.setArray.bind(uboOrEffect);
      this.setIntArray = uboOrEffect.setIntArray.bind(uboOrEffect);
      this.setMatrix = uboOrEffect.setMatrix.bind(uboOrEffect);
      this.setMatrices = uboOrEffect.setMatrices.bind(uboOrEffect);
      this.setVector3 = uboOrEffect.setVector3.bind(uboOrEffect);
      this.setVector4 = uboOrEffect.setVector4.bind(uboOrEffect);
      this.setColor3 = uboOrEffect.setColor3.bind(uboOrEffect);
      this.setColor4 = uboOrEffect.setColor4.bind(uboOrEffect);
      this.setDirectColor4 = uboOrEffect.setDirectColor4.bind(uboOrEffect);
      this.setInt = uboOrEffect.setInt.bind(uboOrEffect);
      this.setInt2 = uboOrEffect.setInt2.bind(uboOrEffect);
      this.setInt3 = uboOrEffect.setInt3.bind(uboOrEffect);
      this.setInt4 = uboOrEffect.setInt4.bind(uboOrEffect);
    }
  }
};

// node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.fragment.js
var name = "gpuUpdateParticlesPixelShader";
var shader = `#version 300 es
void main() {discard;}
`;
if (!ShaderStore.ShadersStore[name]) {
  ShaderStore.ShadersStore[name] = shader;
}

// node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.vertex.js
var name2 = "gpuUpdateParticlesVertexShader";
var shader2 = `#version 300 es
#define PI 3.14159
uniform float currentCount;uniform float timeDelta;uniform float stopFactor;
#ifndef LOCAL
uniform mat4 emitterWM;
#endif
uniform vec2 lifeTime;uniform vec2 emitPower;uniform vec2 sizeRange;uniform vec4 scaleRange;
#ifdef FLOWMAP
uniform mat4 flowMapProjection;uniform float flowMapStrength;uniform sampler2D flowMapSampler;
#endif
#ifndef COLORGRADIENTS
uniform vec4 color1;uniform vec4 color2;
#endif
uniform vec3 gravity;uniform sampler2D randomSampler;uniform sampler2D randomSampler2;uniform vec4 angleRange;
#ifdef BOXEMITTER
uniform vec3 direction1;uniform vec3 direction2;uniform vec3 minEmitBox;uniform vec3 maxEmitBox;
#endif
#ifdef POINTEMITTER
uniform vec3 direction1;uniform vec3 direction2;
#endif
#ifdef HEMISPHERICEMITTER
uniform float radius;uniform float radiusRange;uniform float directionRandomizer;
#endif
#ifdef SPHEREEMITTER
uniform float radius;uniform float radiusRange;
#ifdef DIRECTEDSPHEREEMITTER
uniform vec3 direction1;uniform vec3 direction2;
#else
uniform float directionRandomizer;
#endif
#endif
#ifdef CYLINDEREMITTER
uniform float radius;uniform float height;uniform float radiusRange;
#ifdef DIRECTEDCYLINDEREMITTER
uniform vec3 direction1;uniform vec3 direction2;
#else
uniform float directionRandomizer;
#endif
#endif
#ifdef CONEEMITTER
uniform vec2 radius;uniform float coneAngle;uniform vec2 height;
#ifdef DIRECTEDCONEEMITTER
uniform vec3 direction1;uniform vec3 direction2;
#else
uniform float directionRandomizer;
#endif
#endif
in vec3 position;
#ifdef CUSTOMEMITTER
in vec3 initialPosition;
#endif
in float age;in float life;in vec4 seed;in vec3 size;
#ifndef COLORGRADIENTS
in vec4 color;
#endif
in vec3 direction;
#ifndef BILLBOARD
in vec3 initialDirection;
#endif
#ifdef ANGULARSPEEDGRADIENTS
in float angle;
#else
in vec2 angle;
#endif
#ifdef ANIMATESHEET
in float cellIndex;
#ifdef ANIMATESHEETRANDOMSTART
in float cellStartOffset;
#endif
#endif
#ifdef NOISE
in vec3 noiseCoordinates1;in vec3 noiseCoordinates2;
#endif
out vec3 outPosition;
#ifdef CUSTOMEMITTER
out vec3 outInitialPosition;
#endif
out float outAge;out float outLife;out vec4 outSeed;out vec3 outSize;
#ifndef COLORGRADIENTS
out vec4 outColor;
#endif
out vec3 outDirection;
#ifndef BILLBOARD
out vec3 outInitialDirection;
#endif
#ifdef ANGULARSPEEDGRADIENTS
out float outAngle;
#else
out vec2 outAngle;
#endif
#ifdef ANIMATESHEET
out float outCellIndex;
#ifdef ANIMATESHEETRANDOMSTART
out float outCellStartOffset;
#endif
#endif
#ifdef NOISE
out vec3 outNoiseCoordinates1;out vec3 outNoiseCoordinates2;
#endif
#ifdef SIZEGRADIENTS
uniform sampler2D sizeGradientSampler;
#endif 
#ifdef ANGULARSPEEDGRADIENTS
uniform sampler2D angularSpeedGradientSampler;
#endif 
#ifdef VELOCITYGRADIENTS
uniform sampler2D velocityGradientSampler;
#endif
#ifdef LIMITVELOCITYGRADIENTS
uniform sampler2D limitVelocityGradientSampler;uniform float limitVelocityDamping;
#endif
#ifdef DRAGGRADIENTS
uniform sampler2D dragGradientSampler;
#endif
#ifdef NOISE
uniform vec3 noiseStrength;uniform sampler2D noiseSampler;
#endif
#ifdef ANIMATESHEET
uniform vec4 cellInfos;
#endif
vec3 getRandomVec3(float offset) {return texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;}
vec4 getRandomVec4(float offset) {return texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));}
void main() {float newAge=age+timeDelta; 
if (newAge>=life && stopFactor != 0.) {vec3 newPosition;vec3 newDirection;vec4 randoms=getRandomVec4(seed.x);outLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;outAge=newAge-life;outSeed=seed;
#ifdef SIZEGRADIENTS 
outSize.x=texture(sizeGradientSampler,vec2(0,0)).r;
#else
outSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;
#endif
outSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;outSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a; 
#ifndef COLORGRADIENTS
outColor=color1+(color2-color1)*randoms.b;
#endif
#ifndef ANGULARSPEEDGRADIENTS 
outAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;outAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;
#else
outAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;
#endif 
#ifdef POINTEMITTER
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);newPosition=vec3(0,0,0);newDirection=direction1+(direction2-direction1)*randoms3;
#elif defined(BOXEMITTER)
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);newPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;newDirection=direction1+(direction2-direction1)*randoms3; 
#elif defined(HEMISPHERICEMITTER)
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);float phi=2.0*PI*randoms2.x;float theta=acos(2.0*randoms2.y-1.0);float randX=cos(phi)*sin(theta);float randY=cos(theta);float randZ=sin(phi)*sin(theta);newPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);newDirection=newPosition+directionRandomizer*randoms3; 
#elif defined(SPHEREEMITTER)
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);float phi=2.0*PI*randoms2.x;float theta=acos(2.0*randoms2.y-1.0);float randX=cos(phi)*sin(theta);float randY=cos(theta);float randZ=sin(phi)*sin(theta);newPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);
#ifdef DIRECTEDSPHEREEMITTER
newDirection=normalize(direction1+(direction2-direction1)*randoms3);
#else
newDirection=normalize(newPosition+directionRandomizer*randoms3);
#endif
#elif defined(CYLINDEREMITTER)
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);float yPos=(randoms2.x-0.5)*height;float angle=randoms2.y*PI*2.;float inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));float positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));float xPos=positionRadius*cos(angle);float zPos=positionRadius*sin(angle);newPosition=vec3(xPos,yPos,zPos);
#ifdef DIRECTEDCYLINDEREMITTER
newDirection=direction1+(direction2-direction1)*randoms3;
#else
angle=angle+((randoms3.x-0.5)*PI)*directionRandomizer;newDirection=vec3(cos(angle),(randoms3.y-0.5)*directionRandomizer,sin(angle));newDirection=normalize(newDirection);
#endif
#elif defined(CONEEMITTER)
vec3 randoms2=getRandomVec3(seed.y);float s=2.0*PI*randoms2.x;
#ifdef CONEEMITTERSPAWNPOINT
float h=0.0001;
#else
float h=randoms2.y*height.y;h=1.-h*h; 
#endif
float lRadius=radius.x-radius.x*randoms2.z*radius.y;lRadius=lRadius*h;float randX=lRadius*sin(s);float randZ=lRadius*cos(s);float randY=h *height.x;newPosition=vec3(randX,randY,randZ); 
vec3 randoms3=getRandomVec3(seed.z);
#ifdef DIRECTEDCONEEMITTER
newDirection=direction1+(direction2-direction1)*randoms3;
#else
if (abs(cos(coneAngle))==1.0) {newDirection=vec3(0.,1.0,0.);} else {newDirection=normalize(newPosition+directionRandomizer*randoms3); }
#endif
#elif defined(CUSTOMEMITTER)
newPosition=initialPosition;outInitialPosition=initialPosition;
#else 
newPosition=vec3(0.,0.,0.);newDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));
#endif
float power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;
#ifdef LOCAL
outPosition=newPosition;
#else
outPosition=(emitterWM*vec4(newPosition,1.)).xyz;
#endif
#ifdef CUSTOMEMITTER
outDirection=direction;
#ifndef BILLBOARD 
outInitialDirection=direction;
#endif
#else
#ifdef LOCAL
vec3 initial=newDirection;
#else 
vec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;
#endif
outDirection=initial*power;
#ifndef BILLBOARD 
outInitialDirection=initial;
#endif
#endif
#ifdef ANIMATESHEET 
outCellIndex=cellInfos.x;
#ifdef ANIMATESHEETRANDOMSTART
outCellStartOffset=randoms.a*outLife;
#endif 
#endif
#ifdef NOISE
outNoiseCoordinates1=noiseCoordinates1;outNoiseCoordinates2=noiseCoordinates2;
#endif
} else {float directionScale=timeDelta;outAge=newAge;float ageGradient=newAge/life;
#ifdef VELOCITYGRADIENTS
directionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;
#endif
#ifdef DRAGGRADIENTS
directionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;
#endif
#if defined(CUSTOMEMITTER)
outPosition=position+(direction-position)*ageGradient; 
outInitialPosition=initialPosition;
#else
outPosition=position+direction*directionScale;
#endif
outLife=life;outSeed=seed;
#ifndef COLORGRADIENTS 
outColor=color;
#endif
#ifdef SIZEGRADIENTS
outSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;outSize.yz=size.yz;
#else
outSize=size;
#endif 
#ifndef BILLBOARD 
outInitialDirection=initialDirection;
#endif
#ifdef CUSTOMEMITTER
outDirection=direction;
#else
vec3 updatedDirection=direction+gravity*timeDelta;
#ifdef FLOWMAP
vec4 clipSpace=(flowMapProjection*vec4(position,1.));vec3 ndcSpace=clipSpace.xyz/clipSpace.w;vec2 flowMapUV=ndcSpace.xy*0.5+0.5;vec4 flowMapValue=texture(flowMapSampler,flowMapUV);vec3 flowMapDirection=(flowMapValue.xyz*2.0-1.0)*flowMapValue.w;updatedDirection+=flowMapDirection*timeDelta*flowMapStrength;
#endif
#ifdef LIMITVELOCITYGRADIENTS
float limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;float currentVelocity=length(updatedDirection);if (currentVelocity>limitVelocity) {updatedDirection=updatedDirection*limitVelocityDamping;}
#endif
outDirection=updatedDirection;
#ifdef NOISE
float fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;float fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;float fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;vec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;outDirection=outDirection+force*timeDelta;outNoiseCoordinates1=noiseCoordinates1;outNoiseCoordinates2=noiseCoordinates2;
#endif 
#endif 
#ifdef ANGULARSPEEDGRADIENTS
float angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;outAngle=angle+angularSpeed*timeDelta;
#else
outAngle=vec2(angle.x+angle.y*timeDelta,angle.y);
#endif
#ifdef ANIMATESHEET 
float offsetAge=outAge;float dist=cellInfos.y-cellInfos.x;
#ifdef ANIMATESHEETRANDOMSTART
outCellStartOffset=cellStartOffset;offsetAge+=cellStartOffset;
#else
float cellStartOffset=0.;
#endif 
float ratio=0.;if (cellInfos.w==1.0) {ratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);}
else {ratio=clamp(cellStartOffset+cellInfos.z*offsetAge/life,0.,1.0);}
outCellIndex=float(int(cellInfos.x+ratio*dist));
#endif
}}`;
if (!ShaderStore.ShadersStore[name2]) {
  ShaderStore.ShadersStore[name2] = shader2;
}

// node_modules/@babylonjs/core/Particles/webgl2ParticleSystem.js
var WebGL2ParticleSystem = class {
  /** @internal */
  constructor(parent, engine) {
    this._renderVAO = [];
    this._updateVAO = [];
    this.alignDataInBuffer = false;
    this._parent = parent;
    this._engine = engine;
    this._updateEffectOptions = {
      attributes: [
        "position",
        "initialPosition",
        "age",
        "life",
        "seed",
        "size",
        "color",
        "direction",
        "initialDirection",
        "angle",
        "cellIndex",
        "cellStartOffset",
        "noiseCoordinates1",
        "noiseCoordinates2"
      ],
      uniformsNames: [
        "currentCount",
        "timeDelta",
        "emitterWM",
        "lifeTime",
        "color1",
        "color2",
        "sizeRange",
        "scaleRange",
        "gravity",
        "emitPower",
        "direction1",
        "direction2",
        "minEmitBox",
        "maxEmitBox",
        "radius",
        "directionRandomizer",
        "height",
        "coneAngle",
        "stopFactor",
        "angleRange",
        "radiusRange",
        "cellInfos",
        "noiseStrength",
        "limitVelocityDamping",
        "flowMapProjection",
        "flowMapStrength"
      ],
      uniformBuffersNames: [],
      samplers: [
        "randomSampler",
        "randomSampler2",
        "sizeGradientSampler",
        "angularSpeedGradientSampler",
        "velocityGradientSampler",
        "limitVelocityGradientSampler",
        "noiseSampler",
        "dragGradientSampler",
        "flowMapSampler"
      ],
      defines: "",
      fallbacks: null,
      onCompiled: null,
      onError: null,
      indexParameters: null,
      maxSimultaneousLights: 0,
      transformFeedbackVaryings: []
    };
  }
  /** @internal */
  contextLost() {
    this._updateEffect = void 0;
    this._renderVAO.length = 0;
    this._updateVAO.length = 0;
  }
  /** @internal */
  isUpdateBufferCreated() {
    return !!this._updateEffect;
  }
  /** @internal */
  isUpdateBufferReady() {
    var _a;
    return ((_a = this._updateEffect) == null ? void 0 : _a.isReady()) ?? false;
  }
  /** @internal */
  createUpdateBuffer(defines) {
    this._updateEffectOptions.transformFeedbackVaryings = ["outPosition"];
    this._updateEffectOptions.transformFeedbackVaryings.push("outAge");
    this._updateEffectOptions.transformFeedbackVaryings.push("outSize");
    this._updateEffectOptions.transformFeedbackVaryings.push("outLife");
    this._updateEffectOptions.transformFeedbackVaryings.push("outSeed");
    this._updateEffectOptions.transformFeedbackVaryings.push("outDirection");
    if (this._parent.particleEmitterType instanceof CustomParticleEmitter) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outInitialPosition");
    }
    if (!this._parent._colorGradientsTexture) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outColor");
    }
    if (!this._parent._isBillboardBased) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outInitialDirection");
    }
    if (this._parent.noiseTexture) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outNoiseCoordinates1");
      this._updateEffectOptions.transformFeedbackVaryings.push("outNoiseCoordinates2");
    }
    this._updateEffectOptions.transformFeedbackVaryings.push("outAngle");
    if (this._parent.isAnimationSheetEnabled) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outCellIndex");
      if (this._parent.spriteRandomStartCell) {
        this._updateEffectOptions.transformFeedbackVaryings.push("outCellStartOffset");
      }
    }
    this._updateEffectOptions.defines = defines;
    this._updateEffect = this._engine.createEffect("gpuUpdateParticles", this._updateEffectOptions, this._engine);
    return new UniformBufferEffectCommonAccessor(this._updateEffect);
  }
  /** @internal */
  createVertexBuffers(updateBuffer, renderVertexBuffers) {
    this._updateVAO.push(this._createUpdateVAO(updateBuffer));
    this._renderVAO.push(this._engine.recordVertexArrayObject(renderVertexBuffers, null, this._parent._getWrapper(this._parent.blendMode).effect));
    this._engine.bindArrayBuffer(null);
    this._renderVertexBuffers = renderVertexBuffers;
  }
  /** @internal */
  createParticleBuffer(data) {
    return data;
  }
  /** @internal */
  bindDrawBuffers(index, effect, indexBuffer) {
    if (indexBuffer) {
      this._engine.bindBuffers(this._renderVertexBuffers, indexBuffer, effect);
    } else {
      this._engine.bindVertexArrayObject(this._renderVAO[index], null);
    }
  }
  /** @internal */
  preUpdateParticleBuffer() {
    const engine = this._engine;
    this._engine.enableEffect(this._updateEffect);
    if (!engine.setState) {
      throw new Error("GPU particles cannot work without a full Engine. ThinEngine is not supported");
    }
  }
  /** @internal */
  updateParticleBuffer(index, targetBuffer, currentActiveCount) {
    this._updateEffect.setTexture("randomSampler", this._parent._randomTexture);
    this._updateEffect.setTexture("randomSampler2", this._parent._randomTexture2);
    if (this._parent._flowMap) {
      this._updateEffect.setTexture("flowMapSampler", this._parent._flowMap);
    }
    if (this._parent._sizeGradientsTexture) {
      this._updateEffect.setTexture("sizeGradientSampler", this._parent._sizeGradientsTexture);
    }
    if (this._parent._angularSpeedGradientsTexture) {
      this._updateEffect.setTexture("angularSpeedGradientSampler", this._parent._angularSpeedGradientsTexture);
    }
    if (this._parent._velocityGradientsTexture) {
      this._updateEffect.setTexture("velocityGradientSampler", this._parent._velocityGradientsTexture);
    }
    if (this._parent._limitVelocityGradientsTexture) {
      this._updateEffect.setTexture("limitVelocityGradientSampler", this._parent._limitVelocityGradientsTexture);
    }
    if (this._parent._dragGradientsTexture) {
      this._updateEffect.setTexture("dragGradientSampler", this._parent._dragGradientsTexture);
    }
    if (this._parent.noiseTexture) {
      this._updateEffect.setTexture("noiseSampler", this._parent.noiseTexture);
    }
    this._engine.bindVertexArrayObject(this._updateVAO[index], null);
    const engine = this._engine;
    engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());
    engine.setRasterizerState(false);
    engine.beginTransformFeedback(true);
    engine.drawArraysType(3, 0, currentActiveCount);
    engine.endTransformFeedback();
    engine.setRasterizerState(true);
    engine.bindTransformFeedbackBuffer(null);
  }
  /** @internal */
  releaseBuffers() {
  }
  /** @internal */
  releaseVertexBuffers() {
    for (let index = 0; index < this._updateVAO.length; index++) {
      this._engine.releaseVertexArrayObject(this._updateVAO[index]);
    }
    this._updateVAO.length = 0;
    for (let index = 0; index < this._renderVAO.length; index++) {
      this._engine.releaseVertexArrayObject(this._renderVAO[index]);
    }
    this._renderVAO.length = 0;
  }
  _createUpdateVAO(source) {
    const updateVertexBuffers = {};
    updateVertexBuffers["position"] = source.createVertexBuffer("position", 0, 3);
    let offset = 3;
    updateVertexBuffers["age"] = source.createVertexBuffer("age", offset, 1);
    offset += 1;
    updateVertexBuffers["size"] = source.createVertexBuffer("size", offset, 3);
    offset += 3;
    updateVertexBuffers["life"] = source.createVertexBuffer("life", offset, 1);
    offset += 1;
    updateVertexBuffers["seed"] = source.createVertexBuffer("seed", offset, 4);
    offset += 4;
    updateVertexBuffers["direction"] = source.createVertexBuffer("direction", offset, 3);
    offset += 3;
    if (this._parent.particleEmitterType instanceof CustomParticleEmitter) {
      updateVertexBuffers["initialPosition"] = source.createVertexBuffer("initialPosition", offset, 3);
      offset += 3;
    }
    if (!this._parent._colorGradientsTexture) {
      updateVertexBuffers["color"] = source.createVertexBuffer("color", offset, 4);
      offset += 4;
    }
    if (!this._parent._isBillboardBased) {
      updateVertexBuffers["initialDirection"] = source.createVertexBuffer("initialDirection", offset, 3);
      offset += 3;
    }
    if (this._parent.noiseTexture) {
      updateVertexBuffers["noiseCoordinates1"] = source.createVertexBuffer("noiseCoordinates1", offset, 3);
      offset += 3;
      updateVertexBuffers["noiseCoordinates2"] = source.createVertexBuffer("noiseCoordinates2", offset, 3);
      offset += 3;
    }
    if (this._parent._angularSpeedGradientsTexture) {
      updateVertexBuffers["angle"] = source.createVertexBuffer("angle", offset, 1);
      offset += 1;
    } else {
      updateVertexBuffers["angle"] = source.createVertexBuffer("angle", offset, 2);
      offset += 2;
    }
    if (this._parent._isAnimationSheetEnabled) {
      updateVertexBuffers["cellIndex"] = source.createVertexBuffer("cellIndex", offset, 1);
      offset += 1;
      if (this._parent.spriteRandomStartCell) {
        updateVertexBuffers["cellStartOffset"] = source.createVertexBuffer("cellStartOffset", offset, 1);
        offset += 1;
      }
    }
    const vao = this._engine.recordVertexArrayObject(updateVertexBuffers, null, this._updateEffect);
    this._engine.bindArrayBuffer(null);
    return vao;
  }
};
RegisterClass("BABYLON.WebGL2ParticleSystem", WebGL2ParticleSystem);

export {
  UniformBufferEffectCommonAccessor,
  WebGL2ParticleSystem
};
//# sourceMappingURL=chunk-6S4ZDA7T.js.map
