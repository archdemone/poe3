import {
  VertexBuffer
} from "./chunk-2PJUNA7K.js";
import {
  Matrix,
  TmpVectors,
  Vector2,
  Vector3
} from "./chunk-MBRMNX5M.js";
import {
  BuildArray,
  Epsilon
} from "./chunk-KA4NMM3C.js";

// node_modules/@babylonjs/core/Collisions/pickingInfo.js
var PickingInfo = class {
  constructor() {
    this.hit = false;
    this.distance = 0;
    this.pickedPoint = null;
    this.pickedMesh = null;
    this.bu = 0;
    this.bv = 0;
    this.faceId = -1;
    this.subMeshFaceId = -1;
    this.subMeshId = 0;
    this.pickedSprite = null;
    this.thinInstanceIndex = -1;
    this.ray = null;
    this.originMesh = null;
    this.aimTransform = null;
    this.gripTransform = null;
  }
  /**
   * Gets the normal corresponding to the face the pick collided with
   * @param useWorldCoordinates If the resulting normal should be relative to the world (default: false)
   * @param useVerticesNormals If the vertices normals should be used to calculate the normal instead of the normal map (default: true)
   * @returns The normal corresponding to the face the pick collided with
   * @remarks Note that the returned normal will always point towards the picking ray.
   */
  getNormal(useWorldCoordinates = false, useVerticesNormals = true) {
    if (!this.pickedMesh || useVerticesNormals && !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      return null;
    }
    let indices = this.pickedMesh.getIndices();
    if ((indices == null ? void 0 : indices.length) === 0) {
      indices = null;
    }
    let result;
    const tmp0 = TmpVectors.Vector3[0];
    const tmp1 = TmpVectors.Vector3[1];
    const tmp2 = TmpVectors.Vector3[2];
    if (useVerticesNormals) {
      const normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);
      let normal0 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3] * 3, tmp0) : tmp0.copyFromFloats(normals[this.faceId * 3 * 3], normals[this.faceId * 3 * 3 + 1], normals[this.faceId * 3 * 3 + 2]);
      let normal1 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 1] * 3, tmp1) : tmp1.copyFromFloats(normals[(this.faceId * 3 + 1) * 3], normals[(this.faceId * 3 + 1) * 3 + 1], normals[(this.faceId * 3 + 1) * 3 + 2]);
      let normal2 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 2] * 3, tmp2) : tmp2.copyFromFloats(normals[(this.faceId * 3 + 2) * 3], normals[(this.faceId * 3 + 2) * 3 + 1], normals[(this.faceId * 3 + 2) * 3 + 2]);
      normal0 = normal0.scale(this.bu);
      normal1 = normal1.scale(this.bv);
      normal2 = normal2.scale(1 - this.bu - this.bv);
      result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);
    } else {
      const positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);
      const vertex1 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3] * 3, tmp0) : tmp0.copyFromFloats(positions[this.faceId * 3 * 3], positions[this.faceId * 3 * 3 + 1], positions[this.faceId * 3 * 3 + 2]);
      const vertex2 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 1] * 3, tmp1) : tmp1.copyFromFloats(positions[(this.faceId * 3 + 1) * 3], positions[(this.faceId * 3 + 1) * 3 + 1], positions[(this.faceId * 3 + 1) * 3 + 2]);
      const vertex3 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 2] * 3, tmp2) : tmp2.copyFromFloats(positions[(this.faceId * 3 + 2) * 3], positions[(this.faceId * 3 + 2) * 3 + 1], positions[(this.faceId * 3 + 2) * 3 + 2]);
      const p1p2 = vertex1.subtract(vertex2);
      const p3p2 = vertex3.subtract(vertex2);
      result = Vector3.Cross(p1p2, p3p2);
    }
    const transformNormalToWorld = (pickedMesh, n) => {
      if (this.thinInstanceIndex !== -1) {
        const tm = pickedMesh.thinInstanceGetWorldMatrices()[this.thinInstanceIndex];
        if (tm) {
          Vector3.TransformNormalToRef(n, tm, n);
        }
      }
      let wm = pickedMesh.getWorldMatrix();
      if (pickedMesh.nonUniformScaling) {
        TmpVectors.Matrix[0].copyFrom(wm);
        wm = TmpVectors.Matrix[0];
        wm.setTranslationFromFloats(0, 0, 0);
        wm.invert();
        wm.transposeToRef(TmpVectors.Matrix[1]);
        wm = TmpVectors.Matrix[1];
      }
      Vector3.TransformNormalToRef(n, wm, n);
    };
    if (useWorldCoordinates) {
      transformNormalToWorld(this.pickedMesh, result);
    }
    if (this.ray) {
      const normalForDirectionChecking = TmpVectors.Vector3[0].copyFrom(result);
      if (!useWorldCoordinates) {
        transformNormalToWorld(this.pickedMesh, normalForDirectionChecking);
      }
      if (Vector3.Dot(normalForDirectionChecking, this.ray.direction) > 0) {
        result.negateInPlace();
      }
    }
    result.normalize();
    return result;
  }
  /**
   * Gets the texture coordinates of where the pick occurred
   * @param uvSet The UV set to use to calculate the texture coordinates (default: VertexBuffer.UVKind)
   * @returns The vector containing the coordinates of the texture
   */
  getTextureCoordinates(uvSet = VertexBuffer.UVKind) {
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(uvSet)) {
      return null;
    }
    const indices = this.pickedMesh.getIndices();
    if (!indices) {
      return null;
    }
    const uvs = this.pickedMesh.getVerticesData(uvSet);
    if (!uvs) {
      return null;
    }
    let uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);
    let uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);
    let uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);
    uv0 = uv0.scale(this.bu);
    uv1 = uv1.scale(this.bv);
    uv2 = uv2.scale(1 - this.bu - this.bv);
    return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);
  }
};

// node_modules/@babylonjs/core/Culling/boundingBox.js
var BoundingBox = class _BoundingBox {
  /**
   * Creates a new bounding box
   * @param min defines the minimum vector (in local space)
   * @param max defines the maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  constructor(min, max, worldMatrix) {
    this.vectors = BuildArray(8, Vector3.Zero);
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.extendSize = Vector3.Zero();
    this.extendSizeWorld = Vector3.Zero();
    this.directions = BuildArray(3, Vector3.Zero);
    this.vectorsWorld = BuildArray(8, Vector3.Zero);
    this.minimumWorld = Vector3.Zero();
    this.maximumWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this._drawWrapperFront = null;
    this._drawWrapperBack = null;
    this.reConstruct(min, max, worldMatrix);
  }
  // Methods
  /**
   * Recreates the entire bounding box from scratch as if we call the constructor in place
   * @param min defines the new minimum vector (in local space)
   * @param max defines the new maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  reConstruct(min, max, worldMatrix) {
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    const vectors = this.vectors;
    this.minimum.copyFromFloats(minX, minY, minZ);
    this.maximum.copyFromFloats(maxX, maxY, maxZ);
    vectors[0].copyFromFloats(minX, minY, minZ);
    vectors[1].copyFromFloats(maxX, maxY, maxZ);
    vectors[2].copyFromFloats(maxX, minY, minZ);
    vectors[3].copyFromFloats(minX, maxY, minZ);
    vectors[4].copyFromFloats(minX, minY, maxZ);
    vectors[5].copyFromFloats(maxX, maxY, minZ);
    vectors[6].copyFromFloats(minX, maxY, maxZ);
    vectors[7].copyFromFloats(maxX, minY, maxZ);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);
    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;
    this._update(this._worldMatrix);
  }
  /**
   * Scale the current bounding box by applying a scale factor
   * @param factor defines the scale factor to apply
   * @returns the current bounding box
   */
  scale(factor) {
    const tmpVectors = _BoundingBox._TmpVector3;
    const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);
    const len = diff.length();
    diff.normalizeFromLength(len);
    const distance = len * factor;
    const newRadius = diff.scaleInPlace(distance * 0.5);
    const min = this.center.subtractToRef(newRadius, tmpVectors[1]);
    const max = this.center.addToRef(newRadius, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  }
  /**
   * Gets the world matrix of the bounding box
   * @returns a matrix
   */
  getWorldMatrix() {
    return this._worldMatrix;
  }
  /**
   * @internal
   */
  _update(world) {
    const minWorld = this.minimumWorld;
    const maxWorld = this.maximumWorld;
    const directions = this.directions;
    const vectorsWorld = this.vectorsWorld;
    const vectors = this.vectors;
    if (!world.isIdentity()) {
      minWorld.setAll(Number.MAX_VALUE);
      maxWorld.setAll(-Number.MAX_VALUE);
      for (let index = 0; index < 8; ++index) {
        const v = vectorsWorld[index];
        Vector3.TransformCoordinatesToRef(vectors[index], world, v);
        minWorld.minimizeInPlace(v);
        maxWorld.maximizeInPlace(v);
      }
      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);
      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);
    } else {
      minWorld.copyFrom(this.minimum);
      maxWorld.copyFrom(this.maximum);
      for (let index = 0; index < 8; ++index) {
        vectorsWorld[index].copyFrom(vectors[index]);
      }
      this.extendSizeWorld.copyFrom(this.extendSize);
      this.centerWorld.copyFrom(this.center);
    }
    Vector3.FromArrayToRef(world.m, 0, directions[0]);
    Vector3.FromArrayToRef(world.m, 4, directions[1]);
    Vector3.FromArrayToRef(world.m, 8, directions[2]);
    this._worldMatrix = world;
  }
  /**
   * Tests if the bounding box is intersecting the frustum planes
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an intersection
   */
  isInFrustum(frustumPlanes) {
    return _BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);
  }
  /**
   * Tests if the bounding box is entirely inside the frustum planes
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an inclusion
   */
  isCompletelyInFrustum(frustumPlanes) {
    return _BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);
  }
  /**
   * Tests if a point is inside the bounding box
   * @param point defines the point to test
   * @returns true if the point is inside the bounding box
   */
  intersectsPoint(point) {
    const min = this.minimumWorld;
    const max = this.maximumWorld;
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    const pointX = point.x, pointY = point.y, pointZ = point.z;
    const delta = -Epsilon;
    if (maxX - pointX < delta || delta > pointX - minX) {
      return false;
    }
    if (maxY - pointY < delta || delta > pointY - minY) {
      return false;
    }
    if (maxZ - pointZ < delta || delta > pointZ - minZ) {
      return false;
    }
    return true;
  }
  /**
   * Tests if the bounding box intersects with a bounding sphere
   * @param sphere defines the sphere to test
   * @returns true if there is an intersection
   */
  intersectsSphere(sphere) {
    return _BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);
  }
  /**
   * Tests if the bounding box intersects with a box defined by a min and max vectors
   * @param min defines the min vector to use
   * @param max defines the max vector to use
   * @returns true if there is an intersection
   */
  intersectsMinMax(min, max) {
    const myMin = this.minimumWorld;
    const myMax = this.maximumWorld;
    const myMinX = myMin.x, myMinY = myMin.y, myMinZ = myMin.z, myMaxX = myMax.x, myMaxY = myMax.y, myMaxZ = myMax.z;
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    if (myMaxX < minX || myMinX > maxX) {
      return false;
    }
    if (myMaxY < minY || myMinY > maxY) {
      return false;
    }
    if (myMaxZ < minZ || myMinZ > maxZ) {
      return false;
    }
    return true;
  }
  /**
   * Disposes the resources of the class
   */
  dispose() {
    var _a, _b;
    (_a = this._drawWrapperFront) == null ? void 0 : _a.dispose();
    (_b = this._drawWrapperBack) == null ? void 0 : _b.dispose();
  }
  // Statics
  /**
   * Tests if two bounding boxes are intersections
   * @param box0 defines the first box to test
   * @param box1 defines the second box to test
   * @returns true if there is an intersection
   */
  static Intersects(box0, box1) {
    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);
  }
  /**
   * Tests if a bounding box defines by a min/max vectors intersects a sphere
   * @param minPoint defines the minimum vector of the bounding box
   * @param maxPoint defines the maximum vector of the bounding box
   * @param sphereCenter defines the sphere center
   * @param sphereRadius defines the sphere radius
   * @returns true if there is an intersection
   */
  static IntersectsSphere(minPoint, maxPoint, sphereCenter, sphereRadius) {
    const vector = _BoundingBox._TmpVector3[0];
    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);
    const num = Vector3.DistanceSquared(sphereCenter, vector);
    return num <= sphereRadius * sphereRadius;
  }
  /**
   * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes
   * @param boundingVectors defines an array of 8 vectors representing a bounding box
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an inclusion
   */
  static IsCompletelyInFrustum(boundingVectors, frustumPlanes) {
    for (let p = 0; p < 6; ++p) {
      const frustumPlane = frustumPlanes[p];
      for (let i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Tests if a bounding box defined with 8 vectors intersects frustum planes
   * @param boundingVectors defines an array of 8 vectors representing a bounding box
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an intersection
   */
  static IsInFrustum(boundingVectors, frustumPlanes) {
    for (let p = 0; p < 6; ++p) {
      let canReturnFalse = true;
      const frustumPlane = frustumPlanes[p];
      for (let i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {
          canReturnFalse = false;
          break;
        }
      }
      if (canReturnFalse) {
        return false;
      }
    }
    return true;
  }
};
BoundingBox._TmpVector3 = BuildArray(3, Vector3.Zero);

// node_modules/@babylonjs/core/Culling/boundingSphere.js
var BoundingSphere = class _BoundingSphere {
  /**
   * Creates a new bounding sphere
   * @param min defines the minimum vector (in local space)
   * @param max defines the maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  constructor(min, max, worldMatrix) {
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this.reConstruct(min, max, worldMatrix);
  }
  /**
   * Recreates the entire bounding sphere from scratch as if we call the constructor in place
   * @param min defines the new minimum vector (in local space)
   * @param max defines the new maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  reConstruct(min, max, worldMatrix) {
    this.minimum.copyFrom(min);
    this.maximum.copyFrom(max);
    const distance = Vector3.Distance(min, max);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    this.radius = distance * 0.5;
    this._update(worldMatrix || Matrix.IdentityReadOnly);
  }
  /**
   * Scale the current bounding sphere by applying a scale factor
   * @param factor defines the scale factor to apply
   * @returns the current bounding box
   */
  scale(factor) {
    const newRadius = this.radius * factor;
    const tmpVectors = _BoundingSphere._TmpVector3;
    const tempRadiusVector = tmpVectors[0].setAll(newRadius);
    const min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);
    const max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  }
  /**
   * Gets the world matrix of the bounding box
   * @returns a matrix
   */
  getWorldMatrix() {
    return this._worldMatrix;
  }
  // Methods
  /**
   * @internal
   */
  _update(worldMatrix) {
    if (!worldMatrix.isIdentity()) {
      Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);
      const tempVector = _BoundingSphere._TmpVector3[0];
      Vector3.TransformNormalFromFloatsToRef(1, 1, 1, worldMatrix, tempVector);
      this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;
    } else {
      this.centerWorld.copyFrom(this.center);
      this.radiusWorld = this.radius;
    }
  }
  /**
   * Tests if the bounding sphere is intersecting the frustum planes
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an intersection
   */
  isInFrustum(frustumPlanes) {
    const center = this.centerWorld;
    const radius = this.radiusWorld;
    for (let i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) <= -radius) {
        return false;
      }
    }
    return true;
  }
  /**
   * Tests if the bounding sphere center is in between the frustum planes.
   * Used for optimistic fast inclusion.
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if the sphere center is in between the frustum planes
   */
  isCenterInFrustum(frustumPlanes) {
    const center = this.centerWorld;
    for (let i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) < 0) {
        return false;
      }
    }
    return true;
  }
  /**
   * Tests if a point is inside the bounding sphere
   * @param point defines the point to test
   * @returns true if the point is inside the bounding sphere
   */
  intersectsPoint(point) {
    const squareDistance = Vector3.DistanceSquared(this.centerWorld, point);
    if (this.radiusWorld * this.radiusWorld < squareDistance) {
      return false;
    }
    return true;
  }
  // Statics
  /**
   * Checks if two sphere intersect
   * @param sphere0 sphere 0
   * @param sphere1 sphere 1
   * @returns true if the spheres intersect
   */
  static Intersects(sphere0, sphere1) {
    const squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);
    const radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;
    if (radiusSum * radiusSum < squareDistance) {
      return false;
    }
    return true;
  }
  /**
   * Creates a sphere from a center and a radius
   * @param center The center
   * @param radius radius
   * @param matrix Optional worldMatrix
   * @returns The sphere
   */
  static CreateFromCenterAndRadius(center, radius, matrix) {
    this._TmpVector3[0].copyFrom(center);
    this._TmpVector3[1].copyFromFloats(0, 0, radius);
    this._TmpVector3[2].copyFrom(center);
    this._TmpVector3[0].addInPlace(this._TmpVector3[1]);
    this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);
    const sphere = new _BoundingSphere(this._TmpVector3[0], this._TmpVector3[2]);
    if (matrix) {
      sphere._worldMatrix = matrix;
    } else {
      sphere._worldMatrix = Matrix.Identity();
    }
    return sphere;
  }
};
BoundingSphere._TmpVector3 = BuildArray(3, Vector3.Zero);

// node_modules/@babylonjs/core/Culling/boundingInfo.js
var _Result0 = { min: 0, max: 0 };
var _Result1 = { min: 0, max: 0 };
var ComputeBoxExtents = (axis, box, result) => {
  const p = Vector3.Dot(box.centerWorld, axis);
  const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;
  const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;
  const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;
  const r = r0 + r1 + r2;
  result.min = p - r;
  result.max = p + r;
};
var AxisOverlap = (axis, box0, box1) => {
  ComputeBoxExtents(axis, box0, _Result0);
  ComputeBoxExtents(axis, box1, _Result1);
  return !(_Result0.min > _Result1.max || _Result1.min > _Result0.max);
};
var BoundingInfo = class _BoundingInfo {
  /**
   * Constructs bounding info
   * @param minimum min vector of the bounding box/sphere
   * @param maximum max vector of the bounding box/sphere
   * @param worldMatrix defines the new world matrix
   */
  constructor(minimum, maximum, worldMatrix) {
    this._isLocked = false;
    this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);
    this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);
  }
  /**
   * Recreates the entire bounding info from scratch as if we call the constructor in place
   * @param min defines the new minimum vector (in local space)
   * @param max defines the new maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  reConstruct(min, max, worldMatrix) {
    this.boundingBox.reConstruct(min, max, worldMatrix);
    this.boundingSphere.reConstruct(min, max, worldMatrix);
  }
  /**
   * min vector of the bounding box/sphere
   */
  get minimum() {
    return this.boundingBox.minimum;
  }
  /**
   * max vector of the bounding box/sphere
   */
  get maximum() {
    return this.boundingBox.maximum;
  }
  /**
   * If the info is locked and won't be updated to avoid perf overhead
   */
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(value) {
    this._isLocked = value;
  }
  // Methods
  /**
   * Updates the bounding sphere and box
   * @param world world matrix to be used to update
   */
  update(world) {
    if (this._isLocked) {
      return;
    }
    this.boundingBox._update(world);
    this.boundingSphere._update(world);
  }
  /**
   * Recreate the bounding info to be centered around a specific point given a specific extend.
   * @param center New center of the bounding info
   * @param extend New extend of the bounding info
   * @returns the current bounding info
   */
  centerOn(center, extend) {
    const minimum = _BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);
    const maximum = _BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);
    this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  }
  /**
   * Grows the bounding info to include the given point.
   * @param point The point that will be included in the current bounding info (in local space)
   * @returns the current bounding info
   */
  encapsulate(point) {
    const minimum = Vector3.Minimize(this.minimum, point);
    const maximum = Vector3.Maximize(this.maximum, point);
    this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  }
  /**
   * Grows the bounding info to encapsulate the given bounding info.
   * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info
   * @returns the current bounding info
   */
  encapsulateBoundingInfo(toEncapsulate) {
    const invw = TmpVectors.Matrix[0];
    this.boundingBox.getWorldMatrix().invertToRef(invw);
    const v = TmpVectors.Vector3[0];
    Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld, invw, v);
    this.encapsulate(v);
    Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld, invw, v);
    this.encapsulate(v);
    return this;
  }
  /**
   * Scale the current bounding info by applying a scale factor
   * @param factor defines the scale factor to apply
   * @returns the current bounding info
   */
  scale(factor) {
    this.boundingBox.scale(factor);
    this.boundingSphere.scale(factor);
    return this;
  }
  /**
   * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.
   * @param frustumPlanes defines the frustum to test
   * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)
   * The different strategies available are:
   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD
   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY
   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION
   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY
   * @returns true if the bounding info is in the frustum planes
   */
  isInFrustum(frustumPlanes, strategy = 0) {
    const inclusionTest = strategy === 2 || strategy === 3;
    if (inclusionTest) {
      if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {
        return true;
      }
    }
    if (!this.boundingSphere.isInFrustum(frustumPlanes)) {
      return false;
    }
    const bSphereOnlyTest = strategy === 1 || strategy === 3;
    if (bSphereOnlyTest) {
      return true;
    }
    return this.boundingBox.isInFrustum(frustumPlanes);
  }
  /**
   * Gets the world distance between the min and max points of the bounding box
   */
  get diagonalLength() {
    const boundingBox = this.boundingBox;
    const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, _BoundingInfo._TmpVector3[0]);
    return diag.length();
  }
  /**
   * Checks if a cullable object (mesh...) is in the camera frustum
   * Unlike isInFrustum this checks the full bounding box
   * @param frustumPlanes Camera near/planes
   * @returns true if the object is in frustum otherwise false
   */
  isCompletelyInFrustum(frustumPlanes) {
    return this.boundingBox.isCompletelyInFrustum(frustumPlanes);
  }
  /**
   * @internal
   */
  _checkCollision(collider) {
    return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);
  }
  /**
   * Checks if a point is inside the bounding box and bounding sphere or the mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect
   * @param point the point to check intersection with
   * @returns if the point intersects
   */
  intersectsPoint(point) {
    if (!this.boundingSphere.centerWorld) {
      return false;
    }
    if (!this.boundingSphere.intersectsPoint(point)) {
      return false;
    }
    if (!this.boundingBox.intersectsPoint(point)) {
      return false;
    }
    return true;
  }
  /**
   * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect
   * @param boundingInfo the bounding info to check intersection with
   * @param precise if the intersection should be done using OBB
   * @returns if the bounding info intersects
   */
  intersects(boundingInfo, precise) {
    if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {
      return false;
    }
    if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {
      return false;
    }
    if (!precise) {
      return true;
    }
    const box0 = this.boundingBox;
    const box1 = boundingInfo.boundingBox;
    if (!AxisOverlap(box0.directions[0], box0, box1)) {
      return false;
    }
    if (!AxisOverlap(box0.directions[1], box0, box1)) {
      return false;
    }
    if (!AxisOverlap(box0.directions[2], box0, box1)) {
      return false;
    }
    if (!AxisOverlap(box1.directions[0], box0, box1)) {
      return false;
    }
    if (!AxisOverlap(box1.directions[1], box0, box1)) {
      return false;
    }
    if (!AxisOverlap(box1.directions[2], box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {
      return false;
    }
    return true;
  }
};
BoundingInfo._TmpVector3 = BuildArray(2, Vector3.Zero);

export {
  PickingInfo,
  BoundingBox,
  BoundingSphere,
  BoundingInfo
};
//# sourceMappingURL=chunk-KJ5HQEXA.js.map
