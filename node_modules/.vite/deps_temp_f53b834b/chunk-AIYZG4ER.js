import {
  EffectWrapper
} from "./chunk-TE2ASPF2.js";
import {
  SmartArray,
  SmartArrayNoDuplicate
} from "./chunk-SZB5QSYK.js";
import {
  VertexBuffer
} from "./chunk-2PJUNA7K.js";
import {
  LightConstants
} from "./chunk-WAGTS43G.js";
import {
  Texture
} from "./chunk-WGSHYOCR.js";
import {
  FloorPOT,
  GetExponentOfTwo,
  NearestPOT
} from "./chunk-I4NFOKIT.js";
import {
  SerializationHelper
} from "./chunk-I7MCLN5K.js";
import {
  __decorate,
  serialize,
  serializeAsColor4
} from "./chunk-PVEEDNYT.js";
import {
  AbstractEngine,
  Effect,
  _RetryWithInterval
} from "./chunk-P7RYEPBM.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import {
  Matrix,
  Vector2,
  Vector3
} from "./chunk-XWK5Q5FM.js";
import {
  Observable
} from "./chunk-2YUEJ7I2.js";
import {
  _ObserveArray
} from "./chunk-L6ZZHROD.js";
import {
  GetClass,
  RegisterClass
} from "./chunk-S7NDMBDF.js";

// node_modules/@babylonjs/core/PostProcesses/postProcessManager.js
var PostProcessManager = class {
  /**
   * Creates a new instance PostProcess
   * @param scene The scene that the post process is associated with.
   */
  constructor(scene) {
    this._vertexBuffers = {};
    this.onBeforeRenderObservable = new Observable();
    this._scene = scene;
  }
  _prepareBuffers() {
    if (this._vertexBuffers[VertexBuffer.PositionKind]) {
      return;
    }
    const vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);
    this._buildIndexBuffer();
  }
  _buildIndexBuffer() {
    const indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);
  }
  /**
   * Rebuilds the vertex buffers of the manager.
   * @internal
   */
  _rebuild() {
    const vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (!vb) {
      return;
    }
    vb._rebuild();
    this._buildIndexBuffer();
  }
  // Methods
  /**
   * Prepares a frame to be run through a post process.
   * @param sourceTexture The input texture to the post processes. (default: null)
   * @param postProcesses An array of post processes to be run. (default: null)
   * @returns True if the post processes were able to be run.
   * @internal
   */
  _prepareFrame(sourceTexture = null, postProcesses = null) {
    const camera = this._scene.activeCamera;
    if (!camera) {
      return false;
    }
    postProcesses = postProcesses || camera._postProcesses.filter((pp) => {
      return pp != null;
    });
    if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
      return false;
    }
    postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== void 0);
    return true;
  }
  /**
   * Manually render a set of post processes to a texture.
   * Please note, the frame buffer won't be unbound after the call in case you have more render to do.
   * @param postProcesses An array of post processes to be run.
   * @param targetTexture The render target wrapper to render to.
   * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight
   * @param faceIndex defines the face to render to if a cubemap is defined as the target
   * @param lodLevel defines which lod of the texture to render to
   * @param doNotBindFrambuffer If set to true, assumes that the framebuffer has been bound previously
   * @param numPostsProcesses The number of post processes to render. Defaults to the length of the postProcesses array.
   */
  directRender(postProcesses, targetTexture = null, forceFullscreenViewport = false, faceIndex = 0, lodLevel = 0, doNotBindFrambuffer = false, numPostsProcesses = postProcesses.length) {
    var _a;
    const engine = this._scene.getEngine();
    for (let index = 0; index < numPostsProcesses; index++) {
      if (index < postProcesses.length - 1) {
        postProcesses[index + 1].activate(this._scene.activeCamera || this._scene, targetTexture == null ? void 0 : targetTexture.texture);
      } else {
        if (targetTexture) {
          engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport, lodLevel);
        } else if (!doNotBindFrambuffer) {
          engine.restoreDefaultFramebuffer();
        }
        (_a = engine._debugInsertMarker) == null ? void 0 : _a.call(engine, `post process ${postProcesses[index].name} output`);
      }
      const pp = postProcesses[index];
      const effect = pp.apply();
      if (effect) {
        pp.onBeforeRenderObservable.notifyObservers(effect);
        this._prepareBuffers();
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        engine.drawElementsType(0, 0, 6);
        pp.onAfterRenderObservable.notifyObservers(effect);
      }
    }
    engine.setDepthBuffer(true);
    engine.setDepthWrite(true);
  }
  /**
   * Finalize the result of the output of the postprocesses.
   * @param doNotPresent If true the result will not be displayed to the screen.
   * @param targetTexture The render target wrapper to render to.
   * @param faceIndex The index of the face to bind the target texture to.
   * @param postProcesses The array of post processes to render.
   * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight (default: false)
   * @internal
   */
  _finalizeFrame(doNotPresent, targetTexture, faceIndex, postProcesses, forceFullscreenViewport = false) {
    var _a;
    const camera = this._scene.activeCamera;
    if (!camera) {
      return;
    }
    this.onBeforeRenderObservable.notifyObservers(this);
    postProcesses = postProcesses || camera._postProcesses.filter((pp) => {
      return pp != null;
    });
    if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
      return;
    }
    const engine = this._scene.getEngine();
    for (let index = 0, len = postProcesses.length; index < len; index++) {
      const pp = postProcesses[index];
      if (index < len - 1) {
        pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture == null ? void 0 : targetTexture.texture);
      } else {
        if (targetTexture) {
          engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport);
          pp._outputTexture = targetTexture;
        } else {
          engine.restoreDefaultFramebuffer();
          pp._outputTexture = null;
        }
        (_a = engine._debugInsertMarker) == null ? void 0 : _a.call(engine, `post process ${postProcesses[index].name} output`);
      }
      if (doNotPresent) {
        break;
      }
      const effect = pp.apply();
      if (effect) {
        pp.onBeforeRenderObservable.notifyObservers(effect);
        this._prepareBuffers();
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        engine.drawElementsType(0, 0, 6);
        pp.onAfterRenderObservable.notifyObservers(effect);
      }
    }
    engine.setDepthBuffer(true);
    engine.setDepthWrite(true);
    engine.setAlphaMode(0);
  }
  /**
   * Disposes of the post process manager.
   */
  dispose() {
    const buffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (buffer) {
      buffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
  }
};

// node_modules/@babylonjs/core/Rendering/renderingGroup.js
var RenderingGroup = class _RenderingGroup {
  /**
   * Set the opaque sort comparison function.
   * If null the sub meshes will be render in the order they were created
   */
  set opaqueSortCompareFn(value) {
    if (value) {
      this._opaqueSortCompareFn = value;
    } else {
      this._opaqueSortCompareFn = _RenderingGroup.PainterSortCompare;
    }
    this._renderOpaque = this._renderOpaqueSorted;
  }
  /**
   * Set the alpha test sort comparison function.
   * If null the sub meshes will be render in the order they were created
   */
  set alphaTestSortCompareFn(value) {
    if (value) {
      this._alphaTestSortCompareFn = value;
    } else {
      this._alphaTestSortCompareFn = _RenderingGroup.PainterSortCompare;
    }
    this._renderAlphaTest = this._renderAlphaTestSorted;
  }
  /**
   * Set the transparent sort comparison function.
   * If null the sub meshes will be render in the order they were created
   */
  set transparentSortCompareFn(value) {
    if (value) {
      this._transparentSortCompareFn = value;
    } else {
      this._transparentSortCompareFn = _RenderingGroup.defaultTransparentSortCompare;
    }
    this._renderTransparent = this._renderTransparentSorted;
  }
  /**
   * Creates a new rendering group.
   * @param index The rendering group index
   * @param scene
   * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied
   * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied
   * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied
   */
  constructor(index, scene, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
    this.index = index;
    this._opaqueSubMeshes = new SmartArray(256);
    this._transparentSubMeshes = new SmartArray(256);
    this._alphaTestSubMeshes = new SmartArray(256);
    this._depthOnlySubMeshes = new SmartArray(256);
    this._particleSystems = new SmartArray(256);
    this._spriteManagers = new SmartArray(256);
    this._empty = true;
    this._edgesRenderers = new SmartArrayNoDuplicate(16);
    this.disableDepthPrePass = false;
    this._scene = scene;
    this.opaqueSortCompareFn = opaqueSortCompareFn;
    this.alphaTestSortCompareFn = alphaTestSortCompareFn;
    this.transparentSortCompareFn = transparentSortCompareFn;
  }
  /**
   * Render all the sub meshes contained in the group.
   * @param customRenderFunction Used to override the default render behaviour of the group.
   * @param renderSprites
   * @param renderParticles
   * @param activeMeshes
   */
  render(customRenderFunction, renderSprites, renderParticles, activeMeshes) {
    if (customRenderFunction) {
      customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);
      return;
    }
    const engine = this._scene.getEngine();
    if (this._depthOnlySubMeshes.length !== 0) {
      engine.setColorWrite(false);
      this._renderAlphaTest(this._depthOnlySubMeshes);
      engine.setColorWrite(true);
    }
    if (this._opaqueSubMeshes.length !== 0) {
      this._renderOpaque(this._opaqueSubMeshes);
    }
    if (this._alphaTestSubMeshes.length !== 0) {
      this._renderAlphaTest(this._alphaTestSubMeshes);
    }
    const stencilState = engine.getStencilBuffer();
    engine.setStencilBuffer(false);
    if (renderSprites) {
      this._renderSprites();
    }
    if (renderParticles) {
      this._renderParticles(activeMeshes);
    }
    if (this.onBeforeTransparentRendering) {
      this.onBeforeTransparentRendering();
    }
    if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {
      engine.setStencilBuffer(stencilState);
      if (this._scene.useOrderIndependentTransparency) {
        const excludedMeshes = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);
        if (excludedMeshes.length) {
          this._renderTransparent(excludedMeshes);
        }
      } else {
        this._renderTransparent(this._transparentSubMeshes);
      }
      engine.setAlphaMode(0);
    }
    engine.setStencilBuffer(false);
    if (this._edgesRenderers.length) {
      for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {
        this._edgesRenderers.data[edgesRendererIndex].render();
      }
      engine.setAlphaMode(0);
    }
    engine.setStencilBuffer(stencilState);
  }
  /**
   * Renders the opaque submeshes in the order from the opaqueSortCompareFn.
   * @param subMeshes The submeshes to render
   */
  _renderOpaqueSorted(subMeshes) {
    _RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false, this.disableDepthPrePass);
  }
  /**
   * Renders the opaque submeshes in the order from the alphatestSortCompareFn.
   * @param subMeshes The submeshes to render
   */
  _renderAlphaTestSorted(subMeshes) {
    _RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false, this.disableDepthPrePass);
  }
  /**
   * Renders the opaque submeshes in the order from the transparentSortCompareFn.
   * @param subMeshes The submeshes to render
   */
  _renderTransparentSorted(subMeshes) {
    _RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true, this.disableDepthPrePass);
  }
  /**
   * Renders the submeshes in a specified order.
   * @param subMeshes The submeshes to sort before render
   * @param sortCompareFn The comparison function use to sort
   * @param camera The camera position use to preprocess the submeshes to help sorting
   * @param transparent Specifies to activate blending if true
   * @param disableDepthPrePass Specifies to disable depth pre-pass if true (default: false)
   */
  static _RenderSorted(subMeshes, sortCompareFn, camera, transparent, disableDepthPrePass) {
    let subIndex = 0;
    let subMesh;
    const cameraPosition = camera ? camera.globalPosition : _RenderingGroup._ZeroVector;
    if (transparent) {
      for (; subIndex < subMeshes.length; subIndex++) {
        subMesh = subMeshes.data[subIndex];
        subMesh._alphaIndex = subMesh.getMesh().alphaIndex;
        subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
      }
    }
    const sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);
    if (sortCompareFn) {
      sortedArray.sort(sortCompareFn);
    }
    const scene = sortedArray[0].getMesh().getScene();
    for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {
      subMesh = sortedArray[subIndex];
      if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {
        continue;
      }
      if (transparent) {
        const material = subMesh.getMaterial();
        if (material && material.needDepthPrePass && !disableDepthPrePass) {
          const engine = material.getScene().getEngine();
          engine.setColorWrite(false);
          engine.setAlphaMode(0);
          subMesh.render(false);
          engine.setColorWrite(true);
        }
      }
      subMesh.render(transparent);
    }
  }
  /**
   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
   * are rendered back to front if in the same alpha index.
   *
   * @param a The first submesh
   * @param b The second submesh
   * @returns The result of the comparison
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static defaultTransparentSortCompare(a, b) {
    if (a._alphaIndex > b._alphaIndex) {
      return 1;
    }
    if (a._alphaIndex < b._alphaIndex) {
      return -1;
    }
    return _RenderingGroup.backToFrontSortCompare(a, b);
  }
  /**
   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
   * are rendered back to front.
   *
   * @param a The first submesh
   * @param b The second submesh
   * @returns The result of the comparison
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static backToFrontSortCompare(a, b) {
    if (a._distanceToCamera < b._distanceToCamera) {
      return 1;
    }
    if (a._distanceToCamera > b._distanceToCamera) {
      return -1;
    }
    return 0;
  }
  /**
   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
   * are rendered front to back (prevent overdraw).
   *
   * @param a The first submesh
   * @param b The second submesh
   * @returns The result of the comparison
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static frontToBackSortCompare(a, b) {
    if (a._distanceToCamera < b._distanceToCamera) {
      return -1;
    }
    if (a._distanceToCamera > b._distanceToCamera) {
      return 1;
    }
    return 0;
  }
  /**
   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
   * are grouped by material then geometry.
   *
   * @param a The first submesh
   * @param b The second submesh
   * @returns The result of the comparison
   */
  static PainterSortCompare(a, b) {
    const meshA = a.getMesh();
    const meshB = b.getMesh();
    if (meshA.material && meshB.material) {
      return meshA.material.uniqueId - meshB.material.uniqueId;
    }
    return meshA.uniqueId - meshB.uniqueId;
  }
  /**
   * Resets the different lists of submeshes to prepare a new frame.
   */
  prepare() {
    this._opaqueSubMeshes.reset();
    this._transparentSubMeshes.reset();
    this._alphaTestSubMeshes.reset();
    this._depthOnlySubMeshes.reset();
    this._particleSystems.reset();
    this.prepareSprites();
    this._edgesRenderers.reset();
    this._empty = true;
  }
  /**
   * Resets the different lists of sprites to prepare a new frame.
   */
  prepareSprites() {
    this._spriteManagers.reset();
  }
  dispose() {
    this._opaqueSubMeshes.dispose();
    this._transparentSubMeshes.dispose();
    this._alphaTestSubMeshes.dispose();
    this._depthOnlySubMeshes.dispose();
    this._particleSystems.dispose();
    this._spriteManagers.dispose();
    this._edgesRenderers.dispose();
  }
  /**
   * Inserts the submesh in its correct queue depending on its material.
   * @param subMesh The submesh to dispatch
   * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.
   * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.
   */
  dispatch(subMesh, mesh, material) {
    if (mesh === void 0) {
      mesh = subMesh.getMesh();
    }
    if (material === void 0) {
      material = subMesh.getMaterial();
    }
    if (material === null || material === void 0) {
      return;
    }
    if (material.needAlphaBlendingForMesh(mesh)) {
      this._transparentSubMeshes.push(subMesh);
    } else if (material.needAlphaTestingForMesh(mesh)) {
      if (material.needDepthPrePass && !this.disableDepthPrePass) {
        this._depthOnlySubMeshes.push(subMesh);
      }
      this._alphaTestSubMeshes.push(subMesh);
    } else {
      if (material.needDepthPrePass && !this.disableDepthPrePass) {
        this._depthOnlySubMeshes.push(subMesh);
      }
      this._opaqueSubMeshes.push(subMesh);
    }
    mesh._renderingGroup = this;
    if (mesh._edgesRenderer && mesh.isEnabled() && mesh.isVisible && mesh._edgesRenderer.isEnabled) {
      this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);
    }
    this._empty = false;
  }
  dispatchSprites(spriteManager) {
    this._spriteManagers.push(spriteManager);
    this._empty = false;
  }
  dispatchParticles(particleSystem) {
    this._particleSystems.push(particleSystem);
    this._empty = false;
  }
  _renderParticles(activeMeshes) {
    if (this._particleSystems.length === 0) {
      return;
    }
    const activeCamera = this._scene.activeCamera;
    this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
    for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {
      const particleSystem = this._particleSystems.data[particleIndex];
      if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {
        continue;
      }
      const emitter = particleSystem.emitter;
      if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {
        this._scene._activeParticles.addCount(particleSystem.render(), false);
      }
    }
    this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);
  }
  _renderSprites() {
    if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {
      return;
    }
    const activeCamera = this._scene.activeCamera;
    this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);
    for (let id = 0; id < this._spriteManagers.length; id++) {
      const spriteManager = this._spriteManagers.data[id];
      if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {
        spriteManager.render();
      }
    }
    this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);
  }
};
RenderingGroup._ZeroVector = Vector3.Zero();

// node_modules/@babylonjs/core/Rendering/renderingManager.js
var RenderingGroupInfo = class {
};
var RenderingManager = class _RenderingManager {
  /**
   * Specifies to disable depth pre-pass if true (default: false)
   */
  get disableDepthPrePass() {
    return this._disableDepthPrePass;
  }
  set disableDepthPrePass(value) {
    this._disableDepthPrePass = value;
    for (const group of this._renderingGroups) {
      group.disableDepthPrePass = value;
    }
  }
  /**
   * Gets or sets a boolean indicating that the manager will not reset between frames.
   * This means that if a mesh becomes invisible or transparent it will not be visible until this boolean is set to false again.
   * By default, the rendering manager will dispatch all active meshes per frame (moving them to the transparent, opaque or alpha testing lists).
   * By turning this property on, you will accelerate the rendering by keeping all these lists unchanged between frames.
   */
  get maintainStateBetweenFrames() {
    return this._maintainStateBetweenFrames;
  }
  set maintainStateBetweenFrames(value) {
    if (value === this._maintainStateBetweenFrames) {
      return;
    }
    this._maintainStateBetweenFrames = value;
    if (!this._maintainStateBetweenFrames) {
      this.restoreDispachedFlags();
    }
  }
  /**
   * Restore wasDispatched flags on the lists of elements to render.
   */
  restoreDispachedFlags() {
    for (const mesh of this._scene.meshes) {
      if (mesh.subMeshes) {
        for (const subMesh of mesh.subMeshes) {
          subMesh._wasDispatched = false;
        }
      }
    }
    if (this._scene.spriteManagers) {
      for (const spriteManager of this._scene.spriteManagers) {
        spriteManager._wasDispatched = false;
      }
    }
    for (const particleSystem of this._scene.particleSystems) {
      particleSystem._wasDispatched = false;
    }
  }
  /**
   * Instantiates a new rendering group for a particular scene
   * @param scene Defines the scene the groups belongs to
   */
  constructor(scene) {
    this._useSceneAutoClearSetup = false;
    this._disableDepthPrePass = false;
    this._renderingGroups = new Array();
    this._autoClearDepthStencil = {};
    this._customOpaqueSortCompareFn = {};
    this._customAlphaTestSortCompareFn = {};
    this._customTransparentSortCompareFn = {};
    this._renderingGroupInfo = new RenderingGroupInfo();
    this._maintainStateBetweenFrames = false;
    this._scene = scene;
    for (let i = _RenderingManager.MIN_RENDERINGGROUPS; i < _RenderingManager.MAX_RENDERINGGROUPS; i++) {
      this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };
    }
  }
  /**
   * @returns the rendering group with the specified id.
   * @param id the id of the rendering group (0 by default)
   */
  getRenderingGroup(id) {
    const renderingGroupId = id || 0;
    this._prepareRenderingGroup(renderingGroupId);
    return this._renderingGroups[renderingGroupId];
  }
  _clearDepthStencilBuffer(depth = true, stencil = true) {
    if (this._depthStencilBufferAlreadyCleaned) {
      return;
    }
    this._scene.getEngine().clear(null, false, depth, stencil);
    this._depthStencilBufferAlreadyCleaned = true;
  }
  /**
   * Renders the entire managed groups. This is used by the scene or the different render targets.
   * @internal
   */
  render(customRenderFunction, activeMeshes, renderParticles, renderSprites) {
    const info = this._renderingGroupInfo;
    info.scene = this._scene;
    info.camera = this._scene.activeCamera;
    info.renderingManager = this;
    if (this._scene.spriteManagers && renderSprites) {
      for (let index = 0; index < this._scene.spriteManagers.length; index++) {
        const manager = this._scene.spriteManagers[index];
        this.dispatchSprites(manager);
      }
    }
    for (let index = _RenderingManager.MIN_RENDERINGGROUPS; index < _RenderingManager.MAX_RENDERINGGROUPS; index++) {
      this._depthStencilBufferAlreadyCleaned = index === _RenderingManager.MIN_RENDERINGGROUPS;
      const renderingGroup = this._renderingGroups[index];
      if (!renderingGroup || renderingGroup._empty) {
        continue;
      }
      const renderingGroupMask = 1 << index;
      info.renderingGroupId = index;
      this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
      if (_RenderingManager.AUTOCLEAR) {
        const autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];
        if (autoClear && autoClear.autoClear) {
          this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);
        }
      }
      for (const step of this._scene._beforeRenderingGroupDrawStage) {
        step.action(index);
      }
      renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);
      for (const step of this._scene._afterRenderingGroupDrawStage) {
        step.action(index);
      }
      this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
    }
  }
  /**
   * Resets the different information of the group to prepare a new frame
   * @internal
   */
  reset() {
    if (this.maintainStateBetweenFrames) {
      return;
    }
    for (let index = _RenderingManager.MIN_RENDERINGGROUPS; index < _RenderingManager.MAX_RENDERINGGROUPS; index++) {
      const renderingGroup = this._renderingGroups[index];
      if (renderingGroup) {
        renderingGroup.prepare();
      }
    }
  }
  /**
   * Resets the sprites information of the group to prepare a new frame
   * @internal
   */
  resetSprites() {
    if (this.maintainStateBetweenFrames) {
      return;
    }
    for (let index = _RenderingManager.MIN_RENDERINGGROUPS; index < _RenderingManager.MAX_RENDERINGGROUPS; index++) {
      const renderingGroup = this._renderingGroups[index];
      if (renderingGroup) {
        renderingGroup.prepareSprites();
      }
    }
  }
  /**
   * Dispose and release the group and its associated resources.
   * @internal
   */
  dispose() {
    this.freeRenderingGroups();
    this._renderingGroups.length = 0;
    this._renderingGroupInfo = null;
  }
  /**
   * Clear the info related to rendering groups preventing retention points during dispose.
   */
  freeRenderingGroups() {
    for (let index = _RenderingManager.MIN_RENDERINGGROUPS; index < _RenderingManager.MAX_RENDERINGGROUPS; index++) {
      const renderingGroup = this._renderingGroups[index];
      if (renderingGroup) {
        renderingGroup.dispose();
      }
    }
  }
  _prepareRenderingGroup(renderingGroupId) {
    if (this._renderingGroups[renderingGroupId] === void 0) {
      this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);
      this._renderingGroups[renderingGroupId].disableDepthPrePass = this._disableDepthPrePass;
    }
  }
  /**
   * Add a sprite manager to the rendering manager in order to render it this frame.
   * @param spriteManager Define the sprite manager to render
   */
  dispatchSprites(spriteManager) {
    if (this.maintainStateBetweenFrames && spriteManager._wasDispatched) {
      return;
    }
    spriteManager._wasDispatched = true;
    this.getRenderingGroup(spriteManager.renderingGroupId).dispatchSprites(spriteManager);
  }
  /**
   * Add a particle system to the rendering manager in order to render it this frame.
   * @param particleSystem Define the particle system to render
   */
  dispatchParticles(particleSystem) {
    if (this.maintainStateBetweenFrames && particleSystem._wasDispatched) {
      return;
    }
    particleSystem._wasDispatched = true;
    this.getRenderingGroup(particleSystem.renderingGroupId).dispatchParticles(particleSystem);
  }
  /**
   * Add a submesh to the manager in order to render it this frame
   * @param subMesh The submesh to dispatch
   * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.
   * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.
   */
  dispatch(subMesh, mesh, material) {
    if (mesh === void 0) {
      mesh = subMesh.getMesh();
    }
    if (this.maintainStateBetweenFrames && subMesh._wasDispatched) {
      return;
    }
    subMesh._wasDispatched = true;
    this.getRenderingGroup(mesh.renderingGroupId).dispatch(subMesh, mesh, material);
  }
  /**
   * Overrides the default sort function applied in the rendering group to prepare the meshes.
   * This allowed control for front to back rendering or reversely depending of the special needs.
   *
   * @param renderingGroupId The rendering group id corresponding to its index
   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
   * @param transparentSortCompareFn The transparent queue comparison function use to sort.
   */
  setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
    this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;
    this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;
    this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;
    if (this._renderingGroups[renderingGroupId]) {
      const group = this._renderingGroups[renderingGroupId];
      group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];
      group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];
      group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];
    }
  }
  /**
   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
   *
   * @param renderingGroupId The rendering group id corresponding to its index
   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
   * @param depth Automatically clears depth between groups if true and autoClear is true.
   * @param stencil Automatically clears stencil between groups if true and autoClear is true.
   */
  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {
    this._autoClearDepthStencil[renderingGroupId] = {
      autoClear: autoClearDepthStencil,
      depth,
      stencil
    };
  }
  /**
   * Gets the current auto clear configuration for one rendering group of the rendering
   * manager.
   * @param index the rendering group index to get the information for
   * @returns The auto clear setup for the requested rendering group
   */
  getAutoClearDepthStencilSetup(index) {
    return this._autoClearDepthStencil[index];
  }
};
RenderingManager.MAX_RENDERINGGROUPS = 4;
RenderingManager.MIN_RENDERINGGROUPS = 0;
RenderingManager.AUTOCLEAR = true;

// node_modules/@babylonjs/core/Rendering/objectRenderer.js
var ObjectRenderer = class _ObjectRenderer {
  /**
   * Use this list to define the list of mesh you want to render.
   */
  get renderList() {
    return this._renderList;
  }
  set renderList(value) {
    if (this._renderList === value) {
      return;
    }
    if (this._unObserveRenderList) {
      this._unObserveRenderList();
      this._unObserveRenderList = null;
    }
    if (value) {
      this._unObserveRenderList = _ObserveArray(value, this._renderListHasChanged);
    }
    this._renderList = value;
  }
  /**
   * If true, the object renderer will render all objects without any image processing applied.
   * If false (default value), the renderer will use the current setting of the scene's image processing configuration.
   */
  get disableImageProcessing() {
    return this._disableImageProcessing;
  }
  set disableImageProcessing(value) {
    if (value === this._disableImageProcessing) {
      return;
    }
    this._disableImageProcessing = value;
    this._scene.markAllMaterialsAsDirty(64);
  }
  /**
   * Specifies to disable depth pre-pass if true (default: false)
   */
  get disableDepthPrePass() {
    return this._disableDepthPrePass;
  }
  set disableDepthPrePass(value) {
    this._disableDepthPrePass = value;
    this._renderingManager.disableDepthPrePass = value;
  }
  /**
   * Friendly name of the object renderer
   */
  get name() {
    return this._name;
  }
  set name(value) {
    if (this._name === value) {
      return;
    }
    this._name = value;
    if (this._sceneUBOs) {
      for (let i = 0; i < this._sceneUBOs.length; ++i) {
        this._sceneUBOs[i].name = `Scene ubo #${i} for ${this.name}`;
      }
    }
    if (!this._scene) {
      return;
    }
    for (let i = 0; i < this._renderPassIds.length; ++i) {
      const renderPassId = this._renderPassIds[i];
      this._engine._renderPassNames[renderPassId] = `${this._name}#${i}`;
    }
  }
  /**
   * Gets the render pass ids used by the object renderer.
   */
  get renderPassIds() {
    return this._renderPassIds;
  }
  /**
   * Gets the current value of the refreshId counter
   */
  get currentRefreshId() {
    return this._currentRefreshId;
  }
  /**
   * Gets the array of active meshes
   * @returns an array of AbstractMesh
   */
  getActiveMeshes() {
    return this._activeMeshes;
  }
  /**
   * Sets a specific material to be used to render a mesh/a list of meshes with this object renderer
   * @param mesh mesh or array of meshes
   * @param material material or array of materials to use for this render pass. If undefined is passed, no specific material will be used but the regular material instead (mesh.material). It's possible to provide an array of materials to use a different material for each rendering pass.
   */
  setMaterialForRendering(mesh, material) {
    let meshes;
    if (!Array.isArray(mesh)) {
      meshes = [mesh];
    } else {
      meshes = mesh;
    }
    for (let j = 0; j < meshes.length; ++j) {
      for (let i = 0; i < this.options.numPasses; ++i) {
        let mesh2 = meshes[j];
        if (meshes[j].isAnInstance) {
          mesh2 = meshes[j].sourceMesh;
        }
        mesh2.setMaterialForRenderPass(this._renderPassIds[i], material !== void 0 ? Array.isArray(material) ? material[i] : material : void 0);
      }
    }
  }
  /** @internal */
  _freezeActiveMeshes(freezeMeshes) {
    this._freezeActiveMeshesCancel = _RetryWithInterval(() => {
      return this._checkReadiness();
    }, () => {
      this._freezeActiveMeshesCancel = null;
      if (freezeMeshes) {
        for (let index = 0; index < this._activeMeshes.length; index++) {
          this._activeMeshes.data[index]._freeze();
        }
      }
      this._prepareRenderingManager(0, true);
      this._isFrozen = true;
    }, (err, isTimeout) => {
      this._freezeActiveMeshesCancel = null;
      if (!isTimeout) {
        Logger.Error("ObjectRenderer: An unexpected error occurred while waiting for the renderer to be ready.");
        if (err) {
          Logger.Error(err);
          if (err.stack) {
            Logger.Error(err.stack);
          }
        }
      } else {
        Logger.Error(`ObjectRenderer: Timeout while waiting for the renderer to be ready.`);
        if (err) {
          Logger.Error(err);
        }
      }
    });
  }
  /** @internal */
  _unfreezeActiveMeshes() {
    var _a;
    (_a = this._freezeActiveMeshesCancel) == null ? void 0 : _a.call(this);
    this._freezeActiveMeshesCancel = null;
    for (let index = 0; index < this._activeMeshes.length; index++) {
      this._activeMeshes.data[index]._unFreeze();
    }
    this._isFrozen = false;
  }
  /**
   * Instantiates an object renderer.
   * @param name The friendly name of the object renderer
   * @param scene The scene the renderer belongs to
   * @param options The options used to create the renderer (optional)
   */
  constructor(name, scene, options) {
    this._unObserveRenderList = null;
    this._renderListHasChanged = (_functionName, previousLength) => {
      const newLength = this._renderList ? this._renderList.length : 0;
      if (previousLength === 0 && newLength > 0 || newLength === 0) {
        for (const mesh of this._scene.meshes) {
          mesh._markSubMeshesAsLightDirty();
        }
      }
    };
    this.particleSystemList = null;
    this.getCustomRenderList = null;
    this.renderParticles = true;
    this.renderSprites = false;
    this.forceLayerMaskCheck = false;
    this.enableBoundingBoxRendering = false;
    this.enableOutlineRendering = true;
    this._disableImageProcessing = false;
    this.dontSetTransformationMatrix = false;
    this._disableDepthPrePass = false;
    this.onBeforeRenderObservable = new Observable();
    this.onAfterRenderObservable = new Observable();
    this.onBeforeRenderingManagerRenderObservable = new Observable();
    this.onAfterRenderingManagerRenderObservable = new Observable();
    this.onInitRenderingObservable = new Observable();
    this.onFinishRenderingObservable = new Observable();
    this.onFastPathRenderObservable = new Observable();
    this._currentRefreshId = -1;
    this._refreshRate = 1;
    this._currentApplyByPostProcessSetting = false;
    this._activeMeshes = new SmartArray(256);
    this._activeBoundingBoxes = new SmartArray(32);
    this._currentFrameId = -1;
    this._currentSceneUBOIndex = 0;
    this._isFrozen = false;
    this._freezeActiveMeshesCancel = null;
    this._currentSceneCamera = null;
    this.name = name;
    this._scene = scene;
    this._engine = this._scene.getEngine();
    this._useUBO = this._engine.supportsUniformBuffers;
    if (this._useUBO) {
      this._sceneUBOs = [];
      this._createSceneUBO();
    }
    this.renderList = [];
    this._renderPassIds = [];
    this.options = {
      numPasses: 1,
      doNotChangeAspectRatio: true,
      enableClusteredLights: false,
      ...options
    };
    this._createRenderPassId();
    this.renderPassId = this._renderPassIds[0];
    this._renderingManager = new RenderingManager(scene);
    this._renderingManager._useSceneAutoClearSetup = true;
    if (this.options.enableClusteredLights) {
      this.onInitRenderingObservable.add(() => {
        for (const light of this._scene.lights) {
          if (light.getTypeID() === LightConstants.LIGHTTYPEID_CLUSTERED_CONTAINER && light.isSupported) {
            light._updateBatches(this.activeCamera).render();
          }
        }
      });
    }
    this._scene.addObjectRenderer(this);
  }
  _releaseRenderPassId() {
    for (let i = 0; i < this.options.numPasses; ++i) {
      this._engine.releaseRenderPassId(this._renderPassIds[i]);
    }
    this._renderPassIds.length = 0;
  }
  _createRenderPassId() {
    this._releaseRenderPassId();
    for (let i = 0; i < this.options.numPasses; ++i) {
      this._renderPassIds[i] = this._engine.createRenderPassId(`${this.name}#${i}`);
    }
  }
  _createSceneUBO() {
    const index = this._sceneUBOs.length;
    this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene ubo #${index} for ${this.name}`, false));
  }
  _getSceneUBO() {
    if (this._currentFrameId !== this._engine.frameId) {
      this._currentSceneUBOIndex = 0;
      this._currentFrameId = this._engine.frameId;
    }
    if (this._currentSceneUBOIndex >= this._sceneUBOs.length) {
      this._createSceneUBO();
    }
    const ubo = this._sceneUBOs[this._currentSceneUBOIndex++];
    ubo.unbindEffect();
    return ubo;
  }
  /**
   * Resets the refresh counter of the renderer and start back from scratch.
   * Could be useful to re-render if it is setup to render only once.
   */
  resetRefreshCounter() {
    this._currentRefreshId = -1;
  }
  /**
   * Defines the refresh rate of the rendering or the rendering frequency.
   * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
   */
  get refreshRate() {
    return this._refreshRate;
  }
  set refreshRate(value) {
    this._refreshRate = value;
    this.resetRefreshCounter();
  }
  /**
   * Indicates if the renderer should render the current frame.
   * The output is based on the specified refresh rate.
   * @returns true if the renderer should render the current frame
   */
  shouldRender() {
    if (this._currentRefreshId === -1) {
      this._currentRefreshId = 1;
      return true;
    }
    if (this.refreshRate === this._currentRefreshId) {
      this._currentRefreshId = 1;
      return true;
    }
    this._currentRefreshId++;
    return false;
  }
  /**
   * This function will check if the renderer is ready to render (textures are loaded, shaders are compiled)
   * @param viewportWidth defines the width of the viewport
   * @param viewportHeight defines the height of the viewport
   * @returns true if all required resources are ready
   */
  isReadyForRendering(viewportWidth, viewportHeight) {
    this.prepareRenderList();
    this.initRender(viewportWidth, viewportHeight);
    const isReady = this._checkReadiness();
    this.finishRender();
    return isReady;
  }
  /**
   * Makes sure the list of meshes is ready to be rendered
   * You should call this function before "initRender", but if you know the render list is ok, you may call "initRender" directly
   */
  prepareRenderList() {
    const scene = this._scene;
    if (this._waitingRenderList) {
      if (!this.renderListPredicate) {
        this.renderList = [];
        for (let index = 0; index < this._waitingRenderList.length; index++) {
          const id = this._waitingRenderList[index];
          const mesh = scene.getMeshById(id);
          if (mesh) {
            this.renderList.push(mesh);
          }
        }
      }
      this._waitingRenderList = void 0;
    }
    if (this.renderListPredicate) {
      if (this.renderList) {
        this.renderList.length = 0;
      } else {
        this.renderList = [];
      }
      const sceneMeshes = this._scene.meshes;
      for (let index = 0; index < sceneMeshes.length; index++) {
        const mesh = sceneMeshes[index];
        if (this.renderListPredicate(mesh)) {
          this.renderList.push(mesh);
        }
      }
    }
    this._currentApplyByPostProcessSetting = this._scene.imageProcessingConfiguration.applyByPostProcess;
    if (this._disableImageProcessing) {
      this._scene.imageProcessingConfiguration._applyByPostProcess = this._disableImageProcessing;
    }
  }
  /**
   * This method makes sure everything is setup before "render" can be called
   * @param viewportWidth Width of the viewport to render to
   * @param viewportHeight Height of the viewport to render to
   */
  initRender(viewportWidth, viewportHeight) {
    const camera = this.activeCamera ?? this._scene.activeCamera;
    this._currentSceneCamera = this._scene.activeCamera;
    if (this._useUBO) {
      this._currentSceneUBO = this._scene.getSceneUniformBuffer();
      this._currentSceneUBO.unbindEffect();
      this._scene.setSceneUniformBuffer(this._getSceneUBO());
    }
    this.onInitRenderingObservable.notifyObservers(this);
    if (camera) {
      if (!this.dontSetTransformationMatrix) {
        this._scene.setTransformMatrix(camera.getViewMatrix(), camera.getProjectionMatrix(true));
      }
      this._scene.activeCamera = camera;
      this._engine.setViewport(camera.rigParent ? camera.rigParent.viewport : camera.viewport, viewportWidth, viewportHeight);
    }
    if (this._useUBO) {
      this._scene.finalizeSceneUbo();
    }
    this._defaultRenderListPrepared = false;
  }
  /**
   * This method must be called after the "render" call(s), to complete the rendering process.
   */
  finishRender() {
    const scene = this._scene;
    if (this._useUBO) {
      this._scene.setSceneUniformBuffer(this._currentSceneUBO);
    }
    if (this._disableImageProcessing) {
      scene.imageProcessingConfiguration._applyByPostProcess = this._currentApplyByPostProcessSetting;
    }
    scene.activeCamera = this._currentSceneCamera;
    if (this._currentSceneCamera) {
      if (this.activeCamera && this.activeCamera !== scene.activeCamera) {
        scene.setTransformMatrix(this._currentSceneCamera.getViewMatrix(), this._currentSceneCamera.getProjectionMatrix(true));
      }
      this._engine.setViewport(this._currentSceneCamera.viewport);
    }
    scene.resetCachedMaterial();
    this.onFinishRenderingObservable.notifyObservers(this);
  }
  /**
   * Renders all the objects (meshes, particles systems, sprites) to the currently bound render target texture.
   * @param passIndex defines the pass index to use (default: 0)
   * @param skipOnAfterRenderObservable defines a flag to skip raising the onAfterRenderObservable
   */
  render(passIndex = 0, skipOnAfterRenderObservable = false) {
    var _a, _b;
    const currentRenderPassId = this._engine.currentRenderPassId;
    this._engine.currentRenderPassId = this._renderPassIds[passIndex];
    this.onBeforeRenderObservable.notifyObservers(passIndex);
    const fastPath = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;
    if (!fastPath) {
      const currentRenderList = this._prepareRenderingManager(passIndex);
      const outlineRenderer = (_b = (_a = this._scene).getOutlineRenderer) == null ? void 0 : _b.call(_a);
      const outlineRendererIsEnabled = outlineRenderer == null ? void 0 : outlineRenderer.enabled;
      if (outlineRenderer) {
        outlineRenderer.enabled = this.enableOutlineRendering;
      }
      this.onBeforeRenderingManagerRenderObservable.notifyObservers(passIndex);
      this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);
      this.onAfterRenderingManagerRenderObservable.notifyObservers(passIndex);
      if (outlineRenderer) {
        outlineRenderer.enabled = outlineRendererIsEnabled;
      }
    } else {
      this.onFastPathRenderObservable.notifyObservers(passIndex);
    }
    if (!skipOnAfterRenderObservable) {
      this.onAfterRenderObservable.notifyObservers(passIndex);
    }
    this._engine.currentRenderPassId = currentRenderPassId;
  }
  /** @internal */
  _checkReadiness() {
    const scene = this._scene;
    const currentRenderPassId = this._engine.currentRenderPassId;
    let returnValue = true;
    if (!scene.getViewMatrix()) {
      scene.updateTransformMatrix();
    }
    const numPasses = this.options.numPasses;
    for (let passIndex = 0; passIndex < numPasses && returnValue; passIndex++) {
      let currentRenderList = null;
      const defaultRenderList = this.renderList ? this.renderList : scene.frameGraph ? scene.meshes : scene.getActiveMeshes().data;
      const defaultRenderListLength = this.renderList ? this.renderList.length : scene.frameGraph ? scene.meshes.length : scene.getActiveMeshes().length;
      this._engine.currentRenderPassId = this._renderPassIds[passIndex];
      this.onBeforeRenderObservable.notifyObservers(passIndex);
      if (this.getCustomRenderList) {
        currentRenderList = this.getCustomRenderList(passIndex, defaultRenderList, defaultRenderListLength);
      }
      if (!currentRenderList) {
        currentRenderList = defaultRenderList;
      }
      if (!this.options.doNotChangeAspectRatio) {
        scene.updateTransformMatrix(true);
      }
      for (let i = 0; i < currentRenderList.length && returnValue; ++i) {
        const mesh = currentRenderList[i];
        if (!mesh.isEnabled() || mesh.isBlocked || !mesh.isVisible || !mesh.subMeshes) {
          continue;
        }
        if (this.customIsReadyFunction) {
          if (!this.customIsReadyFunction(mesh, this.refreshRate, true)) {
            returnValue = false;
            continue;
          }
        } else if (!mesh.isReady(true)) {
          returnValue = false;
          continue;
        }
      }
      this.onAfterRenderObservable.notifyObservers(passIndex);
      if (numPasses > 1) {
        scene.incrementRenderId();
        scene.resetCachedMaterial();
      }
    }
    const particleSystems = this.particleSystemList || scene.particleSystems;
    for (const particleSystem of particleSystems) {
      if (!particleSystem.isReady()) {
        returnValue = false;
      }
    }
    this._engine.currentRenderPassId = currentRenderPassId;
    return returnValue;
  }
  _prepareRenderingManager(passIndex = 0, winterIsComing = false) {
    var _a;
    const scene = this._scene;
    let currentRenderList = null;
    let currentRenderListLength = 0;
    let checkLayerMask = false;
    const defaultRenderList = this.renderList ? this.renderList : scene.frameGraph ? scene.meshes : scene.getActiveMeshes().data;
    const defaultRenderListLength = this.renderList ? this.renderList.length : scene.frameGraph ? scene.meshes.length : scene.getActiveMeshes().length;
    if (this.getCustomRenderList) {
      currentRenderList = this.getCustomRenderList(passIndex, defaultRenderList, defaultRenderListLength);
    }
    if (!currentRenderList) {
      if (this._defaultRenderListPrepared && !winterIsComing) {
        return defaultRenderList;
      }
      this._defaultRenderListPrepared = true;
      currentRenderList = defaultRenderList;
      currentRenderListLength = defaultRenderListLength;
      checkLayerMask = !this.renderList || this.forceLayerMaskCheck;
    } else {
      currentRenderListLength = currentRenderList.length;
      checkLayerMask = this.forceLayerMaskCheck;
    }
    const camera = scene.activeCamera;
    const cameraForLOD = this.cameraForLOD ?? camera;
    const boundingBoxRenderer = (_a = scene.getBoundingBoxRenderer) == null ? void 0 : _a.call(scene);
    if (scene._activeMeshesFrozen && this._isFrozen) {
      this._renderingManager.resetSprites();
      if (this.enableBoundingBoxRendering && boundingBoxRenderer) {
        boundingBoxRenderer.reset();
        for (let i = 0; i < this._activeBoundingBoxes.length; i++) {
          const boundingBox = this._activeBoundingBoxes.data[i];
          boundingBoxRenderer.renderList.push(boundingBox);
        }
      }
      return currentRenderList;
    }
    this._renderingManager.reset();
    this._activeMeshes.reset();
    this._activeBoundingBoxes.reset();
    boundingBoxRenderer && boundingBoxRenderer.reset();
    const sceneRenderId = scene.getRenderId();
    const currentFrameId = scene.getFrameId();
    for (let meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {
      const mesh = currentRenderList[meshIndex];
      if (mesh && !mesh.isBlocked) {
        if (this.customIsReadyFunction) {
          if (!this.customIsReadyFunction(mesh, this.refreshRate, false)) {
            this.resetRefreshCounter();
            continue;
          }
        } else if (!mesh.isReady(this.refreshRate === 0)) {
          this.resetRefreshCounter();
          continue;
        }
        let meshToRender = null;
        if (cameraForLOD) {
          const meshToRenderAndFrameId = mesh._internalAbstractMeshDataInfo._currentLOD.get(cameraForLOD);
          if (!meshToRenderAndFrameId || meshToRenderAndFrameId[1] !== currentFrameId) {
            meshToRender = scene.customLODSelector ? scene.customLODSelector(mesh, cameraForLOD) : mesh.getLOD(cameraForLOD);
            if (!meshToRenderAndFrameId) {
              mesh._internalAbstractMeshDataInfo._currentLOD.set(cameraForLOD, [meshToRender, currentFrameId]);
            } else {
              meshToRenderAndFrameId[0] = meshToRender;
              meshToRenderAndFrameId[1] = currentFrameId;
            }
          } else {
            meshToRender = meshToRenderAndFrameId[0];
          }
        } else {
          meshToRender = mesh;
        }
        if (!meshToRender) {
          continue;
        }
        if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {
          meshToRender.computeWorldMatrix();
        }
        meshToRender._preActivateForIntermediateRendering(sceneRenderId);
        let isMasked;
        if (checkLayerMask && camera) {
          isMasked = (mesh.layerMask & camera.layerMask) === 0;
        } else {
          isMasked = false;
        }
        if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {
          this._activeMeshes.push(mesh);
          meshToRender._internalAbstractMeshDataInfo._wasActiveLastFrame = true;
          if (meshToRender !== mesh) {
            meshToRender._activate(sceneRenderId, true);
          }
          this.enableBoundingBoxRendering && boundingBoxRenderer && boundingBoxRenderer._preActiveMesh(mesh);
          if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {
            if (!mesh.isAnInstance) {
              meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;
            } else {
              if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
                meshToRender = mesh;
              }
            }
            meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;
            scene._prepareSkeleton(meshToRender);
            for (let subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {
              const subMesh = meshToRender.subMeshes[subIndex];
              this.enableBoundingBoxRendering && boundingBoxRenderer && boundingBoxRenderer._evaluateSubMesh(mesh, subMesh);
              this._renderingManager.dispatch(subMesh, meshToRender);
            }
          }
          mesh._postActivate();
        }
      }
    }
    if (this.enableBoundingBoxRendering && boundingBoxRenderer && winterIsComing) {
      for (let i = 0; i < boundingBoxRenderer.renderList.length; i++) {
        const boundingBox = boundingBoxRenderer.renderList.data[i];
        this._activeBoundingBoxes.push(boundingBox);
      }
    }
    if (this._scene.particlesEnabled) {
      this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
      const particleSystems = this.particleSystemList || scene.particleSystems;
      for (let particleIndex = 0; particleIndex < particleSystems.length; particleIndex++) {
        const particleSystem = particleSystems[particleIndex];
        const emitter = particleSystem.emitter;
        if (!particleSystem.isStarted() || !emitter || emitter.position && !emitter.isEnabled()) {
          continue;
        }
        this._renderingManager.dispatchParticles(particleSystem);
      }
      this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);
    }
    return currentRenderList;
  }
  /**
   * Gets the rendering manager
   */
  get renderingManager() {
    return this._renderingManager;
  }
  /**
   * Overrides the default sort function applied in the rendering group to prepare the meshes.
   * This allowed control for front to back rendering or reversely depending of the special needs.
   *
   * @param renderingGroupId The rendering group id corresponding to its index
   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
   * @param transparentSortCompareFn The transparent queue comparison function use to sort.
   */
  setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
  }
  /**
   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
   *
   * @param renderingGroupId The rendering group id corresponding to its index
   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
   * @param depth Automatically clears depth between groups if true and autoClear is true.
   * @param stencil Automatically clears stencil between groups if true and autoClear is true.
   */
  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {
    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);
    this._renderingManager._useSceneAutoClearSetup = false;
  }
  /**
   * Clones the renderer.
   * @returns the cloned renderer
   */
  clone() {
    const newRenderer = new _ObjectRenderer(this.name, this._scene, this.options);
    if (this.renderList) {
      newRenderer.renderList = this.renderList.slice(0);
    }
    return newRenderer;
  }
  /**
   * Dispose the renderer and release its associated resources.
   */
  dispose() {
    const renderList = this.renderList ? this.renderList : this._scene.getActiveMeshes().data;
    const renderListLength = this.renderList ? this.renderList.length : this._scene.getActiveMeshes().length;
    for (let i = 0; i < renderListLength; i++) {
      const mesh = renderList[i];
      if (mesh && mesh.getMaterialForRenderPass(this.renderPassId) !== void 0) {
        mesh.setMaterialForRenderPass(this.renderPassId, void 0);
      }
    }
    this.onInitRenderingObservable.clear();
    this.onFinishRenderingObservable.clear();
    this.onBeforeRenderObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onBeforeRenderingManagerRenderObservable.clear();
    this.onAfterRenderingManagerRenderObservable.clear();
    this.onFastPathRenderObservable.clear();
    this._releaseRenderPassId();
    this.renderList = null;
    if (this._sceneUBOs) {
      for (const ubo of this._sceneUBOs) {
        ubo.dispose();
      }
    }
    this._sceneUBOs = void 0;
    this._scene.removeObjectRenderer(this);
  }
  /** @internal */
  _rebuild() {
    if (this.refreshRate === _ObjectRenderer.REFRESHRATE_RENDER_ONCE) {
      this.refreshRate = _ObjectRenderer.REFRESHRATE_RENDER_ONCE;
    }
  }
  /**
   * Clear the info related to rendering groups preventing retention point in material dispose.
   */
  freeRenderingGroups() {
    if (this._renderingManager) {
      this._renderingManager.freeRenderingGroups();
    }
  }
};
ObjectRenderer.REFRESHRATE_RENDER_ONCE = 0;
ObjectRenderer.REFRESHRATE_RENDER_ONEVERYFRAME = 1;
ObjectRenderer.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;

// node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js
Effect.prototype.setDepthStencilTexture = function(channel, texture) {
  this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
};
var RenderTargetTexture = class _RenderTargetTexture extends Texture {
  /**
   * Use this predicate to dynamically define the list of mesh you want to render.
   * If set, the renderList property will be overwritten.
   */
  get renderListPredicate() {
    return this._objectRenderer.renderListPredicate;
  }
  set renderListPredicate(value) {
    this._objectRenderer.renderListPredicate = value;
  }
  /**
   * Use this list to define the list of mesh you want to render.
   */
  get renderList() {
    return this._objectRenderer.renderList;
  }
  set renderList(value) {
    this._objectRenderer.renderList = value;
  }
  /**
   * Define the list of particle systems to render in the texture. If not provided, will render all the particle systems of the scene.
   * Note that the particle systems are rendered only if renderParticles is set to true.
   */
  get particleSystemList() {
    return this._objectRenderer.particleSystemList;
  }
  set particleSystemList(value) {
    this._objectRenderer.particleSystemList = value;
  }
  /**
   * Use this function to overload the renderList array at rendering time.
   * Return null to render with the current renderList, else return the list of meshes to use for rendering.
   * For 2DArray RTT, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of
   * the cube (if the RTT is a cube, else layerOrFace=0).
   * The renderList passed to the function is the current render list (the one that will be used if the function returns null).
   * The length of this list is passed through renderListLength: don't use renderList.length directly because the array can
   * hold dummy elements!
   */
  get getCustomRenderList() {
    return this._objectRenderer.getCustomRenderList;
  }
  set getCustomRenderList(value) {
    this._objectRenderer.getCustomRenderList = value;
  }
  /**
   * Define if particles should be rendered in your texture (default: true).
   */
  get renderParticles() {
    return this._objectRenderer.renderParticles;
  }
  set renderParticles(value) {
    this._objectRenderer.renderParticles = value;
  }
  /**
   * Define if sprites should be rendered in your texture (default: false).
   */
  get renderSprites() {
    return this._objectRenderer.renderSprites;
  }
  set renderSprites(value) {
    this._objectRenderer.renderSprites = value;
  }
  /**
   * Define if bounding box rendering should be enabled (still subject to Mesh.showBoundingBox or scene.forceShowBoundingBoxes). (Default: false).
   */
  get enableBoundingBoxRendering() {
    return this._objectRenderer.enableBoundingBoxRendering;
  }
  set enableBoundingBoxRendering(value) {
    this._objectRenderer.enableBoundingBoxRendering = value;
  }
  /**
   * Define if outline/overlay rendering should be enabled (still subject to Mesh.renderOutline/Mesh.renderOverlay). (Default: true).
   */
  get enableOutlineRendering() {
    return this._objectRenderer.enableOutlineRendering;
  }
  set enableOutlineRendering(value) {
    this._objectRenderer.enableOutlineRendering = value;
  }
  /**
   * Force checking the layerMask property even if a custom list of meshes is provided (ie. if renderList is not undefined) (default: false).
   */
  get forceLayerMaskCheck() {
    return this._objectRenderer.forceLayerMaskCheck;
  }
  set forceLayerMaskCheck(value) {
    this._objectRenderer.forceLayerMaskCheck = value;
  }
  /**
   * Define the camera used to render the texture.
   */
  get activeCamera() {
    return this._objectRenderer.activeCamera;
  }
  set activeCamera(value) {
    this._objectRenderer.activeCamera = value;
  }
  /**
   * Define the camera used to calculate the LOD of the objects.
   * If not defined, activeCamera will be used. If not defined nor activeCamera, scene's active camera will be used.
   */
  get cameraForLOD() {
    return this._objectRenderer.cameraForLOD;
  }
  set cameraForLOD(value) {
    this._objectRenderer.cameraForLOD = value;
  }
  /**
   * If true, the renderer will render all objects without any image processing applied.
   * If false (default value), the renderer will use the current setting of the scene's image processing configuration.
   */
  get disableImageProcessing() {
    return this._objectRenderer.disableImageProcessing;
  }
  set disableImageProcessing(value) {
    this._objectRenderer.disableImageProcessing = value;
  }
  /**
   * Override the mesh isReady function with your own one.
   */
  get customIsReadyFunction() {
    return this._objectRenderer.customIsReadyFunction;
  }
  set customIsReadyFunction(value) {
    this._objectRenderer.customIsReadyFunction = value;
  }
  /**
   * Override the render function of the texture with your own one.
   */
  get customRenderFunction() {
    return this._objectRenderer.customRenderFunction;
  }
  set customRenderFunction(value) {
    this._objectRenderer.customRenderFunction = value;
  }
  /**
   * Post-processes for this render target
   */
  get postProcesses() {
    return this._postProcesses;
  }
  get _prePassEnabled() {
    return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;
  }
  /**
   * Set a after unbind callback in the texture.
   * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.
   */
  set onAfterUnbind(callback) {
    if (this._onAfterUnbindObserver) {
      this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
    }
    this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);
  }
  /**
   * An event triggered before rendering the texture
   */
  get onBeforeRenderObservable() {
    return this._objectRenderer.onBeforeRenderObservable;
  }
  /**
   * Set a before render callback in the texture.
   * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.
   */
  set onBeforeRender(callback) {
    if (this._onBeforeRenderObserver) {
      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
    }
    this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
  }
  /**
   * An event triggered after rendering the texture
   */
  get onAfterRenderObservable() {
    return this._objectRenderer.onAfterRenderObservable;
  }
  /**
   * Set a after render callback in the texture.
   * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.
   */
  set onAfterRender(callback) {
    if (this._onAfterRenderObserver) {
      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
    }
    this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
  }
  /**
   * Set a clear callback in the texture.
   * This has been kept for backward compatibility and use of onClearObservable is recommended.
   */
  set onClear(callback) {
    if (this._onClearObserver) {
      this.onClearObservable.remove(this._onClearObserver);
    }
    this._onClearObserver = this.onClearObservable.add(callback);
  }
  /** @internal */
  get _waitingRenderList() {
    return this._objectRenderer._waitingRenderList;
  }
  /** @internal */
  set _waitingRenderList(value) {
    this._objectRenderer._waitingRenderList = value;
  }
  /**
   * Current render pass id of the render target texture. Note it can change over the rendering as there's a separate id for each face of a cube / each layer of an array layer!
   */
  get renderPassId() {
    return this._objectRenderer.renderPassId;
  }
  /**
   * Gets the render pass ids used by the render target texture. For a single render target the array length will be 1, for a cube texture it will be 6 and for
   * a 2D texture array it will return an array of ids the size of the 2D texture array
   */
  get renderPassIds() {
    return this._objectRenderer.renderPassIds;
  }
  /**
   * Gets the current value of the refreshId counter
   */
  get currentRefreshId() {
    return this._objectRenderer.currentRefreshId;
  }
  /**
   * Sets a specific material to be used to render a mesh/a list of meshes in this render target texture
   * @param mesh mesh or array of meshes
   * @param material material or array of materials to use for this render pass. If undefined is passed, no specific material will be used but the regular material instead (mesh.material). It's possible to provide an array of materials to use a different material for each rendering in the case of a cube texture (6 rendering) and a 2D texture array (as many rendering as the length of the array)
   */
  setMaterialForRendering(mesh, material) {
    this._objectRenderer.setMaterialForRendering(mesh, material);
  }
  /**
   * Define if the texture has multiple draw buffers or if false a single draw buffer.
   */
  get isMulti() {
    var _a;
    return ((_a = this._renderTarget) == null ? void 0 : _a.isMulti) ?? false;
  }
  /**
   * Gets render target creation options that were used.
   */
  get renderTargetOptions() {
    return this._renderTargetOptions;
  }
  /**
   * Gets the render target wrapper associated with this render target
   */
  get renderTarget() {
    return this._renderTarget;
  }
  _onRatioRescale() {
    if (this._sizeRatio) {
      this.resize(this._initialSizeParameter);
    }
  }
  /**
   * Gets or sets the size of the bounding box associated with the texture (when in cube mode)
   * When defined, the cubemap will switch to local mode
   * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
   * @example https://www.babylonjs-playground.com/#RNASML
   */
  set boundingBoxSize(value) {
    if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
      return;
    }
    this._boundingBoxSize = value;
    const scene = this.getScene();
    if (scene) {
      scene.markAllMaterialsAsDirty(1);
    }
  }
  get boundingBoxSize() {
    return this._boundingBoxSize;
  }
  /**
   * In case the RTT has been created with a depth texture, get the associated
   * depth texture.
   * Otherwise, return null.
   */
  get depthStencilTexture() {
    var _a;
    return ((_a = this._renderTarget) == null ? void 0 : _a._depthStencilTexture) ?? null;
  }
  /** @internal */
  constructor(name, size, scene, generateMipMaps = false, doNotChangeAspectRatio = true, type = 0, isCube = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, generateDepthBuffer = true, generateStencilBuffer = false, isMulti = false, format = 5, delayAllocation = false, samples, creationFlags, noColorAttachment = false, useSRGBBuffer = false) {
    let colorAttachment = void 0;
    let gammaSpace = true;
    let existingObjectRenderer = void 0;
    let enableClusteredLights = false;
    if (typeof generateMipMaps === "object") {
      const options = generateMipMaps;
      generateMipMaps = !!options.generateMipMaps;
      doNotChangeAspectRatio = options.doNotChangeAspectRatio ?? true;
      type = options.type ?? 0;
      isCube = !!options.isCube;
      samplingMode = options.samplingMode ?? Texture.TRILINEAR_SAMPLINGMODE;
      generateDepthBuffer = options.generateDepthBuffer ?? true;
      generateStencilBuffer = !!options.generateStencilBuffer;
      isMulti = !!options.isMulti;
      format = options.format ?? 5;
      delayAllocation = !!options.delayAllocation;
      samples = options.samples;
      creationFlags = options.creationFlags;
      noColorAttachment = !!options.noColorAttachment;
      useSRGBBuffer = !!options.useSRGBBuffer;
      colorAttachment = options.colorAttachment;
      gammaSpace = options.gammaSpace ?? gammaSpace;
      existingObjectRenderer = options.existingObjectRenderer;
      enableClusteredLights = !!options.enableClusteredLights;
    }
    super(null, scene, !generateMipMaps, void 0, samplingMode, void 0, void 0, void 0, void 0, format);
    this.ignoreCameraViewport = false;
    this.onBeforeBindObservable = new Observable();
    this.onAfterUnbindObservable = new Observable();
    this.onClearObservable = new Observable();
    this.onResizeObservable = new Observable();
    this._cleared = false;
    this.skipInitialClear = false;
    this._samples = 1;
    this._canRescale = true;
    this._renderTarget = null;
    this._dontDisposeObjectRenderer = false;
    this.boundingBoxPosition = Vector3.Zero();
    this._disableEngineStages = false;
    this._dumpToolsLoading = false;
    scene = this.getScene();
    if (!scene) {
      return;
    }
    const engine = this.getScene().getEngine();
    this._gammaSpace = gammaSpace;
    this._coordinatesMode = Texture.PROJECTION_MODE;
    this.name = name;
    this.isRenderTarget = true;
    this._initialSizeParameter = size;
    this._dontDisposeObjectRenderer = !!existingObjectRenderer;
    this._processSizeParameter(size);
    this._objectRenderer = existingObjectRenderer ?? new ObjectRenderer(name, scene, {
      numPasses: isCube ? 6 : this.getRenderLayers() || 1,
      doNotChangeAspectRatio,
      enableClusteredLights
    });
    this._onBeforeRenderingManagerRenderObserver = this._objectRenderer.onBeforeRenderingManagerRenderObservable.add(() => {
      if (!this._disableEngineStages) {
        for (const step of this._scene._beforeRenderTargetClearStage) {
          step.action(this, this._currentFaceIndex, this._currentLayer);
        }
      }
      if (this.onClearObservable.hasObservers()) {
        this.onClearObservable.notifyObservers(engine);
      } else if (!this.skipInitialClear) {
        engine.clear(this.clearColor || this._scene.clearColor, true, true, true);
      }
      if (!this._doNotChangeAspectRatio) {
        this._scene.updateTransformMatrix(true);
      }
      if (!this._disableEngineStages) {
        for (const step of this._scene._beforeRenderTargetDrawStage) {
          step.action(this, this._currentFaceIndex, this._currentLayer);
        }
      }
    });
    this._onAfterRenderingManagerRenderObserver = this._objectRenderer.onAfterRenderingManagerRenderObservable.add(() => {
      var _a;
      if (!this._disableEngineStages) {
        for (const step of this._scene._afterRenderTargetDrawStage) {
          step.action(this, this._currentFaceIndex, this._currentLayer);
        }
      }
      const saveGenerateMipMaps = ((_a = this._texture) == null ? void 0 : _a.generateMipMaps) ?? false;
      if (this._texture) {
        this._texture.generateMipMaps = false;
      }
      if (this._postProcessManager) {
        this._postProcessManager._finalizeFrame(false, this._renderTarget ?? void 0, this._currentFaceIndex, this._postProcesses, this.ignoreCameraViewport);
      } else if (this._currentUseCameraPostProcess) {
        this._scene.postProcessManager._finalizeFrame(false, this._renderTarget ?? void 0, this._currentFaceIndex);
      }
      if (!this._disableEngineStages) {
        for (const step of this._scene._afterRenderTargetPostProcessStage) {
          step.action(this, this._currentFaceIndex, this._currentLayer);
        }
      }
      if (this._texture) {
        this._texture.generateMipMaps = saveGenerateMipMaps;
      }
      if (!this._doNotChangeAspectRatio) {
        this._scene.updateTransformMatrix(true);
      }
      if (this._currentDumpForDebug) {
        if (!this._dumpTools) {
          Logger.Error("dumpTools module is still being loaded. To speed up the process import dump tools directly in your project");
        } else {
          this._dumpTools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);
        }
      }
    });
    this._onFastPathRenderObserver = this._objectRenderer.onFastPathRenderObservable.add(() => {
      if (this.onClearObservable.hasObservers()) {
        this.onClearObservable.notifyObservers(engine);
      } else {
        if (!this.skipInitialClear) {
          engine.clear(this.clearColor || this._scene.clearColor, true, true, true);
        }
      }
    });
    this._resizeObserver = engine.onResizeObservable.add(() => {
    });
    this._generateMipMaps = generateMipMaps ? true : false;
    this._doNotChangeAspectRatio = doNotChangeAspectRatio;
    if (isMulti) {
      return;
    }
    this._renderTargetOptions = {
      generateMipMaps,
      type,
      format: this._format ?? void 0,
      samplingMode: this.samplingMode,
      generateDepthBuffer,
      generateStencilBuffer,
      samples,
      creationFlags,
      noColorAttachment,
      useSRGBBuffer,
      colorAttachment,
      label: this.name
    };
    if (this.samplingMode === Texture.NEAREST_SAMPLINGMODE) {
      this.wrapU = Texture.CLAMP_ADDRESSMODE;
      this.wrapV = Texture.CLAMP_ADDRESSMODE;
    }
    if (!delayAllocation) {
      if (isCube) {
        this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);
        this.coordinatesMode = Texture.INVCUBIC_MODE;
        this._textureMatrix = Matrix.Identity();
      } else {
        this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);
      }
      this._texture = this._renderTarget.texture;
      if (samples !== void 0) {
        this.samples = samples;
      }
    }
  }
  /**
   * Creates a depth stencil texture.
   * This is only available in WebGL 2 or with the depth texture extension available.
   * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode (default: 0)
   * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture (default: true)
   * @param generateStencil Specifies whether or not a stencil should be allocated in the texture (default: false)
   * @param samples sample count of the depth/stencil texture (default: 1)
   * @param format format of the depth texture (default: 14)
   * @param label defines the label of the texture (for debugging purpose)
   */
  createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14, label) {
    var _a;
    (_a = this._renderTarget) == null ? void 0 : _a.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format, label);
  }
  _processSizeParameter(size) {
    if (size.ratio) {
      this._sizeRatio = size.ratio;
      const engine = this._getEngine();
      this._size = {
        width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),
        height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio)
      };
    } else {
      this._size = size;
    }
  }
  /**
   * Define the number of samples to use in case of MSAA.
   * It defaults to one meaning no MSAA has been enabled.
   */
  get samples() {
    var _a;
    return ((_a = this._renderTarget) == null ? void 0 : _a.samples) ?? this._samples;
  }
  set samples(value) {
    if (this._renderTarget) {
      this._samples = this._renderTarget.setSamples(value);
    }
  }
  /**
   * Adds a post process to the render target rendering passes.
   * @param postProcess define the post process to add
   */
  addPostProcess(postProcess) {
    if (!this._postProcessManager) {
      const scene = this.getScene();
      if (!scene) {
        return;
      }
      this._postProcessManager = new PostProcessManager(scene);
      this._postProcesses = new Array();
    }
    this._postProcesses.push(postProcess);
    this._postProcesses[0].autoClear = false;
  }
  /**
   * Clear all the post processes attached to the render target
   * @param dispose define if the cleared post processes should also be disposed (false by default)
   */
  clearPostProcesses(dispose = false) {
    if (!this._postProcesses) {
      return;
    }
    if (dispose) {
      for (const postProcess of this._postProcesses) {
        postProcess.dispose();
      }
    }
    this._postProcesses = [];
  }
  /**
   * Remove one of the post process from the list of attached post processes to the texture
   * @param postProcess define the post process to remove from the list
   */
  removePostProcess(postProcess) {
    if (!this._postProcesses) {
      return;
    }
    const index = this._postProcesses.indexOf(postProcess);
    if (index === -1) {
      return;
    }
    this._postProcesses.splice(index, 1);
    if (this._postProcesses.length > 0) {
      this._postProcesses[0].autoClear = false;
    }
  }
  /**
   * Resets the refresh counter of the texture and start bak from scratch.
   * Could be useful to regenerate the texture if it is setup to render only once.
   */
  resetRefreshCounter() {
    this._objectRenderer.resetRefreshCounter();
  }
  /**
   * Define the refresh rate of the texture or the rendering frequency.
   * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
   */
  get refreshRate() {
    return this._objectRenderer.refreshRate;
  }
  set refreshRate(value) {
    this._objectRenderer.refreshRate = value;
  }
  /** @internal */
  _shouldRender() {
    return this._objectRenderer.shouldRender();
  }
  /**
   * Gets the actual render size of the texture.
   * @returns the width of the render size
   */
  getRenderSize() {
    return this.getRenderWidth();
  }
  /**
   * Gets the actual render width of the texture.
   * @returns the width of the render size
   */
  getRenderWidth() {
    if (this._size.width) {
      return this._size.width;
    }
    return this._size;
  }
  /**
   * Gets the actual render height of the texture.
   * @returns the height of the render size
   */
  getRenderHeight() {
    if (this._size.width) {
      return this._size.height;
    }
    return this._size;
  }
  /**
   * Gets the actual number of layers of the texture or, in the case of a 3D texture, return the depth.
   * @returns the number of layers
   */
  getRenderLayers() {
    const layers = this._size.layers;
    if (layers) {
      return layers;
    }
    const depth = this._size.depth;
    if (depth) {
      return depth;
    }
    return 0;
  }
  /**
   * Don't allow this render target texture to rescale. Mainly used to prevent rescaling by the scene optimizer.
   */
  disableRescaling() {
    this._canRescale = false;
  }
  /**
   * Get if the texture can be rescaled or not.
   */
  get canRescale() {
    return this._canRescale;
  }
  /**
   * Resize the texture using a ratio.
   * @param ratio the ratio to apply to the texture size in order to compute the new target size
   */
  scale(ratio) {
    const newSize = Math.max(1, this.getRenderSize() * ratio);
    this.resize(newSize);
  }
  /**
   * Get the texture reflection matrix used to rotate/transform the reflection.
   * @returns the reflection matrix
   */
  getReflectionTextureMatrix() {
    if (this.isCube) {
      return this._textureMatrix;
    }
    return super.getReflectionTextureMatrix();
  }
  /**
   * Resize the texture to a new desired size.
   * Be careful as it will recreate all the data in the new texture.
   * @param size Define the new size. It can be:
   *   - a number for squared texture,
   *   - an object containing { width: number, height: number }
   *   - or an object containing a ratio { ratio: number }
   */
  resize(size) {
    var _a;
    const wasCube = this.isCube;
    (_a = this._renderTarget) == null ? void 0 : _a.dispose();
    this._renderTarget = null;
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    this._processSizeParameter(size);
    if (wasCube) {
      this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);
    } else {
      this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);
    }
    this._texture = this._renderTarget.texture;
    if (this._renderTargetOptions.samples !== void 0) {
      this.samples = this._renderTargetOptions.samples;
    }
    if (this.onResizeObservable.hasObservers()) {
      this.onResizeObservable.notifyObservers(this);
    }
  }
  /**
   * Renders all the objects from the render list into the texture.
   * @param useCameraPostProcess Define if camera post processes should be used during the rendering
   * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose
   */
  render(useCameraPostProcess = false, dumpForDebug = false) {
    this._render(useCameraPostProcess, dumpForDebug);
  }
  /**
   * This function will check if the render target texture can be rendered (textures are loaded, shaders are compiled)
   * @returns true if all required resources are ready
   */
  isReadyForRendering() {
    if (!this._dumpToolsLoading) {
      this._dumpToolsLoading = true;
      import("./dumpTools-Y7EFZLEL.js").then((module) => this._dumpTools = module);
    }
    this._objectRenderer.prepareRenderList();
    this.onBeforeBindObservable.notifyObservers(this);
    this._objectRenderer.initRender(this.getRenderWidth(), this.getRenderHeight());
    const isReady = this._objectRenderer._checkReadiness();
    this.onAfterUnbindObservable.notifyObservers(this);
    this._objectRenderer.finishRender();
    return isReady;
  }
  _render(useCameraPostProcess = false, dumpForDebug = false) {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    if (this.useCameraPostProcesses !== void 0) {
      useCameraPostProcess = this.useCameraPostProcesses;
    }
    this._objectRenderer.prepareRenderList();
    this.onBeforeBindObservable.notifyObservers(this);
    this._objectRenderer.initRender(this.getRenderWidth(), this.getRenderHeight());
    if ((this.is2DArray || this.is3D) && !this.isMulti) {
      for (let layer = 0; layer < this.getRenderLayers(); layer++) {
        this._renderToTarget(0, useCameraPostProcess, dumpForDebug, layer);
        scene.incrementRenderId();
        scene.resetCachedMaterial();
      }
    } else if (this.isCube && !this.isMulti) {
      for (let face = 0; face < 6; face++) {
        this._renderToTarget(face, useCameraPostProcess, dumpForDebug);
        scene.incrementRenderId();
        scene.resetCachedMaterial();
      }
    } else {
      this._renderToTarget(0, useCameraPostProcess, dumpForDebug);
    }
    this.onAfterUnbindObservable.notifyObservers(this);
    this._objectRenderer.finishRender();
  }
  _bestReflectionRenderTargetDimension(renderDimension, scale) {
    const minimum = 128;
    const x = renderDimension * scale;
    const curved = NearestPOT(x + minimum * minimum / (minimum + x));
    return Math.min(FloorPOT(renderDimension), curved);
  }
  /**
   * @internal
   * @param faceIndex face index to bind to if this is a cubetexture
   * @param layer defines the index of the texture to bind in the array
   */
  _bindFrameBuffer(faceIndex = 0, layer = 0) {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const engine = scene.getEngine();
    if (this._renderTarget) {
      engine.bindFramebuffer(this._renderTarget, this.isCube ? faceIndex : void 0, void 0, void 0, this.ignoreCameraViewport, 0, layer);
    }
  }
  _unbindFrameBuffer(engine, faceIndex) {
    if (!this._renderTarget) {
      return;
    }
    engine.unBindFramebuffer(this._renderTarget, this.isCube, () => {
      this.onAfterRenderObservable.notifyObservers(faceIndex);
    });
  }
  /**
   * @internal
   */
  _prepareFrame(scene, faceIndex, layer, useCameraPostProcess) {
    if (this._postProcessManager) {
      if (!this._prePassEnabled) {
        if (!this._postProcessManager._prepareFrame(this._texture, this._postProcesses)) {
          this._bindFrameBuffer(faceIndex, layer);
        }
      }
    } else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {
      this._bindFrameBuffer(faceIndex, layer);
    }
  }
  _renderToTarget(faceIndex, useCameraPostProcess, dumpForDebug, layer = 0) {
    var _a, _b;
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const engine = scene.getEngine();
    this._currentFaceIndex = faceIndex;
    this._currentLayer = layer;
    this._currentUseCameraPostProcess = useCameraPostProcess;
    this._currentDumpForDebug = dumpForDebug;
    this._prepareFrame(scene, faceIndex, layer, useCameraPostProcess);
    (_a = engine._debugPushGroup) == null ? void 0 : _a.call(engine, `render to face #${faceIndex} layer #${layer}`, 2);
    this._objectRenderer.render(faceIndex + layer, true);
    (_b = engine._debugPopGroup) == null ? void 0 : _b.call(engine, 2);
    this._unbindFrameBuffer(engine, faceIndex);
    if (this._texture && this.isCube && faceIndex === 5) {
      engine.generateMipMapsForCubemap(this._texture, true);
    }
  }
  /**
   * Overrides the default sort function applied in the rendering group to prepare the meshes.
   * This allowed control for front to back rendering or reversely depending of the special needs.
   *
   * @param renderingGroupId The rendering group id corresponding to its index
   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
   * @param transparentSortCompareFn The transparent queue comparison function use to sort.
   */
  setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
    this._objectRenderer.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
  }
  /**
   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
   *
   * @param renderingGroupId The rendering group id corresponding to its index
   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
   */
  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {
    this._objectRenderer.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);
  }
  /**
   * Clones the texture.
   * @returns the cloned texture
   */
  clone() {
    const textureSize = this.getSize();
    const newTexture = new _RenderTargetTexture(this.name, textureSize, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer, void 0, this._renderTargetOptions.format, void 0, this._renderTargetOptions.samples);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.coordinatesMode = this.coordinatesMode;
    if (this.renderList) {
      newTexture.renderList = this.renderList.slice(0);
    }
    return newTexture;
  }
  /**
   * Serialize the texture to a JSON representation we can easily use in the respective Parse function.
   * @returns The JSON representation of the texture
   */
  serialize() {
    if (!this.name) {
      return null;
    }
    const serializationObject = super.serialize();
    serializationObject.renderTargetSize = this.getRenderSize();
    serializationObject.renderList = [];
    if (this.renderList) {
      for (let index = 0; index < this.renderList.length; index++) {
        serializationObject.renderList.push(this.renderList[index].id);
      }
    }
    return serializationObject;
  }
  /**
   *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore
   */
  disposeFramebufferObjects() {
    var _a;
    (_a = this._renderTarget) == null ? void 0 : _a.dispose(true);
  }
  /**
   * Release and destroy the underlying lower level texture aka internalTexture.
   */
  releaseInternalTexture() {
    var _a;
    (_a = this._renderTarget) == null ? void 0 : _a.releaseTextures();
    this._texture = null;
  }
  /**
   * Dispose the texture and release its associated resources.
   */
  dispose() {
    var _a;
    this.onResizeObservable.clear();
    this.onClearObservable.clear();
    this.onAfterUnbindObservable.clear();
    this.onBeforeBindObservable.clear();
    if (this._postProcessManager) {
      this._postProcessManager.dispose();
      this._postProcessManager = null;
    }
    if (this._prePassRenderTarget) {
      this._prePassRenderTarget.dispose();
    }
    this._objectRenderer.onBeforeRenderingManagerRenderObservable.remove(this._onBeforeRenderingManagerRenderObserver);
    this._objectRenderer.onAfterRenderingManagerRenderObservable.remove(this._onAfterRenderingManagerRenderObserver);
    this._objectRenderer.onFastPathRenderObservable.remove(this._onFastPathRenderObserver);
    if (!this._dontDisposeObjectRenderer) {
      this._objectRenderer.dispose();
    }
    this.clearPostProcesses(true);
    if (this._resizeObserver) {
      this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver);
      this._resizeObserver = null;
    }
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    let index = scene.customRenderTargets.indexOf(this);
    if (index >= 0) {
      scene.customRenderTargets.splice(index, 1);
    }
    for (const camera of scene.cameras) {
      index = camera.customRenderTargets.indexOf(this);
      if (index >= 0) {
        camera.customRenderTargets.splice(index, 1);
      }
    }
    (_a = this._renderTarget) == null ? void 0 : _a.dispose();
    this._renderTarget = null;
    this._texture = null;
    super.dispose();
  }
  /** @internal */
  _rebuild() {
    this._objectRenderer._rebuild();
    if (this._postProcessManager) {
      this._postProcessManager._rebuild();
    }
  }
  /**
   * Clear the info related to rendering groups preventing retention point in material dispose.
   */
  freeRenderingGroups() {
    this._objectRenderer.freeRenderingGroups();
  }
  /**
   * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)
   * @returns the view count
   */
  getViewCount() {
    return 1;
  }
};
RenderTargetTexture.REFRESHRATE_RENDER_ONCE = ObjectRenderer.REFRESHRATE_RENDER_ONCE;
RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME = ObjectRenderer.REFRESHRATE_RENDER_ONEVERYFRAME;
RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = ObjectRenderer.REFRESHRATE_RENDER_ONEVERYTWOFRAMES;
Texture._CreateRenderTargetTexture = (name, renderTargetSize, scene, generateMipMaps, creationFlags) => {
  return new RenderTargetTexture(name, renderTargetSize, scene, generateMipMaps);
};

// node_modules/@babylonjs/core/PostProcesses/postProcess.js
AbstractEngine.prototype.setTextureFromPostProcess = function(channel, postProcess, name) {
  let postProcessInput = null;
  if (postProcess) {
    if (postProcess._forcedOutputTexture) {
      postProcessInput = postProcess._forcedOutputTexture;
    } else if (postProcess._textures.data[postProcess._currentRenderTextureInd]) {
      postProcessInput = postProcess._textures.data[postProcess._currentRenderTextureInd];
    }
  }
  this._bindTexture(channel, (postProcessInput == null ? void 0 : postProcessInput.texture) ?? null, name);
};
AbstractEngine.prototype.setTextureFromPostProcessOutput = function(channel, postProcess, name) {
  var _a;
  this._bindTexture(channel, ((_a = postProcess == null ? void 0 : postProcess._outputTexture) == null ? void 0 : _a.texture) ?? null, name);
};
Effect.prototype.setTextureFromPostProcess = function(channel, postProcess) {
  this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);
};
Effect.prototype.setTextureFromPostProcessOutput = function(channel, postProcess) {
  this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);
};
var PostProcess = class _PostProcess {
  /**
   * Force all the postprocesses to compile to glsl even on WebGPU engines.
   * False by default. This is mostly meant for backward compatibility.
   */
  static get ForceGLSL() {
    return EffectWrapper.ForceGLSL;
  }
  static set ForceGLSL(force) {
    EffectWrapper.ForceGLSL = force;
  }
  /**
   * Registers a shader code processing with a post process name.
   * @param postProcessName name of the post process. Use null for the fallback shader code processing. This is the shader code processing that will be used in case no specific shader code processing has been associated to a post process name
   * @param customShaderCodeProcessing shader code processing to associate to the post process name
   */
  static RegisterShaderCodeProcessing(postProcessName, customShaderCodeProcessing) {
    EffectWrapper.RegisterShaderCodeProcessing(postProcessName, customShaderCodeProcessing);
  }
  /** Name of the PostProcess. */
  get name() {
    return this._effectWrapper.name;
  }
  set name(value) {
    this._effectWrapper.name = value;
  }
  /**
   * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)
   */
  get alphaMode() {
    return this._effectWrapper.alphaMode;
  }
  set alphaMode(value) {
    this._effectWrapper.alphaMode = value;
  }
  /**
   * Number of sample textures (default: 1)
   */
  get samples() {
    return this._samples;
  }
  set samples(n) {
    this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);
    this._textures.forEach((texture) => {
      texture.setSamples(this._samples);
    });
  }
  /**
   * Gets the shader language type used to generate vertex and fragment source code.
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  /**
   * Returns the fragment url or shader name used in the post process.
   * @returns the fragment url or name in the shader store.
   */
  getEffectName() {
    return this._fragmentUrl;
  }
  /**
   * A function that is added to the onActivateObservable
   */
  set onActivate(callback) {
    if (this._onActivateObserver) {
      this.onActivateObservable.remove(this._onActivateObserver);
    }
    if (callback) {
      this._onActivateObserver = this.onActivateObservable.add(callback);
    }
  }
  /**
   * A function that is added to the onSizeChangedObservable
   */
  set onSizeChanged(callback) {
    if (this._onSizeChangedObserver) {
      this.onSizeChangedObservable.remove(this._onSizeChangedObserver);
    }
    this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);
  }
  /**
   * A function that is added to the onApplyObservable
   */
  set onApply(callback) {
    if (this._onApplyObserver) {
      this.onApplyObservable.remove(this._onApplyObserver);
    }
    this._onApplyObserver = this.onApplyObservable.add(callback);
  }
  /**
   * A function that is added to the onBeforeRenderObservable
   */
  set onBeforeRender(callback) {
    if (this._onBeforeRenderObserver) {
      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
    }
    this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
  }
  /**
   * A function that is added to the onAfterRenderObservable
   */
  set onAfterRender(callback) {
    if (this._onAfterRenderObserver) {
      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
    }
    this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
  }
  /**
   * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will
   * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.
   */
  get inputTexture() {
    return this._textures.data[this._currentRenderTextureInd];
  }
  set inputTexture(value) {
    this._forcedOutputTexture = value;
  }
  /**
   * Since inputTexture should always be defined, if we previously manually set `inputTexture`,
   * the only way to unset it is to use this function to restore its internal state
   */
  restoreDefaultInputTexture() {
    if (this._forcedOutputTexture) {
      this._forcedOutputTexture = null;
      this.markTextureDirty();
    }
  }
  /**
   * Gets the camera which post process is applied to.
   * @returns The camera the post process is applied to.
   */
  getCamera() {
    return this._camera;
  }
  /**
   * Gets the texel size of the postprocess.
   * See https://en.wikipedia.org/wiki/Texel_(graphics)
   */
  get texelSize() {
    if (this._shareOutputWithPostProcess) {
      return this._shareOutputWithPostProcess.texelSize;
    }
    if (this._forcedOutputTexture) {
      this._texelSize.copyFromFloats(1 / this._forcedOutputTexture.width, 1 / this._forcedOutputTexture.height);
    }
    return this._texelSize;
  }
  /** @internal */
  constructor(name, fragmentUrl, parameters, samplers, _size, camera, samplingMode = 1, engine, reusable, defines = null, textureType = 0, vertexUrl = "postprocess", indexParameters, blockCompilation = false, textureFormat = 5, shaderLanguage, extraInitializations) {
    this._parentContainer = null;
    this.width = -1;
    this.height = -1;
    this.nodeMaterialSource = null;
    this._outputTexture = null;
    this.autoClear = true;
    this.forceAutoClearInAlphaMode = false;
    this.animations = [];
    this.enablePixelPerfectMode = false;
    this.forceFullscreenViewport = true;
    this.scaleMode = 1;
    this.alwaysForcePOT = false;
    this._samples = 1;
    this.adaptScaleToCurrentViewport = false;
    this._webGPUReady = false;
    this._reusable = false;
    this._renderId = 0;
    this.externalTextureSamplerBinding = false;
    this._textures = new SmartArray(2);
    this._textureCache = [];
    this._currentRenderTextureInd = 0;
    this._scaleRatio = new Vector2(1, 1);
    this._texelSize = Vector2.Zero();
    this.onActivateObservable = new Observable();
    this.onSizeChangedObservable = new Observable();
    this.onApplyObservable = new Observable();
    this.onBeforeRenderObservable = new Observable();
    this.onAfterRenderObservable = new Observable();
    this.onDisposeObservable = new Observable();
    let size = 1;
    let uniformBuffers = null;
    let effectWrapper;
    if (parameters && !Array.isArray(parameters)) {
      const options = parameters;
      parameters = options.uniforms ?? null;
      samplers = options.samplers ?? null;
      size = options.size ?? 1;
      camera = options.camera ?? null;
      samplingMode = options.samplingMode ?? 1;
      engine = options.engine;
      reusable = options.reusable;
      defines = Array.isArray(options.defines) ? options.defines.join("\n") : options.defines ?? null;
      textureType = options.textureType ?? 0;
      vertexUrl = options.vertexUrl ?? "postprocess";
      indexParameters = options.indexParameters;
      blockCompilation = options.blockCompilation ?? false;
      textureFormat = options.textureFormat ?? 5;
      shaderLanguage = options.shaderLanguage ?? 0;
      uniformBuffers = options.uniformBuffers ?? null;
      extraInitializations = options.extraInitializations;
      effectWrapper = options.effectWrapper;
    } else if (_size) {
      if (typeof _size === "number") {
        size = _size;
      } else {
        size = { width: _size.width, height: _size.height };
      }
    }
    this._useExistingThinPostProcess = !!effectWrapper;
    this._effectWrapper = effectWrapper ?? new EffectWrapper({
      name,
      useShaderStore: true,
      useAsPostProcess: true,
      fragmentShader: fragmentUrl,
      engine: engine || (camera == null ? void 0 : camera.getScene().getEngine()),
      uniforms: parameters,
      samplers,
      uniformBuffers,
      defines,
      vertexUrl,
      indexParameters,
      blockCompilation: true,
      shaderLanguage,
      extraInitializations: void 0
    });
    this.name = name;
    this.onEffectCreatedObservable = this._effectWrapper.onEffectCreatedObservable;
    if (camera != null) {
      this._camera = camera;
      this._scene = camera.getScene();
      camera.attachPostProcess(this);
      this._engine = this._scene.getEngine();
      this._scene.addPostProcess(this);
      this.uniqueId = this._scene.getUniqueId();
    } else if (engine) {
      this._engine = engine;
      this._engine.postProcesses.push(this);
    }
    this._options = size;
    this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;
    this._reusable = reusable || false;
    this._textureType = textureType;
    this._textureFormat = textureFormat;
    this._shaderLanguage = shaderLanguage || 0;
    this._samplers = samplers || [];
    if (this._samplers.indexOf("textureSampler") === -1) {
      this._samplers.push("textureSampler");
    }
    this._fragmentUrl = fragmentUrl;
    this._vertexUrl = vertexUrl;
    this._parameters = parameters || [];
    if (this._parameters.indexOf("scale") === -1) {
      this._parameters.push("scale");
    }
    this._uniformBuffers = uniformBuffers || [];
    this._indexParameters = indexParameters;
    if (!this._useExistingThinPostProcess) {
      this._webGPUReady = this._shaderLanguage === 1;
      const importPromises = [];
      this._gatherImports(this._engine.isWebGPU && !_PostProcess.ForceGLSL, importPromises);
      this._effectWrapper._webGPUReady = this._webGPUReady;
      this._effectWrapper._postConstructor(blockCompilation, defines, extraInitializations, importPromises);
    }
  }
  _gatherImports(useWebGPU = false, list) {
    if (useWebGPU && this._webGPUReady) {
      list.push(Promise.all([import("./postprocess.vertex-S5GTK4SE.js")]));
    } else {
      list.push(Promise.all([import("./postprocess.vertex-QTZG3BMK.js")]));
    }
  }
  /**
   * Gets a string identifying the name of the class
   * @returns "PostProcess" string
   */
  getClassName() {
    return "PostProcess";
  }
  /**
   * Gets the engine which this post process belongs to.
   * @returns The engine the post process was enabled with.
   */
  getEngine() {
    return this._engine;
  }
  /**
   * The effect that is created when initializing the post process.
   * @returns The created effect corresponding to the postprocess.
   */
  getEffect() {
    return this._effectWrapper.drawWrapper.effect;
  }
  /**
   * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.
   * @param postProcess The post process to share the output with.
   * @returns This post process.
   */
  shareOutputWith(postProcess) {
    this._disposeTextures();
    this._shareOutputWithPostProcess = postProcess;
    return this;
  }
  /**
   * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.
   * This should be called if the post process that shares output with this post process is disabled/disposed.
   */
  useOwnOutput() {
    if (this._textures.length == 0) {
      this._textures = new SmartArray(2);
    }
    this._shareOutputWithPostProcess = null;
  }
  /**
   * Updates the effect with the current post process compile time values and recompiles the shader.
   * @param defines Define statements that should be added at the beginning of the shader. (default: null)
   * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
   * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
   * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
   * @param onCompiled Called when the shader has been compiled.
   * @param onError Called if there is an error when compiling a shader.
   * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)
   * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)
   */
  updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {
    this._effectWrapper.updateEffect(defines, uniforms, samplers, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl);
    this._postProcessDefines = Array.isArray(this._effectWrapper.options.defines) ? this._effectWrapper.options.defines.join("\n") : this._effectWrapper.options.defines;
  }
  /**
   * The post process is reusable if it can be used multiple times within one frame.
   * @returns If the post process is reusable
   */
  isReusable() {
    return this._reusable;
  }
  /** invalidate frameBuffer to hint the postprocess to create a depth buffer */
  markTextureDirty() {
    this.width = -1;
  }
  _createRenderTargetTexture(textureSize, textureOptions, channel = 0) {
    for (let i = 0; i < this._textureCache.length; i++) {
      if (this._textureCache[i].texture.width === textureSize.width && this._textureCache[i].texture.height === textureSize.height && this._textureCache[i].postProcessChannel === channel && this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer && this._textureCache[i].texture.samples === textureOptions.samples) {
        return this._textureCache[i].texture;
      }
    }
    const tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);
    this._textureCache.push({ texture: tex, postProcessChannel: channel, lastUsedRenderId: -1 });
    return tex;
  }
  _flushTextureCache() {
    const currentRenderId = this._renderId;
    for (let i = this._textureCache.length - 1; i >= 0; i--) {
      if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {
        let currentlyUsed = false;
        for (let j = 0; j < this._textures.length; j++) {
          if (this._textures.data[j] === this._textureCache[i].texture) {
            currentlyUsed = true;
            break;
          }
        }
        if (!currentlyUsed) {
          this._textureCache[i].texture.dispose();
          this._textureCache.splice(i, 1);
        }
      }
    }
  }
  /**
   * Resizes the post-process texture
   * @param width Width of the texture
   * @param height Height of the texture
   * @param camera The camera this post-process is applied to. Pass null if the post-process is used outside the context of a camera post-process chain (default: null)
   * @param needMipMaps True if mip maps need to be generated after render (default: false)
   * @param forceDepthStencil True to force post-process texture creation with stencil depth and buffer (default: false)
   */
  resize(width, height, camera = null, needMipMaps = false, forceDepthStencil = false) {
    if (this._textures.length > 0) {
      this._textures.reset();
    }
    this.width = width;
    this.height = height;
    let firstPP = null;
    if (camera) {
      for (let i = 0; i < camera._postProcesses.length; i++) {
        if (camera._postProcesses[i] !== null) {
          firstPP = camera._postProcesses[i];
          break;
        }
      }
    }
    const textureSize = { width: this.width, height: this.height };
    const textureOptions = {
      generateMipMaps: needMipMaps,
      generateDepthBuffer: forceDepthStencil || firstPP === this,
      generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,
      samplingMode: this.renderTargetSamplingMode,
      type: this._textureType,
      format: this._textureFormat,
      samples: this._samples,
      label: "PostProcessRTT-" + this.name
    };
    this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));
    if (this._reusable) {
      this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));
    }
    this._texelSize.copyFromFloats(1 / this.width, 1 / this.height);
    this.onSizeChangedObservable.notifyObservers(this);
  }
  _getTarget() {
    let target;
    if (this._shareOutputWithPostProcess) {
      target = this._shareOutputWithPostProcess.inputTexture;
    } else if (this._forcedOutputTexture) {
      target = this._forcedOutputTexture;
      this.width = this._forcedOutputTexture.width;
      this.height = this._forcedOutputTexture.height;
    } else {
      target = this.inputTexture;
      let cache;
      for (let i = 0; i < this._textureCache.length; i++) {
        if (this._textureCache[i].texture === target) {
          cache = this._textureCache[i];
          break;
        }
      }
      if (cache) {
        cache.lastUsedRenderId = this._renderId;
      }
    }
    return target;
  }
  /**
   * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.
   * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.
   * @param cameraOrScene The camera that will be used in the post process. This camera will be used when calling onActivateObservable. You can also pass the scene if no camera is available.
   * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)
   * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)
   * @returns The render target wrapper that was bound to be written to.
   */
  activate(cameraOrScene, sourceTexture = null, forceDepthStencil) {
    var _a, _b;
    const camera = cameraOrScene === null || cameraOrScene.cameraRigMode !== void 0 ? cameraOrScene || this._camera : null;
    const scene = (camera == null ? void 0 : camera.getScene()) ?? cameraOrScene;
    const engine = scene.getEngine();
    const maxSize = engine.getCaps().maxTextureSize;
    const requiredWidth = (sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * this._options | 0;
    const requiredHeight = (sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * this._options | 0;
    let desiredWidth = this._options.width || requiredWidth;
    let desiredHeight = this._options.height || requiredHeight;
    const needMipMaps = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;
    let target = null;
    if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {
      if (this.adaptScaleToCurrentViewport) {
        const currentViewport = engine.currentViewport;
        if (currentViewport) {
          desiredWidth *= currentViewport.width;
          desiredHeight *= currentViewport.height;
        }
      }
      if (needMipMaps || this.alwaysForcePOT) {
        if (!this._options.width) {
          desiredWidth = engine.needPOTTextures ? GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;
        }
        if (!this._options.height) {
          desiredHeight = engine.needPOTTextures ? GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;
        }
      }
      if (this.width !== desiredWidth || this.height !== desiredHeight || !(target = this._getTarget())) {
        this.resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);
      }
      this._textures.forEach((texture) => {
        if (texture.samples !== this.samples) {
          this._engine.updateRenderTargetTextureSampleCount(texture, this.samples);
        }
      });
      this._flushTextureCache();
      this._renderId++;
    }
    if (!target) {
      target = this._getTarget();
    }
    if (this.enablePixelPerfectMode) {
      this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);
      this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);
    } else {
      this._scaleRatio.copyFromFloats(1, 1);
      this._engine.bindFramebuffer(target, 0, void 0, void 0, this.forceFullscreenViewport);
    }
    (_b = (_a = this._engine)._debugInsertMarker) == null ? void 0 : _b.call(_a, `post process ${this.name} input`);
    this.onActivateObservable.notifyObservers(camera);
    if (this.autoClear && (this.alphaMode === 0 || this.forceAutoClearInAlphaMode)) {
      this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);
    }
    if (this._reusable) {
      this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;
    }
    return target;
  }
  /**
   * If the post process is supported.
   */
  get isSupported() {
    return this._effectWrapper.drawWrapper.effect.isSupported;
  }
  /**
   * The aspect ratio of the output texture.
   */
  get aspectRatio() {
    if (this._shareOutputWithPostProcess) {
      return this._shareOutputWithPostProcess.aspectRatio;
    }
    if (this._forcedOutputTexture) {
      return this._forcedOutputTexture.width / this._forcedOutputTexture.height;
    }
    return this.width / this.height;
  }
  /**
   * Get a value indicating if the post-process is ready to be used
   * @returns true if the post-process is ready (shader is compiled)
   */
  isReady() {
    return this._effectWrapper.isReady();
  }
  /**
   * Binds all textures and uniforms to the shader, this will be run on every pass.
   * @returns the effect corresponding to this post process. Null if not compiled or not ready.
   */
  apply() {
    if (!this._effectWrapper.isReady()) {
      return null;
    }
    this._engine.enableEffect(this._effectWrapper.drawWrapper);
    this._engine.setState(false);
    this._engine.setDepthBuffer(false);
    this._engine.setDepthWrite(false);
    if (this.alphaConstants) {
      this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);
    }
    this._engine.setAlphaMode(this.alphaMode);
    let source;
    if (this._shareOutputWithPostProcess) {
      source = this._shareOutputWithPostProcess.inputTexture;
    } else if (this._forcedOutputTexture) {
      source = this._forcedOutputTexture;
    } else {
      source = this.inputTexture;
    }
    if (!this.externalTextureSamplerBinding) {
      this._effectWrapper.drawWrapper.effect._bindTexture("textureSampler", source == null ? void 0 : source.texture);
    }
    this._effectWrapper.drawWrapper.effect.setVector2("scale", this._scaleRatio);
    this.onApplyObservable.notifyObservers(this._effectWrapper.drawWrapper.effect);
    this._effectWrapper.bind(true);
    return this._effectWrapper.drawWrapper.effect;
  }
  _disposeTextures() {
    if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {
      this._disposeTextureCache();
      return;
    }
    this._disposeTextureCache();
    this._textures.dispose();
  }
  _disposeTextureCache() {
    for (let i = this._textureCache.length - 1; i >= 0; i--) {
      this._textureCache[i].texture.dispose();
    }
    this._textureCache.length = 0;
  }
  /**
   * Sets the required values to the prepass renderer.
   * @param prePassRenderer defines the prepass renderer to setup.
   * @returns true if the pre pass is needed.
   */
  setPrePassRenderer(prePassRenderer) {
    if (this._prePassEffectConfiguration) {
      this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);
      this._prePassEffectConfiguration.enabled = true;
      return true;
    }
    return false;
  }
  /**
   * Disposes the post process.
   * @param camera The camera to dispose the post process on.
   */
  dispose(camera) {
    camera = camera || this._camera;
    if (!this._useExistingThinPostProcess) {
      this._effectWrapper.dispose();
    }
    this._disposeTextures();
    let index;
    if (this._scene) {
      index = this._scene.removePostProcess(this);
    }
    if (this._parentContainer) {
      const index2 = this._parentContainer.postProcesses.indexOf(this);
      if (index2 > -1) {
        this._parentContainer.postProcesses.splice(index2, 1);
      }
      this._parentContainer = null;
    }
    index = this._engine.postProcesses.indexOf(this);
    if (index !== -1) {
      this._engine.postProcesses.splice(index, 1);
    }
    this.onDisposeObservable.notifyObservers();
    if (!camera) {
      return;
    }
    camera.detachPostProcess(this);
    index = camera._postProcesses.indexOf(this);
    if (index === 0 && camera._postProcesses.length > 0) {
      const firstPostProcess = this._camera._getFirstPostProcess();
      if (firstPostProcess) {
        firstPostProcess.markTextureDirty();
      }
    }
    this.onActivateObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onApplyObservable.clear();
    this.onBeforeRenderObservable.clear();
    this.onSizeChangedObservable.clear();
    this.onEffectCreatedObservable.clear();
  }
  /**
   * Serializes the post process to a JSON object
   * @returns the JSON object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    const camera = this.getCamera() || this._scene && this._scene.activeCamera;
    serializationObject.customType = "BABYLON." + this.getClassName();
    serializationObject.cameraId = camera ? camera.id : null;
    serializationObject.reusable = this._reusable;
    serializationObject.textureType = this._textureType;
    serializationObject.fragmentUrl = this._fragmentUrl;
    serializationObject.parameters = this._parameters;
    serializationObject.samplers = this._samplers;
    serializationObject.uniformBuffers = this._uniformBuffers;
    serializationObject.options = this._options;
    serializationObject.defines = this._postProcessDefines;
    serializationObject.textureFormat = this._textureFormat;
    serializationObject.vertexUrl = this._vertexUrl;
    serializationObject.indexParameters = this._indexParameters;
    return serializationObject;
  }
  /**
   * Clones this post process
   * @returns a new post process similar to this one
   */
  clone() {
    const serializationObject = this.serialize();
    serializationObject._engine = this._engine;
    serializationObject.cameraId = null;
    const result = _PostProcess.Parse(serializationObject, this._scene, "");
    if (!result) {
      return null;
    }
    result.onActivateObservable = this.onActivateObservable.clone();
    result.onSizeChangedObservable = this.onSizeChangedObservable.clone();
    result.onApplyObservable = this.onApplyObservable.clone();
    result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();
    result.onAfterRenderObservable = this.onAfterRenderObservable.clone();
    result._prePassEffectConfiguration = this._prePassEffectConfiguration;
    return result;
  }
  /**
   * Creates a material from parsed material data
   * @param parsedPostProcess defines parsed post process data
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures
   * @returns a new post process
   */
  static Parse(parsedPostProcess, scene, rootUrl) {
    const postProcessType = GetClass(parsedPostProcess.customType);
    if (!postProcessType || !postProcessType._Parse) {
      return null;
    }
    const camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;
    return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);
  }
  /**
   * @internal
   */
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new _PostProcess(parsedPostProcess.name, parsedPostProcess.fragmentUrl, parsedPostProcess.parameters, parsedPostProcess.samplers, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable, parsedPostProcess.defines, parsedPostProcess.textureType, parsedPostProcess.vertexUrl, parsedPostProcess.indexParameters, false, parsedPostProcess.textureFormat);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serialize()
], PostProcess.prototype, "uniqueId", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "name", null);
__decorate([
  serialize()
], PostProcess.prototype, "width", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "height", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "renderTargetSamplingMode", void 0);
__decorate([
  serializeAsColor4()
], PostProcess.prototype, "clearColor", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "autoClear", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "forceAutoClearInAlphaMode", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "alphaMode", null);
__decorate([
  serialize()
], PostProcess.prototype, "alphaConstants", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "enablePixelPerfectMode", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "forceFullscreenViewport", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "scaleMode", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "alwaysForcePOT", void 0);
__decorate([
  serialize("samples")
], PostProcess.prototype, "_samples", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "adaptScaleToCurrentViewport", void 0);
RegisterClass("BABYLON.PostProcess", PostProcess);

export {
  PostProcessManager,
  RenderingGroup,
  RenderingGroupInfo,
  RenderingManager,
  ObjectRenderer,
  RenderTargetTexture,
  PostProcess
};
//# sourceMappingURL=chunk-AIYZG4ER.js.map
