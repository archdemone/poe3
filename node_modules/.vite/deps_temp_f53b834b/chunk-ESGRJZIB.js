import {
  TimingTools
} from "./chunk-P7RYEPBM.js";

// node_modules/@babylonjs/core/Materials/drawWrapper.js
var DrawWrapper = class {
  /**
   * Retrieves the effect from a DrawWrapper or Effect instance.
   * @param effect The effect or DrawWrapper instance to retrieve the effect from.
   * @returns The effect associated with the given instance, or null if not found.
   */
  static GetEffect(effect) {
    return effect.getPipelineContext === void 0 ? effect.effect : effect;
  }
  /**
   * Creates a new DrawWrapper instance.
   * Note that drawContext is always created (but may end up being undefined if the engine doesn't need draw contexts), but materialContext is optional.
   * @param engine The engine to create the draw wrapper for.
   * @param createMaterialContext If true, creates a material context for this wrapper (default is true).
   */
  constructor(engine, createMaterialContext = true) {
    this._wasPreviouslyReady = false;
    this._forceRebindOnNextCall = true;
    this._wasPreviouslyUsingInstances = null;
    this.effect = null;
    this.defines = null;
    this.drawContext = engine.createDrawContext();
    if (createMaterialContext) {
      this.materialContext = engine.createMaterialContext();
    }
  }
  /**
   * Sets the effect and its associated defines for this wrapper.
   * @param effect The effect to associate with this wrapper.
   * @param defines The defines to associate with this wrapper.
   * @param resetContext If true, resets the draw context (default is true).
   */
  setEffect(effect, defines, resetContext = true) {
    var _a;
    this.effect = effect;
    if (defines !== void 0) {
      this.defines = defines;
    }
    if (resetContext) {
      (_a = this.drawContext) == null ? void 0 : _a.reset();
    }
  }
  /**
   * Disposes the effect wrapper and its resources
   * @param immediate if the effect should be disposed immediately or on the next frame.
   * If dispose() is not called during a scene or engine dispose, we want to delay the dispose of the underlying effect. Mostly to give a chance to user code to reuse the effect in some way.
   */
  dispose(immediate = false) {
    var _a;
    if (this.effect) {
      const effect = this.effect;
      if (immediate) {
        effect.dispose();
      } else {
        TimingTools.SetImmediate(() => {
          effect.getEngine().onEndFrameObservable.addOnce(() => {
            effect.dispose();
          });
        });
      }
      this.effect = null;
    }
    (_a = this.drawContext) == null ? void 0 : _a.dispose();
  }
};

export {
  DrawWrapper
};
//# sourceMappingURL=chunk-ESGRJZIB.js.map
