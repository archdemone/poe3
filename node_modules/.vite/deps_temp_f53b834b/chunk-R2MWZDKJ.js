import {
  CustomParticleEmitter
} from "./chunk-EGDANSF7.js";
import {
  ImageProcessingConfigurationDefines
} from "./chunk-OD54AC3V.js";
import {
  PrepareSamplersForImageProcessing,
  PrepareUniformsForImageProcessing
} from "./chunk-M4ZP5RIT.js";
import {
  AddClipPlaneUniforms,
  BindClipPlane,
  BindFogParameters,
  BindLogDepth,
  PrepareStringDefinesForClipPlanes
} from "./chunk-OBPOXDVH.js";
import {
  DrawWrapper
} from "./chunk-ESGRJZIB.js";
import {
  Buffer,
  VertexBuffer
} from "./chunk-2PJUNA7K.js";
import {
  DeepCopier
} from "./chunk-5BR36B43.js";
import {
  Texture
} from "./chunk-WGSHYOCR.js";
import {
  SerializationHelper
} from "./chunk-I7MCLN5K.js";
import {
  AbstractEngine
} from "./chunk-P7RYEPBM.js";
import {
  _WarnImport
} from "./chunk-OWCZTH5B.js";
import {
  Color3,
  Color4,
  TmpColors
} from "./chunk-TMMBUR4V.js";
import {
  Matrix,
  TmpVectors,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-XWK5Q5FM.js";
import {
  EngineStore
} from "./chunk-ZVW3KNNR.js";
import {
  Observable
} from "./chunk-2YUEJ7I2.js";
import {
  GetClass,
  RegisterClass
} from "./chunk-S7NDMBDF.js";
import {
  Clamp,
  Lerp,
  RandomRange
} from "./chunk-427EVWOG.js";

// node_modules/@babylonjs/core/Misc/gradients.js
var ColorGradient = class {
  /**
   * Creates a new color4 gradient
   * @param gradient gets or sets the gradient value (between 0 and 1)
   * @param color1 gets or sets first associated color
   * @param color2 gets or sets first second color
   */
  constructor(gradient, color1, color2) {
    this.gradient = gradient;
    this.color1 = color1;
    this.color2 = color2;
  }
  /**
   * Will get a color picked randomly between color1 and color2.
   * If color2 is undefined then color1 will be used
   * @param result defines the target Color4 to store the result in
   */
  getColorToRef(result) {
    if (!this.color2) {
      result.copyFrom(this.color1);
      return;
    }
    Color4.LerpToRef(this.color1, this.color2, Math.random(), result);
  }
};
var Color3Gradient = class {
  /**
   * Creates a new color3 gradient
   * @param gradient gets or sets the gradient value (between 0 and 1)
   * @param color gets or sets associated color
   */
  constructor(gradient, color) {
    this.gradient = gradient;
    this.color = color;
  }
};
var FactorGradient = class {
  /**
   * Creates a new factor gradient
   * @param gradient gets or sets the gradient value (between 0 and 1)
   * @param factor1 gets or sets first associated factor
   * @param factor2 gets or sets second associated factor
   */
  constructor(gradient, factor1, factor2) {
    this.gradient = gradient;
    this.factor1 = factor1;
    this.factor2 = factor2;
  }
  /**
   * Will get a number picked randomly between factor1 and factor2.
   * If factor2 is undefined then factor1 will be used
   * @returns the picked number
   */
  getFactor() {
    if (this.factor2 === void 0 || this.factor2 === this.factor1) {
      return this.factor1;
    }
    return this.factor1 + (this.factor2 - this.factor1) * Math.random();
  }
};
var GradientHelper = class {
  /**
   * Gets the current gradient from an array of IValueGradient
   * @param ratio defines the current ratio to get
   * @param gradients defines the array of IValueGradient
   * @param updateFunc defines the callback function used to get the final value from the selected gradients
   */
  static GetCurrentGradient(ratio, gradients, updateFunc) {
    if (gradients[0].gradient > ratio) {
      updateFunc(gradients[0], gradients[0], 1);
      return;
    }
    for (let gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {
      const currentGradient = gradients[gradientIndex];
      const nextGradient = gradients[gradientIndex + 1];
      if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {
        const scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);
        updateFunc(currentGradient, nextGradient, scale);
        return;
      }
    }
    const lastIndex = gradients.length - 1;
    updateFunc(gradients[lastIndex], gradients[lastIndex], 1);
  }
};

// node_modules/@babylonjs/core/Materials/Textures/rawTexture.js
var RawTexture = class _RawTexture extends Texture {
  /**
   * Instantiates a new RawTexture.
   * Raw texture can help creating a texture directly from an array of data.
   * This can be super useful if you either get the data from an uncompressed source or
   * if you wish to create your texture pixel by pixel.
   * @param data define the array of data to use to create the texture (null to create an empty texture)
   * @param width define the width of the texture
   * @param height define the height of the texture
   * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps define whether mip maps should be generated or not
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @param waitDataToBeReady If set to true Rawtexture will wait data to be set in order to be flaged as ready.
   */
  constructor(data, width, height, format, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags, useSRGBBuffer, waitDataToBeReady) {
    super(null, sceneOrEngine, !generateMipMaps, invertY, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, creationFlags);
    this.format = format;
    if (!this._engine) {
      return;
    }
    if (!this._engine._caps.textureFloatLinearFiltering && type === 1) {
      samplingMode = 1;
    }
    if (!this._engine._caps.textureHalfFloatLinearFiltering && type === 2) {
      samplingMode = 1;
    }
    this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false);
    this.wrapU = Texture.CLAMP_ADDRESSMODE;
    this.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._waitingForData = !!waitDataToBeReady && !data;
  }
  /**
   * Updates the texture underlying data.
   * @param data Define the new data of the texture
   */
  update(data) {
    this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer);
    this._waitingForData = false;
  }
  /**
   * Clones the texture.
   * @returns the cloned texture
   */
  clone() {
    if (!this._texture) {
      return super.clone();
    }
    const rawTexture = new _RawTexture(null, this.getSize().width, this.getSize().height, this.format, this.getScene(), this._texture.generateMipMaps, this._invertY, this.samplingMode, this._texture.type, this._texture._creationFlags, this._useSRGBBuffer);
    rawTexture._texture = this._texture;
    this._texture.incrementReferences();
    return rawTexture;
  }
  isReady() {
    return super.isReady() && !this._waitingForData;
  }
  /**
   * Creates a luminance texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @returns the luminance texture
   */
  static CreateLuminanceTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
    return new _RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  }
  /**
   * Creates a luminance alpha texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @returns the luminance alpha texture
   */
  static CreateLuminanceAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
    return new _RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  }
  /**
   * Creates an alpha texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @returns the alpha texture
   */
  static CreateAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
    return new _RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  }
  /**
   * Creates a RGB texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns the RGB alpha texture
   */
  static CreateRGBTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {
    return new _RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);
  }
  /**
   * Creates a RGBA texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @param waitDataToBeReady if set to true this will force texture to wait for data to be set before it is considered ready.
   * @returns the RGBA texture
   */
  static CreateRGBATexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false, waitDataToBeReady = false) {
    return new _RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer, waitDataToBeReady);
  }
  /**
   * Creates a RGBA storage texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns the RGBA texture
   */
  static CreateRGBAStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, useSRGBBuffer = false) {
    return new _RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1, useSRGBBuffer);
  }
  /**
   * Creates a R texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @returns the R texture
   */
  static CreateRTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {
    return new _RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
  }
  /**
   * Creates a R storage texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @returns the R texture
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static CreateRStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {
    return new _RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);
  }
};

// node_modules/@babylonjs/core/Particles/baseParticleSystem.js
var BaseParticleSystem = class _BaseParticleSystem {
  /**
   * The amount of time the particle system is running (depends of the overall update speed).
   */
  get targetStopDuration() {
    return this._targetStopDuration;
  }
  set targetStopDuration(value) {
    if (this._targetStopDuration === value) {
      return;
    }
    this._targetStopDuration = value;
  }
  /**
   * Returns true if the particle system was generated by a node particle system set
   */
  get isNodeGenerated() {
    return false;
  }
  /**
   * Gets or sets a texture used to add random noise to particle positions
   */
  get noiseTexture() {
    return this._noiseTexture;
  }
  set noiseTexture(value) {
    if (this._noiseTexture === value) {
      return;
    }
    this._noiseTexture = value;
    this._reset();
  }
  /** @internal */
  get _isAnimationSheetEnabled() {
    return this._animationSheetEnabled;
  }
  set _isAnimationSheetEnabled(value) {
    if (this._animationSheetEnabled === value) {
      return;
    }
    this._animationSheetEnabled = value;
  }
  /**
   * Gets or sets whether an animation sprite sheet is enabled or not on the particle system
   */
  get isAnimationSheetEnabled() {
    return this._isAnimationSheetEnabled;
  }
  set isAnimationSheetEnabled(value) {
    if (this._isAnimationSheetEnabled == value) {
      return;
    }
    this._isAnimationSheetEnabled = value;
    this._reset();
  }
  /**
   * Gets or sets a boolean enabling the use of logarithmic depth buffers, which is good for wide depth buffers.
   */
  get useLogarithmicDepth() {
    return this._useLogarithmicDepth;
  }
  set useLogarithmicDepth(value) {
    this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
  }
  /**
   * Get hosting scene
   * @returns the scene
   */
  getScene() {
    return this._scene;
  }
  _hasTargetStopDurationDependantGradient() {
    return this._startSizeGradients && this._startSizeGradients.length > 0 || this._emitRateGradients && this._emitRateGradients.length > 0 || this._lifeTimeGradients && this._lifeTimeGradients.length > 0;
  }
  _setEngineBasedOnBlendMode(blendMode) {
    switch (blendMode) {
      case _BaseParticleSystem.BLENDMODE_MULTIPLYADD:
        return;
      case _BaseParticleSystem.BLENDMODE_ADD:
        blendMode = 1;
        break;
      case _BaseParticleSystem.BLENDMODE_ONEONE:
        blendMode = 6;
        break;
      case _BaseParticleSystem.BLENDMODE_STANDARD:
        blendMode = 2;
        break;
      case _BaseParticleSystem.BLENDMODE_MULTIPLY:
        blendMode = 4;
        break;
      case _BaseParticleSystem.BLENDMODE_SUBTRACT:
        blendMode = 3;
        break;
      default:
        break;
    }
    this._engine.setAlphaMode(blendMode);
  }
  /**
   * Gets the current list of drag gradients.
   * You must use addDragGradient and removeDragGradient to update this list
   * @returns the list of drag gradients
   */
  getDragGradients() {
    return this._dragGradients;
  }
  /**
   * Gets the current list of limit velocity gradients.
   * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list
   * @returns the list of limit velocity gradients
   */
  getLimitVelocityGradients() {
    return this._limitVelocityGradients;
  }
  /**
   * Gets the current list of color gradients.
   * You must use addColorGradient and removeColorGradient to update this list
   * @returns the list of color gradients
   */
  getColorGradients() {
    return this._colorGradients;
  }
  /**
   * Gets the current list of size gradients.
   * You must use addSizeGradient and removeSizeGradient to update this list
   * @returns the list of size gradients
   */
  getSizeGradients() {
    return this._sizeGradients;
  }
  /**
   * Gets the current list of color remap gradients.
   * You must use addColorRemapGradient and removeColorRemapGradient to update this list
   * @returns the list of color remap gradients
   */
  getColorRemapGradients() {
    return this._colorRemapGradients;
  }
  /**
   * Gets the current list of alpha remap gradients.
   * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list
   * @returns the list of alpha remap gradients
   */
  getAlphaRemapGradients() {
    return this._alphaRemapGradients;
  }
  /**
   * Gets the current list of life time gradients.
   * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list
   * @returns the list of life time gradients
   */
  getLifeTimeGradients() {
    return this._lifeTimeGradients;
  }
  /**
   * Gets the current list of angular speed gradients.
   * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list
   * @returns the list of angular speed gradients
   */
  getAngularSpeedGradients() {
    return this._angularSpeedGradients;
  }
  /**
   * Gets the current list of velocity gradients.
   * You must use addVelocityGradient and removeVelocityGradient to update this list
   * @returns the list of velocity gradients
   */
  getVelocityGradients() {
    return this._velocityGradients;
  }
  /**
   * Gets the current list of start size gradients.
   * You must use addStartSizeGradient and removeStartSizeGradient to update this list
   * @returns the list of start size gradients
   */
  getStartSizeGradients() {
    return this._startSizeGradients;
  }
  /**
   * Gets the current list of emit rate gradients.
   * You must use addEmitRateGradient and removeEmitRateGradient to update this list
   * @returns the list of emit rate gradients
   */
  getEmitRateGradients() {
    return this._emitRateGradients;
  }
  /**
   * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get direction1() {
    if (this.particleEmitterType.direction1) {
      return this.particleEmitterType.direction1;
    }
    return Vector3.Zero();
  }
  set direction1(value) {
    if (this.particleEmitterType.direction1) {
      this.particleEmitterType.direction1 = value;
    }
  }
  /**
   * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get direction2() {
    if (this.particleEmitterType.direction2) {
      return this.particleEmitterType.direction2;
    }
    return Vector3.Zero();
  }
  set direction2(value) {
    if (this.particleEmitterType.direction2) {
      this.particleEmitterType.direction2 = value;
    }
  }
  /**
   * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get minEmitBox() {
    if (this.particleEmitterType.minEmitBox) {
      return this.particleEmitterType.minEmitBox;
    }
    return Vector3.Zero();
  }
  set minEmitBox(value) {
    if (this.particleEmitterType.minEmitBox) {
      this.particleEmitterType.minEmitBox = value;
    }
  }
  /**
   * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get maxEmitBox() {
    if (this.particleEmitterType.maxEmitBox) {
      return this.particleEmitterType.maxEmitBox;
    }
    return Vector3.Zero();
  }
  set maxEmitBox(value) {
    if (this.particleEmitterType.maxEmitBox) {
      this.particleEmitterType.maxEmitBox = value;
    }
  }
  /**
   * Gets or sets the billboard mode to use when isBillboardBased = true.
   * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED
   */
  get billboardMode() {
    return this._billboardMode;
  }
  set billboardMode(value) {
    if (this._billboardMode === value) {
      return;
    }
    this._billboardMode = value;
    this._reset();
  }
  /**
   * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
   */
  get isBillboardBased() {
    return this._isBillboardBased;
  }
  set isBillboardBased(value) {
    if (this._isBillboardBased === value) {
      return;
    }
    this._isBillboardBased = value;
    this._reset();
  }
  /**
   * Gets the image processing configuration used either in this material.
   */
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  /**
   * Sets the Default image processing configuration used either in the this material.
   *
   * If sets to null, the scene one is in use.
   */
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
  }
  /**
   * Attaches a new image processing configuration to the Standard Material.
   * @param configuration
   */
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (!configuration && this._scene) {
      this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
  }
  /** @internal */
  _reset() {
  }
  /**
   * @internal
   */
  _removeGradientAndTexture(gradient, gradients, texture) {
    if (!gradients) {
      return this;
    }
    let index = 0;
    for (const valueGradient of gradients) {
      if (valueGradient.gradient === gradient) {
        gradients.splice(index, 1);
        break;
      }
      index++;
    }
    if (texture) {
      texture.dispose();
    }
    return this;
  }
  /**
   * Instantiates a particle system.
   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
   * @param name The name of the particle system
   */
  constructor(name) {
    this.animations = [];
    this.renderingGroupId = 0;
    this.emitter = Vector3.Zero();
    this.emitRate = 10;
    this.manualEmitCount = -1;
    this.updateSpeed = 0.01;
    this._targetStopDuration = 0;
    this.disposeOnStop = false;
    this.minEmitPower = 1;
    this.maxEmitPower = 1;
    this.minLifeTime = 1;
    this.maxLifeTime = 1;
    this.minSize = 1;
    this.maxSize = 1;
    this.minScaleX = 1;
    this.maxScaleX = 1;
    this.minScaleY = 1;
    this.maxScaleY = 1;
    this.minInitialRotation = 0;
    this.maxInitialRotation = 0;
    this.minAngularSpeed = 0;
    this.maxAngularSpeed = 0;
    this.layerMask = 268435455;
    this.customShader = null;
    this.preventAutoStart = false;
    this.applyFog = false;
    this._wasDispatched = false;
    this._rootUrl = "";
    this.noiseStrength = new Vector3(10, 10, 10);
    this.onAnimationEnd = null;
    this.blendMode = _BaseParticleSystem.BLENDMODE_ONEONE;
    this.forceDepthWrite = false;
    this.preWarmCycles = 0;
    this.preWarmStepOffset = 1;
    this.spriteCellChangeSpeed = 1;
    this.startSpriteCellID = 0;
    this.endSpriteCellID = 0;
    this.spriteCellWidth = 0;
    this.spriteCellHeight = 0;
    this.spriteCellLoop = true;
    this.spriteRandomStartCell = false;
    this.translationPivot = new Vector2(0, 0);
    this._animationSheetEnabled = false;
    this.beginAnimationOnStart = false;
    this.beginAnimationFrom = 0;
    this.beginAnimationTo = 60;
    this.beginAnimationLoop = false;
    this.worldOffset = new Vector3(0, 0, 0);
    this._useLogarithmicDepth = false;
    this.gravity = Vector3.Zero();
    this._colorGradients = null;
    this._sizeGradients = null;
    this._lifeTimeGradients = null;
    this._angularSpeedGradients = null;
    this._velocityGradients = null;
    this._limitVelocityGradients = null;
    this._dragGradients = null;
    this._emitRateGradients = null;
    this._startSizeGradients = null;
    this._rampGradients = null;
    this._colorRemapGradients = null;
    this._alphaRemapGradients = null;
    this.startDelay = 0;
    this.limitVelocityDamping = 0.4;
    this.color1 = new Color4(1, 1, 1, 1);
    this.color2 = new Color4(1, 1, 1, 1);
    this.colorDead = new Color4(0, 0, 0, 1);
    this.textureMask = new Color4(1, 1, 1, 1);
    this._isSubEmitter = false;
    this._billboardMode = 7;
    this._isBillboardBased = true;
    this._imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();
    this.id = name;
    this.name = name;
  }
  /**
   * Creates a Point Emitter for the particle system (emits directly from the emitter position)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
   */
  createPointEmitter(direction1, direction2) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
   * @param radius The radius of the hemisphere to emit from
   * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
   */
  createHemisphericEmitter(radius = 1, radiusRange = 1) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Sphere Emitter for the particle system (emits along the sphere radius)
   * @param radius The radius of the sphere to emit from
   * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
   */
  createSphereEmitter(radius = 1, radiusRange = 1) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
   * @param radius The radius of the sphere to emit from
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
   */
  createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
   * @param radius The radius of the emission cylinder
   * @param height The height of the emission cylinder
   * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
   * @param directionRandomizer How much to randomize the particle direction [0-1]
   */
  createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
   * @param radius The radius of the cylinder to emit from
   * @param height The height of the emission cylinder
   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
   */
  createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
   * @param radius The radius of the cone to emit from
   * @param angle The base angle of the cone
   */
  createConeEmitter(radius = 1, angle = Math.PI / 4) {
    throw new Error("Method not implemented.");
  }
  createDirectedConeEmitter(radius = 1, angle = Math.PI / 4, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
   * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
   * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
   */
  createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {
    throw new Error("Method not implemented.");
  }
};
BaseParticleSystem.BLENDMODE_ONEONE = 0;
BaseParticleSystem.BLENDMODE_STANDARD = 1;
BaseParticleSystem.BLENDMODE_ADD = 2;
BaseParticleSystem.BLENDMODE_MULTIPLY = 3;
BaseParticleSystem.BLENDMODE_MULTIPLYADD = 4;
BaseParticleSystem.BLENDMODE_SUBTRACT = -1;
RegisterClass("BABYLON.BaseParticleSystem", BaseParticleSystem);

// node_modules/@babylonjs/core/Particles/particle.js
var Particle = class _Particle {
  /**
   * Creates a new instance Particle
   * @param particleSystem the particle system the particle belongs to
   */
  constructor(particleSystem) {
    this.particleSystem = particleSystem;
    this.position = Vector3.Zero();
    this.direction = Vector3.Zero();
    this.color = new Color4(0, 0, 0, 0);
    this.colorStep = new Color4(0, 0, 0, 0);
    this.initialColor = new Color4(0, 0, 0, 0);
    this.colorDead = new Color4(0, 0, 0, 0);
    this.lifeTime = 1;
    this.age = 0;
    this.size = 0;
    this.scale = new Vector2(1, 1);
    this.angle = 0;
    this.angularSpeed = 0;
    this.cellIndex = 0;
    this._attachedSubEmitters = null;
    this._currentColor1 = new Color4(0, 0, 0, 0);
    this._currentColor2 = new Color4(0, 0, 0, 0);
    this._currentSize1 = 0;
    this._currentSize2 = 0;
    this._currentAngularSpeed1 = 0;
    this._currentAngularSpeed2 = 0;
    this._currentVelocity1 = 0;
    this._currentVelocity2 = 0;
    this._currentLimitVelocity1 = 0;
    this._currentLimitVelocity2 = 0;
    this._currentDrag1 = 0;
    this._currentDrag2 = 0;
    this.id = _Particle._Count++;
    if (!this.particleSystem.isAnimationSheetEnabled) {
      return;
    }
    this._updateCellInfoFromSystem();
  }
  _updateCellInfoFromSystem() {
    this.cellIndex = this.particleSystem.startSpriteCellID;
  }
  /**
   * Defines how the sprite cell index is updated for the particle
   */
  updateCellIndex() {
    let offsetAge = this.age;
    let changeSpeed = this.particleSystem.spriteCellChangeSpeed;
    if (this.particleSystem.spriteRandomStartCell) {
      if (this._randomCellOffset === void 0) {
        this._randomCellOffset = Math.random() * this.lifeTime;
      }
      if (changeSpeed === 0) {
        changeSpeed = 1;
        offsetAge = this._randomCellOffset;
      } else {
        offsetAge += this._randomCellOffset;
      }
    }
    const dist = this._initialEndSpriteCellId - this._initialStartSpriteCellId + 1;
    let ratio;
    if (this._initialSpriteCellLoop) {
      ratio = Clamp(offsetAge * changeSpeed % this.lifeTime / this.lifeTime);
    } else {
      ratio = Clamp(offsetAge * changeSpeed / this.lifeTime);
    }
    this.cellIndex = this._initialStartSpriteCellId + ratio * dist | 0;
  }
  /**
   * @internal
   */
  _inheritParticleInfoToSubEmitter(subEmitter) {
    if (subEmitter.particleSystem.emitter.position) {
      const emitterMesh = subEmitter.particleSystem.emitter;
      emitterMesh.position.copyFrom(this.position);
      if (subEmitter.inheritDirection) {
        const temp = TmpVectors.Vector3[0];
        this.direction.normalizeToRef(temp);
        emitterMesh.setDirection(temp, 0, Math.PI / 2);
      }
    } else {
      const emitterPosition = subEmitter.particleSystem.emitter;
      emitterPosition.copyFrom(this.position);
    }
    this.direction.scaleToRef(subEmitter.inheritedVelocityAmount / 2, TmpVectors.Vector3[0]);
    subEmitter.particleSystem._inheritedVelocityOffset.copyFrom(TmpVectors.Vector3[0]);
  }
  /** @internal */
  _inheritParticleInfoToSubEmitters() {
    if (this._attachedSubEmitters && this._attachedSubEmitters.length > 0) {
      for (const subEmitter of this._attachedSubEmitters) {
        this._inheritParticleInfoToSubEmitter(subEmitter);
      }
    }
  }
  /** @internal */
  _reset() {
    this.age = 0;
    this.id = _Particle._Count++;
    this._currentColorGradient = null;
    this._currentSizeGradient = null;
    this._currentAngularSpeedGradient = null;
    this._currentVelocityGradient = null;
    this._currentLimitVelocityGradient = null;
    this._currentDragGradient = null;
    this.cellIndex = this.particleSystem.startSpriteCellID;
    this._randomCellOffset = void 0;
  }
  /**
   * Copy the properties of particle to another one.
   * @param other the particle to copy the information to.
   */
  copyTo(other) {
    other.position.copyFrom(this.position);
    if (this._initialDirection) {
      if (other._initialDirection) {
        other._initialDirection.copyFrom(this._initialDirection);
      } else {
        other._initialDirection = this._initialDirection.clone();
      }
    } else {
      other._initialDirection = null;
    }
    other.direction.copyFrom(this.direction);
    if (this._localPosition) {
      if (other._localPosition) {
        other._localPosition.copyFrom(this._localPosition);
      } else {
        other._localPosition = this._localPosition.clone();
      }
    }
    other.color.copyFrom(this.color);
    other.colorStep.copyFrom(this.colorStep);
    other.initialColor.copyFrom(this.initialColor);
    other.colorDead.copyFrom(this.colorDead);
    other.lifeTime = this.lifeTime;
    other.age = this.age;
    other._randomCellOffset = this._randomCellOffset;
    other.size = this.size;
    other.scale.copyFrom(this.scale);
    other.angle = this.angle;
    other.angularSpeed = this.angularSpeed;
    other.particleSystem = this.particleSystem;
    other.cellIndex = this.cellIndex;
    other.id = this.id;
    other._attachedSubEmitters = this._attachedSubEmitters;
    if (this._currentColorGradient) {
      other._currentColorGradient = this._currentColorGradient;
      other._currentColor1.copyFrom(this._currentColor1);
      other._currentColor2.copyFrom(this._currentColor2);
    }
    if (this._currentSizeGradient) {
      other._currentSizeGradient = this._currentSizeGradient;
      other._currentSize1 = this._currentSize1;
      other._currentSize2 = this._currentSize2;
    }
    if (this._currentAngularSpeedGradient) {
      other._currentAngularSpeedGradient = this._currentAngularSpeedGradient;
      other._currentAngularSpeed1 = this._currentAngularSpeed1;
      other._currentAngularSpeed2 = this._currentAngularSpeed2;
    }
    if (this._currentVelocityGradient) {
      other._currentVelocityGradient = this._currentVelocityGradient;
      other._currentVelocity1 = this._currentVelocity1;
      other._currentVelocity2 = this._currentVelocity2;
    }
    if (this._currentLimitVelocityGradient) {
      other._currentLimitVelocityGradient = this._currentLimitVelocityGradient;
      other._currentLimitVelocity1 = this._currentLimitVelocity1;
      other._currentLimitVelocity2 = this._currentLimitVelocity2;
    }
    if (this._currentDragGradient) {
      other._currentDragGradient = this._currentDragGradient;
      other._currentDrag1 = this._currentDrag1;
      other._currentDrag2 = this._currentDrag2;
    }
    if (this.particleSystem.isAnimationSheetEnabled) {
      other._initialStartSpriteCellId = this._initialStartSpriteCellId;
      other._initialEndSpriteCellId = this._initialEndSpriteCellId;
      other._initialSpriteCellLoop = this._initialSpriteCellLoop;
    }
    if (this.particleSystem.useRampGradients) {
      if (other.remapData && this.remapData) {
        other.remapData.copyFrom(this.remapData);
      } else {
        other.remapData = new Vector4(0, 0, 0, 0);
      }
    }
    if (this._randomNoiseCoordinates1) {
      if (other._randomNoiseCoordinates1) {
        other._randomNoiseCoordinates1.copyFrom(this._randomNoiseCoordinates1);
        other._randomNoiseCoordinates2.copyFrom(this._randomNoiseCoordinates2);
      } else {
        other._randomNoiseCoordinates1 = this._randomNoiseCoordinates1.clone();
        other._randomNoiseCoordinates2 = this._randomNoiseCoordinates2.clone();
      }
    }
  }
};
Particle._Count = 0;

// node_modules/@babylonjs/core/Particles/EmitterTypes/boxParticleEmitter.js
var BoxParticleEmitter = class _BoxParticleEmitter {
  /**
   * Creates a new instance BoxParticleEmitter
   */
  constructor() {
    this.direction1 = new Vector3(0, 1, 0);
    this.direction2 = new Vector3(0, 1, 0);
    this.minEmitBox = new Vector3(-0.5, -0.5, -0.5);
    this.maxEmitBox = new Vector3(0.5, 0.5, 0.5);
  }
  /**
   * Called by the particle System when the direction is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param directionToUpdate is the direction vector to update with the result
   * @param particle is the particle we are computed the direction for
   * @param isLocal defines if the direction should be set in local space
   */
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    const randX = RandomRange(this.direction1.x, this.direction2.x);
    const randY = RandomRange(this.direction1.y, this.direction2.y);
    const randZ = RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.x = randX;
      directionToUpdate.y = randY;
      directionToUpdate.z = randZ;
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  }
  /**
   * Called by the particle System when the position is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param positionToUpdate is the position vector to update with the result
   * @param particle is the particle we are computed the position for
   * @param isLocal defines if the position should be set in local space
   */
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    const randX = RandomRange(this.minEmitBox.x, this.maxEmitBox.x);
    const randY = RandomRange(this.minEmitBox.y, this.maxEmitBox.y);
    const randZ = RandomRange(this.minEmitBox.z, this.maxEmitBox.z);
    if (isLocal) {
      positionToUpdate.x = randX;
      positionToUpdate.y = randY;
      positionToUpdate.z = randZ;
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
  }
  /**
   * Clones the current emitter and returns a copy of it
   * @returns the new emitter
   */
  clone() {
    const newOne = new _BoxParticleEmitter();
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  /**
   * Called by the GPUParticleSystem to setup the update shader
   * @param uboOrEffect defines the update shader
   */
  applyToShader(uboOrEffect) {
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
    uboOrEffect.setVector3("minEmitBox", this.minEmitBox);
    uboOrEffect.setVector3("maxEmitBox", this.maxEmitBox);
  }
  /**
   * Creates the structure of the ubo for this particle emitter
   * @param ubo ubo to create the structure for
   */
  buildUniformLayout(ubo) {
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
    ubo.addUniform("minEmitBox", 3);
    ubo.addUniform("maxEmitBox", 3);
  }
  /**
   * Returns a string to use to update the GPU particles update shader
   * @returns a string containing the defines string
   */
  getEffectDefines() {
    return "#define BOXEMITTER";
  }
  /**
   * Returns the string "BoxParticleEmitter"
   * @returns a string containing the class name
   */
  getClassName() {
    return "BoxParticleEmitter";
  }
  /**
   * Serializes the particle system to a JSON object.
   * @returns the JSON object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    serializationObject.minEmitBox = this.minEmitBox.asArray();
    serializationObject.maxEmitBox = this.maxEmitBox.asArray();
    return serializationObject;
  }
  /**
   * Parse properties from a JSON object
   * @param serializationObject defines the JSON object
   */
  parse(serializationObject) {
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
    Vector3.FromArrayToRef(serializationObject.minEmitBox, 0, this.minEmitBox);
    Vector3.FromArrayToRef(serializationObject.maxEmitBox, 0, this.maxEmitBox);
  }
};

// node_modules/@babylonjs/core/Particles/thinParticleSystem.function.js
function _CreateColorData(particle, system) {
  const step = RandomRange(0, 1);
  Color4.LerpToRef(system.color1, system.color2, step, particle.color);
}
function _CreateColorDeadData(particle, system) {
  system.colorDead.subtractToRef(particle.color, system._colorDiff);
  system._colorDiff.scaleToRef(1 / particle.lifeTime, particle.colorStep);
}
function _CreateColorGradientsData(particle, system) {
  particle._currentColorGradient = system._colorGradients[0];
  particle._currentColorGradient.getColorToRef(particle.color);
  particle._currentColor1.copyFrom(particle.color);
  if (system._colorGradients.length > 1) {
    system._colorGradients[1].getColorToRef(particle._currentColor2);
  } else {
    particle._currentColor2.copyFrom(particle.color);
  }
}
function _ProcessColorGradients(particle, system) {
  const colorGradients = system._colorGradients;
  GradientHelper.GetCurrentGradient(system._ratio, colorGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== particle._currentColorGradient) {
      particle._currentColor1.copyFrom(particle._currentColor2);
      nextGradient.getColorToRef(particle._currentColor2);
      particle._currentColorGradient = currentGradient;
    }
    Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);
  });
}
function _ProcessColor(particle, system) {
  particle.colorStep.scaleToRef(system._scaledUpdateSpeed, system._scaledColorStep);
  particle.color.addInPlace(system._scaledColorStep);
  if (particle.color.a < 0) {
    particle.color.a = 0;
  }
}
function _ProcessAngularSpeedGradients(particle, system) {
  GradientHelper.GetCurrentGradient(system._ratio, system._angularSpeedGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== particle._currentAngularSpeedGradient) {
      particle._currentAngularSpeed1 = particle._currentAngularSpeed2;
      particle._currentAngularSpeed2 = nextGradient.getFactor();
      particle._currentAngularSpeedGradient = currentGradient;
    }
    particle.angularSpeed = Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);
  });
}
function _ProcessAngularSpeed(particle, system) {
  particle.angle += particle.angularSpeed * system._scaledUpdateSpeed;
}
function _CreateDirectionData(particle, system) {
  system.particleEmitterType.startDirectionFunction(system._emitterWorldMatrix, particle.direction, particle, system.isLocal, system._emitterInverseWorldMatrix);
}
function _CreateCustomDirectionData(particle, system) {
  system.startDirectionFunction(system._emitterWorldMatrix, particle.direction, particle, system.isLocal);
}
function _CreateVelocityGradients(particle, system) {
  particle._currentVelocityGradient = system._velocityGradients[0];
  particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();
  if (system._velocityGradients.length > 1) {
    particle._currentVelocity2 = system._velocityGradients[1].getFactor();
  } else {
    particle._currentVelocity2 = particle._currentVelocity1;
  }
}
function _CreateLimitVelocityGradients(particle, system) {
  particle._currentLimitVelocityGradient = system._limitVelocityGradients[0];
  particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();
  if (system._limitVelocityGradients.length > 1) {
    particle._currentLimitVelocity2 = system._limitVelocityGradients[1].getFactor();
  } else {
    particle._currentLimitVelocity2 = particle._currentLimitVelocity1;
  }
}
function _ProcessVelocityGradients(particle, system) {
  GradientHelper.GetCurrentGradient(system._ratio, system._velocityGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== particle._currentVelocityGradient) {
      particle._currentVelocity1 = particle._currentVelocity2;
      particle._currentVelocity2 = nextGradient.getFactor();
      particle._currentVelocityGradient = currentGradient;
    }
    system._directionScale *= Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);
  });
}
function _ProcessLimitVelocityGradients(particle, system) {
  GradientHelper.GetCurrentGradient(system._ratio, system._limitVelocityGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== particle._currentLimitVelocityGradient) {
      particle._currentLimitVelocity1 = particle._currentLimitVelocity2;
      particle._currentLimitVelocity2 = nextGradient.getFactor();
      particle._currentLimitVelocityGradient = currentGradient;
    }
    const limitVelocity = Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);
    const currentVelocity = particle.direction.length();
    if (currentVelocity > limitVelocity) {
      particle.direction.scaleInPlace(system.limitVelocityDamping);
    }
  });
}
function _ProcessDirection(particle, system) {
  particle.direction.scaleToRef(system._directionScale, system._scaledDirection);
}
function _CreatePositionData(particle, system) {
  system.particleEmitterType.startPositionFunction(system._emitterWorldMatrix, particle.position, particle, system.isLocal);
}
function _CreateCustomPositionData(particle, system) {
  system.startPositionFunction(system._emitterWorldMatrix, particle.position, particle, system.isLocal);
}
function _CreateIsLocalData(particle, system) {
  if (!particle._localPosition) {
    particle._localPosition = particle.position.clone();
  } else {
    particle._localPosition.copyFrom(particle.position);
  }
  Vector3.TransformCoordinatesToRef(particle._localPosition, system._emitterWorldMatrix, particle.position);
}
function _ProcessPosition(particle, system) {
  if (system.isLocal && particle._localPosition) {
    particle._localPosition.addInPlace(system._scaledDirection);
    Vector3.TransformCoordinatesToRef(particle._localPosition, system._emitterWorldMatrix, particle.position);
  } else {
    particle.position.addInPlace(system._scaledDirection);
  }
}
function _CreateDragData(particle, system) {
  particle._currentDragGradient = system._dragGradients[0];
  particle._currentDrag1 = particle._currentDragGradient.getFactor();
  if (system._dragGradients.length > 1) {
    particle._currentDrag2 = system._dragGradients[1].getFactor();
  } else {
    particle._currentDrag2 = particle._currentDrag1;
  }
}
function _ProcessDragGradients(particle, system) {
  GradientHelper.GetCurrentGradient(system._ratio, system._dragGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== particle._currentDragGradient) {
      particle._currentDrag1 = particle._currentDrag2;
      particle._currentDrag2 = nextGradient.getFactor();
      particle._currentDragGradient = currentGradient;
    }
    const drag = Lerp(particle._currentDrag1, particle._currentDrag2, scale);
    system._scaledDirection.scaleInPlace(1 - drag);
  });
}
function _CreateNoiseData(particle, system) {
  if (particle._randomNoiseCoordinates1) {
    particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());
    particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());
  } else {
    particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());
    particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());
  }
}
function _ProcessNoise(particle, system) {
  const noiseTextureData = system._noiseTextureData;
  const noiseTextureSize = system._noiseTextureSize;
  if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {
    const fetchedColorR = system._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
    const fetchedColorG = system._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
    const fetchedColorB = system._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
    const force = TmpVectors.Vector3[0];
    const scaledForce = TmpVectors.Vector3[1];
    force.copyFromFloats((2 * fetchedColorR - 1) * system.noiseStrength.x, (2 * fetchedColorG - 1) * system.noiseStrength.y, (2 * fetchedColorB - 1) * system.noiseStrength.z);
    force.scaleToRef(system._tempScaledUpdateSpeed, scaledForce);
    particle.direction.addInPlace(scaledForce);
  }
}
function _ProcessGravity(particle, system) {
  system.gravity.scaleToRef(system._tempScaledUpdateSpeed, system._scaledGravity);
  particle.direction.addInPlace(system._scaledGravity);
}
function _CreateSizeData(particle, system) {
  particle.size = RandomRange(system.minSize, system.maxSize);
  particle.scale.copyFromFloats(RandomRange(system.minScaleX, system.maxScaleX), RandomRange(system.minScaleY, system.maxScaleY));
}
function _CreateSizeGradientsData(particle, system) {
  particle._currentSizeGradient = system._sizeGradients[0];
  particle._currentSize1 = particle._currentSizeGradient.getFactor();
  particle.size = particle._currentSize1;
  if (system._sizeGradients.length > 1) {
    particle._currentSize2 = system._sizeGradients[1].getFactor();
  } else {
    particle._currentSize2 = particle._currentSize1;
  }
  particle.scale.copyFromFloats(RandomRange(system.minScaleX, system.maxScaleX), RandomRange(system.minScaleY, system.maxScaleY));
}
function _CreateStartSizeGradientsData(particle, system) {
  const ratio = system._actualFrame / system.targetStopDuration;
  GradientHelper.GetCurrentGradient(ratio, system._startSizeGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== system._currentStartSizeGradient) {
      system._currentStartSize1 = system._currentStartSize2;
      system._currentStartSize2 = nextGradient.getFactor();
      system._currentStartSizeGradient = currentGradient;
    }
    const value = Lerp(system._currentStartSize1, system._currentStartSize2, scale);
    particle.scale.scaleInPlace(value);
  });
}
function _ProcessSizeGradients(particle, system) {
  GradientHelper.GetCurrentGradient(system._ratio, system._sizeGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== particle._currentSizeGradient) {
      particle._currentSize1 = particle._currentSize2;
      particle._currentSize2 = nextGradient.getFactor();
      particle._currentSizeGradient = currentGradient;
    }
    particle.size = Lerp(particle._currentSize1, particle._currentSize2, scale);
  });
}
function _CreateRampData(particle, system) {
  particle.remapData = new Vector4(0, 1, 0, 1);
}
function _ProcessRemapGradients(particle, system) {
  if (system._colorRemapGradients && system._colorRemapGradients.length > 0) {
    GradientHelper.GetCurrentGradient(system._ratio, system._colorRemapGradients, (currentGradient, nextGradient, scale) => {
      const min = Lerp(currentGradient.factor1, nextGradient.factor1, scale);
      const max = Lerp(currentGradient.factor2, nextGradient.factor2, scale);
      particle.remapData.x = min;
      particle.remapData.y = max - min;
    });
  }
  if (system._alphaRemapGradients && system._alphaRemapGradients.length > 0) {
    GradientHelper.GetCurrentGradient(system._ratio, system._alphaRemapGradients, (currentGradient, nextGradient, scale) => {
      const min = Lerp(currentGradient.factor1, nextGradient.factor1, scale);
      const max = Lerp(currentGradient.factor2, nextGradient.factor2, scale);
      particle.remapData.z = min;
      particle.remapData.w = max - min;
    });
  }
}
function _CreateLifeGradientsData(particle, system) {
  const ratio = Clamp(system._actualFrame / system.targetStopDuration);
  GradientHelper.GetCurrentGradient(ratio, system._lifeTimeGradients, (currentGradient, nextGradient) => {
    const factorGradient1 = currentGradient;
    const factorGradient2 = nextGradient;
    const lifeTime1 = factorGradient1.getFactor();
    const lifeTime2 = factorGradient2.getFactor();
    const gradient = (ratio - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);
    particle.lifeTime = Lerp(lifeTime1, lifeTime2, gradient);
  });
  system._emitPower = RandomRange(system.minEmitPower, system.maxEmitPower);
}
function _CreateLifetimeData(particle, system) {
  particle.lifeTime = RandomRange(system.minLifeTime, system.maxLifeTime);
  system._emitPower = RandomRange(system.minEmitPower, system.maxEmitPower);
}
function _CreateEmitPowerData(particle, system) {
  if (system._emitPower === 0) {
    if (!particle._initialDirection) {
      particle._initialDirection = particle.direction.clone();
    } else {
      particle._initialDirection.copyFrom(particle.direction);
    }
    particle.direction.set(0, 0, 0);
  } else {
    particle._initialDirection = null;
    particle.direction.scaleInPlace(system._emitPower);
  }
  particle.direction.addInPlace(system._inheritedVelocityOffset);
}
function _CreateAngleData(particle, system) {
  particle.angularSpeed = RandomRange(system.minAngularSpeed, system.maxAngularSpeed);
  particle.angle = RandomRange(system.minInitialRotation, system.maxInitialRotation);
}
function _CreateAngleGradientsData(particle, system) {
  particle._currentAngularSpeedGradient = system._angularSpeedGradients[0];
  particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();
  particle._currentAngularSpeed1 = particle.angularSpeed;
  if (system._angularSpeedGradients.length > 1) {
    particle._currentAngularSpeed2 = system._angularSpeedGradients[1].getFactor();
  } else {
    particle._currentAngularSpeed2 = particle._currentAngularSpeed1;
  }
  particle.angle = RandomRange(system.minInitialRotation, system.maxInitialRotation);
}
function _CreateSheetData(particle, system) {
  particle._initialStartSpriteCellId = system.startSpriteCellID;
  particle._initialEndSpriteCellId = system.endSpriteCellID;
  particle._initialSpriteCellLoop = system.spriteCellLoop;
}

// node_modules/@babylonjs/core/Particles/Queue/executionQueue.js
function _ConnectBefore(newOne, activeOne) {
  newOne.previousItem = activeOne.previousItem;
  newOne.nextItem = activeOne;
  if (activeOne.previousItem) {
    activeOne.previousItem.nextItem = newOne;
  }
  activeOne.previousItem = newOne;
}
function _ConnectAfter(newOne, activeOne) {
  newOne.previousItem = activeOne;
  newOne.nextItem = activeOne.nextItem;
  if (activeOne.nextItem) {
    activeOne.nextItem.previousItem = newOne;
  }
  activeOne.nextItem = newOne;
}
function _ConnectAtTheEnd(newOne, root) {
  let activeOne = root;
  while (activeOne.nextItem) {
    activeOne = activeOne.nextItem;
  }
  newOne.previousItem = activeOne;
  newOne.nextItem = activeOne.nextItem;
  activeOne.nextItem = newOne;
}
function _RemoveFromQueue(item) {
  if (item.previousItem) {
    item.previousItem.nextItem = item.nextItem;
  }
  if (item.nextItem) {
    item.nextItem.previousItem = item.previousItem;
  }
}

// node_modules/@babylonjs/core/Particles/thinParticleSystem.js
var ThinParticleSystem = class _ThinParticleSystem extends BaseParticleSystem {
  /**
   * This function can be defined to specify initial direction for every new particle.
   * It by default use the emitterType defined function
   */
  get startDirectionFunction() {
    return this._startDirectionFunction;
  }
  set startDirectionFunction(value) {
    if (this._startDirectionFunction === value) {
      return;
    }
    this._startDirectionFunction = value;
    if (value) {
      this._directionProcessing.process = _CreateCustomDirectionData;
    } else {
      this._directionProcessing.process = _CreateDirectionData;
    }
  }
  /**
   * This function can be defined to specify initial position for every new particle.
   * It by default use the emitterType defined function
   */
  get startPositionFunction() {
    return this._startPositionFunction;
  }
  set startPositionFunction(value) {
    if (this._startPositionFunction === value) {
      return;
    }
    this._startPositionFunction = value;
    if (value) {
      this._positionCreation.process = _CreateCustomPositionData;
    } else {
      this._positionCreation.process = _CreatePositionData;
    }
  }
  /**
   * Sets a callback that will be triggered when the system is disposed
   */
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  /**
   * Gets a boolean indicating that the particle system was disposed
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /** Gets or sets a boolean indicating that ramp gradients must be used
   * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients
   */
  get useRampGradients() {
    return this._useRampGradients;
  }
  set useRampGradients(value) {
    if (this._useRampGradients === value) {
      return;
    }
    this._useRampGradients = value;
    this._resetEffect();
    if (value) {
      this._rampCreation = {
        process: _CreateRampData,
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._rampCreation, this._colorDeadCreation);
      this._remapGradientProcessing = {
        process: _ProcessRemapGradients,
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._remapGradientProcessing, this._gravityProcessing);
    } else {
      _RemoveFromQueue(this._rampCreation);
      _RemoveFromQueue(this._remapGradientProcessing);
    }
  }
  /**
   * Specifies if the particles are updated in emitter local space or world space
   */
  get isLocal() {
    return this._isLocal;
  }
  set isLocal(value) {
    if (this._isLocal === value) {
      return;
    }
    this._isLocal = value;
    if (value) {
      this._isLocalCreation = {
        process: _CreateIsLocalData,
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._isLocalCreation, this._positionCreation);
    } else {
      _RemoveFromQueue(this._isLocalCreation);
    }
  }
  /**
   * Gets the current list of active particles
   */
  get particles() {
    return this._particles;
  }
  /**
   * Gets the shader language used in this material.
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  /** @internal */
  get _isAnimationSheetEnabled() {
    return this._animationSheetEnabled;
  }
  set _isAnimationSheetEnabled(value) {
    if (this._animationSheetEnabled === value) {
      return;
    }
    this._animationSheetEnabled = value;
    if (value) {
      this._sheetCreation = {
        process: _CreateSheetData,
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._sheetCreation, this._colorDeadCreation);
    } else {
      _RemoveFromQueue(this._sheetCreation);
    }
    this._reset();
  }
  /**
   * Gets the number of particles active at the same time.
   * @returns The number of active particles.
   */
  getActiveCount() {
    return this._particles.length;
  }
  /**
   * Returns the string "ParticleSystem"
   * @returns a string containing the class name
   */
  getClassName() {
    return "ParticleSystem";
  }
  /**
   * Gets a boolean indicating that the system is stopping
   * @returns true if the system is currently stopping
   */
  isStopping() {
    return this._stopped && this.isAlive();
  }
  /**
   * Gets the custom effect used to render the particles
   * @param blendMode Blend mode for which the effect should be retrieved
   * @returns The effect
   */
  getCustomEffect(blendMode = 0) {
    var _a;
    return ((_a = this._customWrappers[blendMode]) == null ? void 0 : _a.effect) ?? this._customWrappers[0].effect;
  }
  _getCustomDrawWrapper(blendMode = 0) {
    return this._customWrappers[blendMode] ?? this._customWrappers[0];
  }
  /**
   * Sets the custom effect used to render the particles
   * @param effect The effect to set
   * @param blendMode Blend mode for which the effect should be set
   */
  setCustomEffect(effect, blendMode = 0) {
    this._customWrappers[blendMode] = new DrawWrapper(this._engine);
    this._customWrappers[blendMode].effect = effect;
    if (this._customWrappers[blendMode].drawContext) {
      this._customWrappers[blendMode].drawContext.useInstancing = this._useInstancing;
    }
  }
  /**
   * Observable that will be called just before the particles are drawn
   */
  get onBeforeDrawParticlesObservable() {
    if (!this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable = new Observable();
    }
    return this._onBeforeDrawParticlesObservable;
  }
  /**
   * Gets the name of the particle vertex shader
   */
  get vertexShaderName() {
    return "particles";
  }
  /**
   * Gets the vertex buffers used by the particle system
   */
  get vertexBuffers() {
    return this._vertexBuffers;
  }
  /**
   * Gets the index buffer used by the particle system (or null if no index buffer is used (if _useInstancing=true))
   */
  get indexBuffer() {
    return this._indexBuffer;
  }
  get noiseTexture() {
    return this._noiseTexture;
  }
  set noiseTexture(value) {
    if (this.noiseTexture === value) {
      return;
    }
    this._noiseTexture = value;
    if (!value) {
      _RemoveFromQueue(this._noiseCreation);
      _RemoveFromQueue(this._noiseProcessing);
      return;
    }
    this._noiseCreation = {
      process: _CreateNoiseData,
      previousItem: null,
      nextItem: null
    };
    _ConnectAfter(this._noiseCreation, this._colorDeadCreation);
    this._noiseProcessing = {
      process: _ProcessNoise,
      previousItem: null,
      nextItem: null
    };
    _ConnectAfter(this._noiseProcessing, this._positionProcessing);
  }
  /**
   * Instantiates a particle system.
   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
   * @param name The name of the particle system
   * @param capacity The max number of particles alive at the same time
   * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene
   * @param customEffect a custom effect used to change the way particles are rendered by default
   * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture
   * @param epsilon Offset used to render the particles
   * @param noUpdateQueue If true, the particle system will start with an empty update queue
   */
  constructor(name, capacity, sceneOrEngine, customEffect = null, isAnimationSheetEnabled = false, epsilon = 0.01, noUpdateQueue = false) {
    super(name);
    this._emitterInverseWorldMatrix = Matrix.Identity();
    this._startDirectionFunction = null;
    this._startPositionFunction = null;
    this._inheritedVelocityOffset = new Vector3();
    this.onDisposeObservable = new Observable();
    this.onStoppedObservable = new Observable();
    this.onStartedObservable = new Observable();
    this._noiseTextureSize = null;
    this._noiseTextureData = null;
    this._particles = new Array();
    this._stockParticles = new Array();
    this._newPartsExcess = 0;
    this._vertexBuffers = {};
    this._scaledColorStep = new Color4(0, 0, 0, 0);
    this._colorDiff = new Color4(0, 0, 0, 0);
    this._scaledDirection = Vector3.Zero();
    this._scaledGravity = Vector3.Zero();
    this._currentRenderId = -1;
    this._useInstancing = false;
    this._isDisposed = false;
    this._started = false;
    this._stopped = false;
    this._actualFrame = 0;
    this._currentEmitRate1 = 0;
    this._currentEmitRate2 = 0;
    this._currentStartSize1 = 0;
    this._currentStartSize2 = 0;
    this.updateInAnimate = true;
    this._rawTextureWidth = 256;
    this._useRampGradients = false;
    this._updateQueueStart = null;
    this._startSizeCreation = null;
    this._createQueueStart = null;
    this._isLocal = false;
    this.isGPU = false;
    this._shaderLanguage = 0;
    this._onBeforeDrawParticlesObservable = null;
    this._emitFromParticle = (particle) => {
    };
    this.recycleParticle = (particle) => {
      const lastParticle = this._particles.pop();
      if (lastParticle !== particle) {
        lastParticle.copyTo(particle);
      }
      this._stockParticles.push(lastParticle);
    };
    this._createParticle = () => {
      let particle;
      if (this._stockParticles.length !== 0) {
        particle = this._stockParticles.pop();
        particle._reset();
      } else {
        particle = new Particle(this);
      }
      this._prepareParticle(particle);
      return particle;
    };
    this.paused = false;
    this._shadersLoaded = false;
    this._capacity = capacity;
    this._epsilon = epsilon;
    if (!sceneOrEngine || sceneOrEngine.getClassName() === "Scene") {
      this._scene = sceneOrEngine || EngineStore.LastCreatedScene;
      this._engine = this._scene.getEngine();
      this.uniqueId = this._scene.getUniqueId();
      this._scene.particleSystems.push(this);
    } else {
      this._engine = sceneOrEngine;
      this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);
    }
    if (this._engine.getCaps().vertexArrayObject) {
      this._vertexArrayObject = null;
    }
    this._initShaderSourceAsync();
    this._lifeTimeCreation = {
      process: _CreateLifetimeData,
      previousItem: null,
      nextItem: null
    };
    this._positionCreation = {
      process: _CreatePositionData,
      previousItem: null,
      nextItem: null
    };
    _ConnectAfter(this._positionCreation, this._lifeTimeCreation);
    this._directionCreation = {
      process: _CreateDirectionData,
      previousItem: null,
      nextItem: null
    };
    _ConnectAfter(this._directionCreation, this._positionCreation);
    this._emitPowerCreation = {
      process: _CreateEmitPowerData,
      previousItem: null,
      nextItem: null
    };
    _ConnectAfter(this._emitPowerCreation, this._directionCreation);
    this._sizeCreation = {
      process: _CreateSizeData,
      previousItem: null,
      nextItem: null
    };
    _ConnectAfter(this._sizeCreation, this._emitPowerCreation);
    this._angleCreation = {
      process: _CreateAngleData,
      previousItem: null,
      nextItem: null
    };
    _ConnectAfter(this._angleCreation, this._sizeCreation);
    this._colorCreation = {
      process: _CreateColorData,
      previousItem: null,
      nextItem: null
    };
    _ConnectAfter(this._colorCreation, this._angleCreation);
    this._colorDeadCreation = {
      process: _CreateColorDeadData,
      previousItem: null,
      nextItem: null
    };
    _ConnectAfter(this._colorDeadCreation, this._colorCreation);
    this._createQueueStart = this._lifeTimeCreation;
    if (!noUpdateQueue) {
      this._colorProcessing = {
        process: _ProcessColor,
        previousItem: null,
        nextItem: null
      };
      this._angularSpeedProcessing = {
        process: _ProcessAngularSpeed,
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._angularSpeedProcessing, this._colorProcessing);
      this._directionProcessing = {
        process: _ProcessDirection,
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._directionProcessing, this._angularSpeedProcessing);
      this._positionProcessing = {
        process: _ProcessPosition,
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._positionProcessing, this._directionProcessing);
      this._gravityProcessing = {
        process: _ProcessGravity,
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._gravityProcessing, this._positionProcessing);
      this._updateQueueStart = this._colorProcessing;
    }
    this._isAnimationSheetEnabled = isAnimationSheetEnabled;
    this._attachImageProcessingConfiguration(null);
    this._customWrappers = { 0: new DrawWrapper(this._engine) };
    this._customWrappers[0].effect = customEffect;
    this._drawWrappers = [];
    this._useInstancing = this._engine.getCaps().instancedArrays;
    this._createIndexBuffer();
    this._createVertexBuffers();
    this.particleEmitterType = new BoxParticleEmitter();
    this.updateFunction = (particles) => {
      var _a;
      if (this.noiseTexture) {
        this._noiseTextureSize = this.noiseTexture.getSize();
        (_a = this.noiseTexture.getContent()) == null ? void 0 : _a.then((data) => {
          this._noiseTextureData = data;
        });
      }
      const sameParticleArray = particles === this._particles;
      for (let index = 0; index < particles.length; index++) {
        const particle = particles[index];
        this._tempScaledUpdateSpeed = this._scaledUpdateSpeed;
        const previousAge = particle.age;
        particle.age += this._tempScaledUpdateSpeed;
        if (particle.age > particle.lifeTime) {
          const diff = particle.age - previousAge;
          const oldDiff = particle.lifeTime - previousAge;
          this._tempScaledUpdateSpeed = oldDiff * this._tempScaledUpdateSpeed / diff;
          particle.age = particle.lifeTime;
        }
        this._ratio = particle.age / particle.lifeTime;
        this._directionScale = this._tempScaledUpdateSpeed;
        let currentQueueItem = this._updateQueueStart;
        while (currentQueueItem) {
          currentQueueItem.process(particle, this);
          currentQueueItem = currentQueueItem.nextItem;
        }
        if (this._isAnimationSheetEnabled && !noUpdateQueue) {
          particle.updateCellIndex();
        }
        particle._inheritParticleInfoToSubEmitters();
        if (particle.age >= particle.lifeTime) {
          this._emitFromParticle(particle);
          if (particle._attachedSubEmitters) {
            for (const subEmitter of particle._attachedSubEmitters) {
              subEmitter.particleSystem.disposeOnStop = true;
              subEmitter.particleSystem.stop();
            }
            particle._attachedSubEmitters = null;
          }
          this.recycleParticle(particle);
          if (sameParticleArray) {
            index--;
          }
          continue;
        }
      }
    };
  }
  serialize(serializeTexture) {
    throw new Error("Method not implemented.");
  }
  /**
   * Clones the particle system.
   * @param name The name of the cloned object
   * @param newEmitter The new emitter to use
   * @param cloneTexture Also clone the textures if true
   */
  clone(name, newEmitter, cloneTexture = false) {
    throw new Error("Method not implemented.");
  }
  _addFactorGradient(factorGradients, gradient, factor, factor2) {
    const newGradient = new FactorGradient(gradient, factor, factor2);
    factorGradients.push(newGradient);
    factorGradients.sort((a, b) => {
      if (a.gradient < b.gradient) {
        return -1;
      } else if (a.gradient > b.gradient) {
        return 1;
      }
      return 0;
    });
  }
  _removeFactorGradient(factorGradients, gradient) {
    if (!factorGradients) {
      return;
    }
    let index = 0;
    for (const factorGradient of factorGradients) {
      if (factorGradient.gradient === gradient) {
        factorGradients.splice(index, 1);
        break;
      }
      index++;
    }
  }
  _syncLifeTimeCreation() {
    if (this.targetStopDuration && this._lifeTimeGradients && this._lifeTimeGradients.length > 0) {
      this._lifeTimeCreation.process = _CreateLifeGradientsData;
      return;
    }
    this._lifeTimeCreation.process = _CreateLifetimeData;
  }
  _syncStartSizeCreation() {
    if (this._startSizeGradients && this._startSizeGradients[0] && this.targetStopDuration) {
      if (!this._startSizeCreation) {
        this._startSizeCreation = {
          process: _CreateStartSizeGradientsData,
          previousItem: null,
          nextItem: null
        };
        _ConnectAfter(this._startSizeCreation, this._sizeCreation);
      }
      return;
    }
    if (this._startSizeCreation) {
      _RemoveFromQueue(this._startSizeCreation);
      this._startSizeCreation = null;
    }
  }
  get targetStopDuration() {
    return this._targetStopDuration;
  }
  set targetStopDuration(value) {
    if (this.targetStopDuration === value) {
      return;
    }
    this._targetStopDuration = value;
    this._syncLifeTimeCreation();
    this._syncStartSizeCreation();
  }
  /**
   * Adds a new life time gradient
   * @param gradient defines the gradient to use (between 0 and 1)
   * @param factor defines the life time factor to affect to the specified gradient
   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
   * @returns the current particle system
   */
  addLifeTimeGradient(gradient, factor, factor2) {
    if (!this._lifeTimeGradients) {
      this._lifeTimeGradients = [];
    }
    this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);
    this._syncLifeTimeCreation();
    return this;
  }
  /**
   * Remove a specific life time gradient
   * @param gradient defines the gradient to remove
   * @returns the current particle system
   */
  removeLifeTimeGradient(gradient) {
    this._removeFactorGradient(this._lifeTimeGradients, gradient);
    this._syncLifeTimeCreation();
    return this;
  }
  /**
   * Adds a new size gradient
   * @param gradient defines the gradient to use (between 0 and 1)
   * @param factor defines the size factor to affect to the specified gradient
   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
   * @returns the current particle system
   */
  addSizeGradient(gradient, factor, factor2) {
    if (!this._sizeGradients) {
      this._sizeGradients = [];
    }
    if (this._sizeGradients.length === 0) {
      this._sizeCreation.process = _CreateSizeGradientsData;
      this._sizeGradientProcessing = {
        process: _ProcessSizeGradients,
        previousItem: null,
        nextItem: null
      };
      _ConnectBefore(this._sizeGradientProcessing, this._gravityProcessing);
    }
    this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);
    return this;
  }
  /**
   * Remove a specific size gradient
   * @param gradient defines the gradient to remove
   * @returns the current particle system
   */
  removeSizeGradient(gradient) {
    var _a;
    this._removeFactorGradient(this._sizeGradients, gradient);
    if (((_a = this._sizeGradients) == null ? void 0 : _a.length) === 0) {
      _RemoveFromQueue(this._sizeGradientProcessing);
      this._sizeCreation.process = _CreateSizeData;
    }
    return this;
  }
  /**
   * Adds a new color remap gradient
   * @param gradient defines the gradient to use (between 0 and 1)
   * @param min defines the color remap minimal range
   * @param max defines the color remap maximal range
   * @returns the current particle system
   */
  addColorRemapGradient(gradient, min, max) {
    if (!this._colorRemapGradients) {
      this._colorRemapGradients = [];
    }
    this._addFactorGradient(this._colorRemapGradients, gradient, min, max);
    return this;
  }
  /**
   * Remove a specific color remap gradient
   * @param gradient defines the gradient to remove
   * @returns the current particle system
   */
  removeColorRemapGradient(gradient) {
    this._removeFactorGradient(this._colorRemapGradients, gradient);
    return this;
  }
  /**
   * Adds a new alpha remap gradient
   * @param gradient defines the gradient to use (between 0 and 1)
   * @param min defines the alpha remap minimal range
   * @param max defines the alpha remap maximal range
   * @returns the current particle system
   */
  addAlphaRemapGradient(gradient, min, max) {
    if (!this._alphaRemapGradients) {
      this._alphaRemapGradients = [];
    }
    this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);
    return this;
  }
  /**
   * Remove a specific alpha remap gradient
   * @param gradient defines the gradient to remove
   * @returns the current particle system
   */
  removeAlphaRemapGradient(gradient) {
    this._removeFactorGradient(this._alphaRemapGradients, gradient);
    return this;
  }
  /**
   * Adds a new angular speed gradient
   * @param gradient defines the gradient to use (between 0 and 1)
   * @param factor defines the angular speed  to affect to the specified gradient
   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
   * @returns the current particle system
   */
  addAngularSpeedGradient(gradient, factor, factor2) {
    if (!this._angularSpeedGradients) {
      this._angularSpeedGradients = [];
    }
    if (this._angularSpeedGradients.length === 0) {
      this._angleCreation.process = _CreateAngleGradientsData;
      this._angularSpeedGradientProcessing = {
        process: _ProcessAngularSpeedGradients,
        previousItem: null,
        nextItem: null
      };
      _ConnectBefore(this._angularSpeedGradientProcessing, this._angularSpeedProcessing);
    }
    this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);
    return this;
  }
  /**
   * Remove a specific angular speed gradient
   * @param gradient defines the gradient to remove
   * @returns the current particle system
   */
  removeAngularSpeedGradient(gradient) {
    var _a;
    this._removeFactorGradient(this._angularSpeedGradients, gradient);
    if (((_a = this._angularSpeedGradients) == null ? void 0 : _a.length) === 0) {
      this._angleCreation.process = _CreateAngleData;
      _RemoveFromQueue(this._angularSpeedGradientProcessing);
    }
    return this;
  }
  /**
   * Adds a new velocity gradient
   * @param gradient defines the gradient to use (between 0 and 1)
   * @param factor defines the velocity to affect to the specified gradient
   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
   * @returns the current particle system
   */
  addVelocityGradient(gradient, factor, factor2) {
    if (!this._velocityGradients) {
      this._velocityGradients = [];
    }
    if (this._velocityGradients.length === 0) {
      this._velocityCreation = {
        process: _CreateVelocityGradients,
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._velocityCreation, this._angleCreation);
      this._velocityGradientProcessing = {
        process: _ProcessVelocityGradients,
        previousItem: null,
        nextItem: null
      };
      _ConnectBefore(this._velocityGradientProcessing, this._directionProcessing);
    }
    this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);
    return this;
  }
  /**
   * Remove a specific velocity gradient
   * @param gradient defines the gradient to remove
   * @returns the current particle system
   */
  removeVelocityGradient(gradient) {
    var _a;
    this._removeFactorGradient(this._velocityGradients, gradient);
    if (((_a = this._velocityGradients) == null ? void 0 : _a.length) === 0) {
      _RemoveFromQueue(this._velocityCreation);
      _RemoveFromQueue(this._velocityGradientProcessing);
    }
    return this;
  }
  /**
   * Adds a new limit velocity gradient
   * @param gradient defines the gradient to use (between 0 and 1)
   * @param factor defines the limit velocity value to affect to the specified gradient
   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
   * @returns the current particle system
   */
  addLimitVelocityGradient(gradient, factor, factor2) {
    if (!this._limitVelocityGradients) {
      this._limitVelocityGradients = [];
    }
    if (this._limitVelocityGradients.length === 0) {
      this._limitVelocityCreation = {
        process: _CreateLimitVelocityGradients,
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._limitVelocityCreation, this._angleCreation);
      this._limitVelocityGradientProcessing = {
        process: _ProcessLimitVelocityGradients,
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._limitVelocityGradientProcessing, this._directionProcessing);
    }
    this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);
    return this;
  }
  /**
   * Remove a specific limit velocity gradient
   * @param gradient defines the gradient to remove
   * @returns the current particle system
   */
  removeLimitVelocityGradient(gradient) {
    var _a;
    this._removeFactorGradient(this._limitVelocityGradients, gradient);
    if (((_a = this._limitVelocityGradients) == null ? void 0 : _a.length) === 0) {
      _RemoveFromQueue(this._limitVelocityCreation);
      _RemoveFromQueue(this._limitVelocityGradientProcessing);
    }
    return this;
  }
  /**
   * Adds a new drag gradient
   * @param gradient defines the gradient to use (between 0 and 1)
   * @param factor defines the drag value to affect to the specified gradient
   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
   * @returns the current particle system
   */
  addDragGradient(gradient, factor, factor2) {
    if (!this._dragGradients) {
      this._dragGradients = [];
    }
    if (this._dragGradients.length === 0) {
      this._dragCreation = {
        process: _CreateDragData,
        previousItem: null,
        nextItem: null
      };
      _ConnectBefore(this._dragCreation, this._colorDeadCreation);
      this._dragGradientProcessing = {
        process: _ProcessDragGradients,
        previousItem: null,
        nextItem: null
      };
      _ConnectBefore(this._dragGradientProcessing, this._positionProcessing);
    }
    this._addFactorGradient(this._dragGradients, gradient, factor, factor2);
    return this;
  }
  /**
   * Remove a specific drag gradient
   * @param gradient defines the gradient to remove
   * @returns the current particle system
   */
  removeDragGradient(gradient) {
    var _a;
    this._removeFactorGradient(this._dragGradients, gradient);
    if (((_a = this._dragGradients) == null ? void 0 : _a.length) === 0) {
      _RemoveFromQueue(this._dragCreation);
      _RemoveFromQueue(this._dragGradientProcessing);
    }
    return this;
  }
  /**
   * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)
   * @param gradient defines the gradient to use (between 0 and 1)
   * @param factor defines the emit rate value to affect to the specified gradient
   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
   * @returns the current particle system
   */
  addEmitRateGradient(gradient, factor, factor2) {
    if (!this._emitRateGradients) {
      this._emitRateGradients = [];
    }
    this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);
    return this;
  }
  /**
   * Remove a specific emit rate gradient
   * @param gradient defines the gradient to remove
   * @returns the current particle system
   */
  removeEmitRateGradient(gradient) {
    this._removeFactorGradient(this._emitRateGradients, gradient);
    return this;
  }
  /**
   * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)
   * @param gradient defines the gradient to use (between 0 and 1)
   * @param factor defines the start size value to affect to the specified gradient
   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
   * @returns the current particle system
   */
  addStartSizeGradient(gradient, factor, factor2) {
    if (!this._startSizeGradients) {
      this._startSizeGradients = [];
    }
    this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);
    this._syncStartSizeCreation();
    return this;
  }
  /**
   * Remove a specific start size gradient
   * @param gradient defines the gradient to remove
   * @returns the current particle system
   */
  removeStartSizeGradient(gradient) {
    this._removeFactorGradient(this._startSizeGradients, gradient);
    this._syncStartSizeCreation();
    return this;
  }
  _createRampGradientTexture() {
    if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {
      return;
    }
    const data = new Uint8Array(this._rawTextureWidth * 4);
    const tmpColor = TmpColors.Color3[0];
    for (let x = 0; x < this._rawTextureWidth; x++) {
      const ratio = x / this._rawTextureWidth;
      GradientHelper.GetCurrentGradient(ratio, this._rampGradients, (currentGradient, nextGradient, scale) => {
        Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);
        data[x * 4] = tmpColor.r * 255;
        data[x * 4 + 1] = tmpColor.g * 255;
        data[x * 4 + 2] = tmpColor.b * 255;
        data[x * 4 + 3] = 255;
      });
    }
    this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);
  }
  /**
   * Gets the current list of ramp gradients.
   * You must use addRampGradient and removeRampGradient to update this list
   * @returns the list of ramp gradients
   */
  getRampGradients() {
    return this._rampGradients;
  }
  /** Force the system to rebuild all gradients that need to be resync */
  forceRefreshGradients() {
    this._syncRampGradientTexture();
  }
  _syncRampGradientTexture() {
    if (!this._rampGradients) {
      return;
    }
    this._rampGradients.sort((a, b) => {
      if (a.gradient < b.gradient) {
        return -1;
      } else if (a.gradient > b.gradient) {
        return 1;
      }
      return 0;
    });
    if (this._rampGradientsTexture) {
      this._rampGradientsTexture.dispose();
      this._rampGradientsTexture = null;
    }
    this._createRampGradientTexture();
  }
  /**
   * Adds a new ramp gradient used to remap particle colors
   * @param gradient defines the gradient to use (between 0 and 1)
   * @param color defines the color to affect to the specified gradient
   * @returns the current particle system
   */
  addRampGradient(gradient, color) {
    if (!this._rampGradients) {
      this._rampGradients = [];
    }
    const rampGradient = new Color3Gradient(gradient, color);
    this._rampGradients.push(rampGradient);
    this._syncRampGradientTexture();
    return this;
  }
  /**
   * Remove a specific ramp gradient
   * @param gradient defines the gradient to remove
   * @returns the current particle system
   */
  removeRampGradient(gradient) {
    this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);
    this._rampGradientsTexture = null;
    if (this._rampGradients && this._rampGradients.length > 0) {
      this._createRampGradientTexture();
    }
    return this;
  }
  /**
   * Adds a new color gradient
   * @param gradient defines the gradient to use (between 0 and 1)
   * @param color1 defines the color to affect to the specified gradient
   * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from
   * @returns this particle system
   */
  addColorGradient(gradient, color1, color2) {
    if (!this._colorGradients) {
      this._colorGradients = [];
    }
    if (this._colorGradients.length === 0) {
      this._colorCreation.process = _CreateColorGradientsData;
      this._colorProcessing.process = _ProcessColorGradients;
    }
    const colorGradient = new ColorGradient(gradient, color1, color2);
    this._colorGradients.push(colorGradient);
    this._colorGradients.sort((a, b) => {
      if (a.gradient < b.gradient) {
        return -1;
      } else if (a.gradient > b.gradient) {
        return 1;
      }
      return 0;
    });
    return this;
  }
  /**
   * Remove a specific color gradient
   * @param gradient defines the gradient to remove
   * @returns this particle system
   */
  removeColorGradient(gradient) {
    if (!this._colorGradients) {
      return this;
    }
    let index = 0;
    for (const colorGradient of this._colorGradients) {
      if (colorGradient.gradient === gradient) {
        this._colorGradients.splice(index, 1);
        break;
      }
      index++;
    }
    if (this._colorGradients.length === 0) {
      this._colorCreation.process = _CreateColorData;
      this._colorProcessing.process = _ProcessColor;
    }
    return this;
  }
  /**
   * Resets the draw wrappers cache
   */
  resetDrawCache() {
    if (!this._drawWrappers) {
      return;
    }
    for (const drawWrappers of this._drawWrappers) {
      if (drawWrappers) {
        for (const drawWrapper of drawWrappers) {
          drawWrapper == null ? void 0 : drawWrapper.dispose();
        }
      }
    }
    this._drawWrappers = [];
  }
  /** @internal */
  _fetchR(u, v, width, height, pixels) {
    u = Math.abs(u) * 0.5 + 0.5;
    v = Math.abs(v) * 0.5 + 0.5;
    const wrappedU = u * width % width | 0;
    const wrappedV = v * height % height | 0;
    const position = (wrappedU + wrappedV * width) * 4;
    return pixels[position] / 255;
  }
  _reset() {
    this._resetEffect();
  }
  _resetEffect() {
    if (this._vertexBuffer) {
      this._vertexBuffer.dispose();
      this._vertexBuffer = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
    if (this._vertexArrayObject) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObject);
      this._vertexArrayObject = null;
    }
    this._createVertexBuffers();
  }
  _createVertexBuffers() {
    this._vertexBufferSize = this._useInstancing ? 10 : 12;
    if (this._isAnimationSheetEnabled) {
      this._vertexBufferSize += 1;
    }
    if (!this._isBillboardBased || this.billboardMode === 8 || this.billboardMode === 9) {
      this._vertexBufferSize += 3;
    }
    if (this._useRampGradients) {
      this._vertexBufferSize += 4;
    }
    const engine = this._engine;
    const vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);
    this._vertexData = new Float32Array(this._capacity * vertexSize);
    this._vertexBuffer = new Buffer(engine, this._vertexData, true, vertexSize);
    let dataOffset = 0;
    const positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers[VertexBuffer.PositionKind] = positions;
    dataOffset += 3;
    const colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers[VertexBuffer.ColorKind] = colors;
    dataOffset += 4;
    const options = this._vertexBuffer.createVertexBuffer("angle", dataOffset, 1, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers["angle"] = options;
    dataOffset += 1;
    const size = this._vertexBuffer.createVertexBuffer("size", dataOffset, 2, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers["size"] = size;
    dataOffset += 2;
    if (this._isAnimationSheetEnabled) {
      const cellIndexBuffer = this._vertexBuffer.createVertexBuffer("cellIndex", dataOffset, 1, this._vertexBufferSize, this._useInstancing);
      this._vertexBuffers["cellIndex"] = cellIndexBuffer;
      dataOffset += 1;
    }
    if (!this._isBillboardBased || this.billboardMode === 8 || this.billboardMode === 9) {
      const directionBuffer = this._vertexBuffer.createVertexBuffer("direction", dataOffset, 3, this._vertexBufferSize, this._useInstancing);
      this._vertexBuffers["direction"] = directionBuffer;
      dataOffset += 3;
    }
    if (this._useRampGradients) {
      const rampDataBuffer = this._vertexBuffer.createVertexBuffer("remapData", dataOffset, 4, this._vertexBufferSize, this._useInstancing);
      this._vertexBuffers["remapData"] = rampDataBuffer;
      dataOffset += 4;
    }
    let offsets;
    if (this._useInstancing) {
      const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);
      offsets = this._spriteBuffer.createVertexBuffer("offset", 0, 2);
    } else {
      offsets = this._vertexBuffer.createVertexBuffer("offset", dataOffset, 2, this._vertexBufferSize, this._useInstancing);
      dataOffset += 2;
    }
    this._vertexBuffers["offset"] = offsets;
    this.resetDrawCache();
  }
  _createIndexBuffer() {
    if (this._useInstancing) {
      this._linesIndexBufferUseInstancing = this._engine.createIndexBuffer(new Uint32Array([0, 1, 1, 3, 3, 2, 2, 0, 0, 3]));
      return;
    }
    const indices = [];
    const indicesWireframe = [];
    let index = 0;
    for (let count = 0; count < this._capacity; count++) {
      indices.push(index);
      indices.push(index + 1);
      indices.push(index + 2);
      indices.push(index);
      indices.push(index + 2);
      indices.push(index + 3);
      indicesWireframe.push(index, index + 1, index + 1, index + 2, index + 2, index + 3, index + 3, index, index, index + 3);
      index += 4;
    }
    this._indexBuffer = this._engine.createIndexBuffer(indices);
    this._linesIndexBuffer = this._engine.createIndexBuffer(indicesWireframe);
  }
  /**
   * Gets the maximum number of particles active at the same time.
   * @returns The max number of active particles.
   */
  getCapacity() {
    return this._capacity;
  }
  /**
   * Gets whether there are still active particles in the system.
   * @returns True if it is alive, otherwise false.
   */
  isAlive() {
    return this._alive;
  }
  /**
   * Gets if the system has been started. (Note: this will still be true after stop is called)
   * @returns True if it has been started, otherwise false.
   */
  isStarted() {
    return this._started;
  }
  /** @internal */
  _preStart() {
  }
  /**
   * Starts the particle system and begins to emit
   * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)
   */
  start(delay = this.startDelay) {
    var _a;
    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {
      throw "Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";
    }
    if (delay) {
      setTimeout(() => {
        this.start(0);
      }, delay);
      return;
    }
    this._started = true;
    this._stopped = false;
    this._actualFrame = 0;
    this._preStart();
    if (this._emitRateGradients) {
      if (this._emitRateGradients.length > 0) {
        this._currentEmitRateGradient = this._emitRateGradients[0];
        this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();
        this._currentEmitRate2 = this._currentEmitRate1;
      }
      if (this._emitRateGradients.length > 1) {
        this._currentEmitRate2 = this._emitRateGradients[1].getFactor();
      }
    }
    if (this._startSizeGradients) {
      if (this._startSizeGradients.length > 0) {
        this._currentStartSizeGradient = this._startSizeGradients[0];
        this._currentStartSize1 = this._currentStartSizeGradient.getFactor();
        this._currentStartSize2 = this._currentStartSize1;
      }
      if (this._startSizeGradients.length > 1) {
        this._currentStartSize2 = this._startSizeGradients[1].getFactor();
      }
    }
    if (this.preWarmCycles) {
      if (((_a = this.emitter) == null ? void 0 : _a.getClassName().indexOf("Mesh")) !== -1) {
        this.emitter.computeWorldMatrix(true);
      }
      const noiseTextureAsProcedural = this.noiseTexture;
      if (noiseTextureAsProcedural && noiseTextureAsProcedural.onGeneratedObservable) {
        noiseTextureAsProcedural.onGeneratedObservable.addOnce(() => {
          setTimeout(() => {
            for (let index = 0; index < this.preWarmCycles; index++) {
              this.animate(true);
              noiseTextureAsProcedural.render();
            }
          });
        });
      } else {
        for (let index = 0; index < this.preWarmCycles; index++) {
          this.animate(true);
        }
      }
    }
    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {
      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);
    }
    this.onStartedObservable.notifyObservers(this);
  }
  /**
   * Stops the particle system.
   * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. The default value is true.
   */
  stop(stopSubEmitters = true) {
    if (this._stopped) {
      return;
    }
    this.onStoppedObservable.notifyObservers(this);
    this._stopped = true;
    this._postStop(stopSubEmitters);
  }
  /** @internal */
  _postStop(_stopSubEmitters) {
  }
  // Animation sheet
  /**
   * Remove all active particles
   */
  reset() {
    this._stockParticles.length = 0;
    this._particles.length = 0;
  }
  /**
   * @internal (for internal use only)
   */
  _appendParticleVertex(index, particle, offsetX, offsetY) {
    var _a;
    let offset = index * this._vertexBufferSize;
    const floatingOriginOffset = TmpVectors.Vector3[0].copyFrom(((_a = this._scene) == null ? void 0 : _a.floatingOriginOffset) || Vector3.ZeroReadOnly);
    this._vertexData[offset++] = particle.position.x + this.worldOffset.x - floatingOriginOffset.x;
    this._vertexData[offset++] = particle.position.y + this.worldOffset.y - floatingOriginOffset.y;
    this._vertexData[offset++] = particle.position.z + this.worldOffset.z - floatingOriginOffset.z;
    this._vertexData[offset++] = particle.color.r;
    this._vertexData[offset++] = particle.color.g;
    this._vertexData[offset++] = particle.color.b;
    this._vertexData[offset++] = particle.color.a;
    this._vertexData[offset++] = particle.angle;
    this._vertexData[offset++] = particle.scale.x * particle.size;
    this._vertexData[offset++] = particle.scale.y * particle.size;
    if (this._isAnimationSheetEnabled) {
      this._vertexData[offset++] = particle.cellIndex;
    }
    if (!this._isBillboardBased) {
      if (particle._initialDirection) {
        let initialDirection = particle._initialDirection;
        if (this.isLocal) {
          Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);
          initialDirection = TmpVectors.Vector3[0];
        }
        if (initialDirection.x === 0 && initialDirection.z === 0) {
          initialDirection.x = 1e-3;
        }
        this._vertexData[offset++] = initialDirection.x;
        this._vertexData[offset++] = initialDirection.y;
        this._vertexData[offset++] = initialDirection.z;
      } else {
        let direction = particle.direction;
        if (this.isLocal) {
          Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);
          direction = TmpVectors.Vector3[0];
        }
        if (direction.x === 0 && direction.z === 0) {
          direction.x = 1e-3;
        }
        this._vertexData[offset++] = direction.x;
        this._vertexData[offset++] = direction.y;
        this._vertexData[offset++] = direction.z;
      }
    } else if (this.billboardMode === 8 || this.billboardMode === 9) {
      this._vertexData[offset++] = particle.direction.x;
      this._vertexData[offset++] = particle.direction.y;
      this._vertexData[offset++] = particle.direction.z;
    }
    if (this._useRampGradients && particle.remapData) {
      this._vertexData[offset++] = particle.remapData.x;
      this._vertexData[offset++] = particle.remapData.y;
      this._vertexData[offset++] = particle.remapData.z;
      this._vertexData[offset++] = particle.remapData.w;
    }
    if (!this._useInstancing) {
      if (this._isAnimationSheetEnabled) {
        if (offsetX === 0) {
          offsetX = this._epsilon;
        } else if (offsetX === 1) {
          offsetX = 1 - this._epsilon;
        }
        if (offsetY === 0) {
          offsetY = this._epsilon;
        } else if (offsetY === 1) {
          offsetY = 1 - this._epsilon;
        }
      }
      this._vertexData[offset++] = offsetX;
      this._vertexData[offset++] = offsetY;
    }
  }
  /** @internal */
  _prepareParticle(_particle) {
  }
  _createNewOnes(newParticles) {
    let particle;
    for (let index = 0; index < newParticles; index++) {
      if (this._particles.length === this._capacity) {
        break;
      }
      particle = this._createParticle();
      this._particles.push(particle);
      let currentQueueItem = this._createQueueStart;
      while (currentQueueItem) {
        currentQueueItem.process(particle, this);
        currentQueueItem = currentQueueItem.nextItem;
      }
      particle._inheritParticleInfoToSubEmitters();
    }
  }
  _update(newParticles) {
    this._alive = this._particles.length > 0;
    if (this.emitter.position) {
      const emitterMesh = this.emitter;
      this._emitterWorldMatrix = emitterMesh.getWorldMatrix();
    } else {
      const emitterPosition = this.emitter;
      this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);
    }
    this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);
    this.updateFunction(this._particles);
    this._createNewOnes(newParticles);
  }
  /**
   * @internal
   */
  static _GetAttributeNamesOrOptions(isAnimationSheetEnabled = false, isBillboardBased = false, useRampGradients = false) {
    const attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, "angle", "offset", "size"];
    if (isAnimationSheetEnabled) {
      attributeNamesOrOptions.push("cellIndex");
    }
    if (!isBillboardBased) {
      attributeNamesOrOptions.push("direction");
    }
    if (useRampGradients) {
      attributeNamesOrOptions.push("remapData");
    }
    return attributeNamesOrOptions;
  }
  /**
   * @internal
   */
  static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false, applyFog = false) {
    const effectCreationOption = ["invView", "view", "projection", "textureMask", "translationPivot", "eyePosition"];
    AddClipPlaneUniforms(effectCreationOption);
    if (isAnimationSheetEnabled) {
      effectCreationOption.push("particlesInfos");
    }
    if (useLogarithmicDepth) {
      effectCreationOption.push("logarithmicDepthConstant");
    }
    if (applyFog) {
      effectCreationOption.push("vFogInfos");
      effectCreationOption.push("vFogColor");
    }
    return effectCreationOption;
  }
  /**
   * Fill the defines array according to the current settings of the particle system
   * @param defines Array to be updated
   * @param blendMode blend mode to take into account when updating the array
   * @param fillImageProcessing fills the image processing defines
   */
  fillDefines(defines, blendMode, fillImageProcessing = true) {
    if (this._scene) {
      PrepareStringDefinesForClipPlanes(this, this._scene, defines);
      if (this.applyFog && this._scene.fogEnabled && this._scene.fogMode !== 0) {
        defines.push("#define FOG");
      }
    }
    if (this._isAnimationSheetEnabled) {
      defines.push("#define ANIMATESHEET");
    }
    if (this.useLogarithmicDepth) {
      defines.push("#define LOGARITHMICDEPTH");
    }
    if (blendMode === BaseParticleSystem.BLENDMODE_MULTIPLY) {
      defines.push("#define BLENDMULTIPLYMODE");
    }
    if (this._useRampGradients) {
      defines.push("#define RAMPGRADIENT");
    }
    if (this._isBillboardBased) {
      defines.push("#define BILLBOARD");
      switch (this.billboardMode) {
        case 2:
          defines.push("#define BILLBOARDY");
          break;
        case 8:
        case 9:
          defines.push("#define BILLBOARDSTRETCHED");
          if (this.billboardMode === 9) {
            defines.push("#define BILLBOARDSTRETCHED_LOCAL");
          }
          break;
        case 7:
          defines.push("#define BILLBOARDMODE_ALL");
          break;
        default:
          break;
      }
    }
    if (fillImageProcessing && this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);
      defines.push(this._imageProcessingConfigurationDefines.toString());
    }
  }
  /**
   * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system
   * @param uniforms Uniforms array to fill
   * @param attributes Attributes array to fill
   * @param samplers Samplers array to fill
   */
  fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers) {
    attributes.push(..._ThinParticleSystem._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== 8 && this.billboardMode !== 9, this._useRampGradients));
    uniforms.push(..._ThinParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth, this.applyFog));
    samplers.push("diffuseSampler", "rampSampler");
    if (this._imageProcessingConfiguration) {
      PrepareUniformsForImageProcessing(uniforms, this._imageProcessingConfigurationDefines);
      PrepareSamplersForImageProcessing(samplers, this._imageProcessingConfigurationDefines);
    }
  }
  /**
   * @internal
   */
  _getWrapper(blendMode) {
    const customWrapper = this._getCustomDrawWrapper(blendMode);
    if (customWrapper == null ? void 0 : customWrapper.effect) {
      return customWrapper;
    }
    const defines = [];
    this.fillDefines(defines, blendMode);
    const currentRenderPassId = this._engine._features.supportRenderPasses ? this._engine.currentRenderPassId : 0;
    let drawWrappers = this._drawWrappers[currentRenderPassId];
    if (!drawWrappers) {
      drawWrappers = this._drawWrappers[currentRenderPassId] = [];
    }
    let drawWrapper = drawWrappers[blendMode];
    if (!drawWrapper) {
      drawWrapper = new DrawWrapper(this._engine);
      if (drawWrapper.drawContext) {
        drawWrapper.drawContext.useInstancing = this._useInstancing;
      }
      drawWrappers[blendMode] = drawWrapper;
    }
    const join = defines.join("\n");
    if (drawWrapper.defines !== join) {
      const attributesNamesOrOptions = [];
      const effectCreationOption = [];
      const samplers = [];
      this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);
      drawWrapper.setEffect(this._engine.createEffect("particles", attributesNamesOrOptions, effectCreationOption, samplers, join, void 0, void 0, void 0, void 0, this._shaderLanguage), join);
    }
    return drawWrapper;
  }
  /**
   * Animates the particle system for the current frame by emitting new particles and or animating the living ones.
   * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)
   */
  animate(preWarmOnly = false) {
    var _a;
    if (!this._started || this.paused) {
      return;
    }
    if (!preWarmOnly && this._scene) {
      if (!this.isReady()) {
        return;
      }
      if (this._currentRenderId === this._scene.getFrameId()) {
        return;
      }
      this._currentRenderId = this._scene.getFrameId();
    }
    this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : ((_a = this._scene) == null ? void 0 : _a.getAnimationRatio()) || 1);
    let newParticles;
    if (this.manualEmitCount > -1) {
      newParticles = this.manualEmitCount;
      this._newPartsExcess = 0;
      this.manualEmitCount = 0;
    } else {
      let rate = this.emitRate;
      if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {
        const ratio = this._actualFrame / this.targetStopDuration;
        GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, (currentGradient, nextGradient, scale) => {
          if (currentGradient !== this._currentEmitRateGradient) {
            this._currentEmitRate1 = this._currentEmitRate2;
            this._currentEmitRate2 = nextGradient.getFactor();
            this._currentEmitRateGradient = currentGradient;
          }
          rate = Lerp(this._currentEmitRate1, this._currentEmitRate2, scale);
        });
      }
      newParticles = rate * this._scaledUpdateSpeed >> 0;
      this._newPartsExcess += rate * this._scaledUpdateSpeed - newParticles;
    }
    if (this._newPartsExcess > 1) {
      newParticles += this._newPartsExcess >> 0;
      this._newPartsExcess -= this._newPartsExcess >> 0;
    }
    this._alive = false;
    if (!this._stopped) {
      this._actualFrame += this._scaledUpdateSpeed;
      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {
        this.stop();
      }
    } else {
      newParticles = 0;
    }
    this._update(newParticles);
    if (this._stopped) {
      if (!this._alive) {
        this._started = false;
        if (this.onAnimationEnd) {
          this.onAnimationEnd();
        }
        if (this.disposeOnStop && this._scene) {
          this._scene._toBeDisposed.push(this);
        }
      }
    }
    if (!preWarmOnly) {
      let offset = 0;
      for (let index = 0; index < this._particles.length; index++) {
        const particle = this._particles[index];
        this._appendParticleVertices(offset, particle);
        offset += this._useInstancing ? 1 : 4;
      }
      if (this._vertexBuffer) {
        this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);
      }
    }
    if (this.manualEmitCount === 0 && this.disposeOnStop) {
      this.stop();
    }
  }
  _appendParticleVertices(offset, particle) {
    this._appendParticleVertex(offset++, particle, 0, 0);
    if (!this._useInstancing) {
      this._appendParticleVertex(offset++, particle, 1, 0);
      this._appendParticleVertex(offset++, particle, 1, 1);
      this._appendParticleVertex(offset++, particle, 0, 1);
    }
  }
  /**
   * Rebuilds the particle system.
   */
  rebuild() {
    var _a;
    if (this._engine.getCaps().vertexArrayObject) {
      this._vertexArrayObject = null;
    }
    this._createIndexBuffer();
    (_a = this._spriteBuffer) == null ? void 0 : _a._rebuild();
    this._createVertexBuffers();
    this.resetDrawCache();
  }
  async _initShaderSourceAsync() {
    const engine = this._engine;
    if (engine.isWebGPU && !_ThinParticleSystem.ForceGLSL) {
      this._shaderLanguage = 1;
      await Promise.all([import("./particles.vertex-LMVKMDZA.js"), import("./particles.fragment-DKUNRAVL.js")]);
    } else {
      await Promise.all([import("./particles.vertex-C5TX4GYR.js"), import("./particles.fragment-EOKK7IKS.js")]);
    }
    this._shadersLoaded = true;
  }
  /**
   * Is this system ready to be used/rendered
   * @returns true if the system is ready
   */
  isReady() {
    if (!this._shadersLoaded) {
      return false;
    }
    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {
      return false;
    }
    if (this.blendMode !== BaseParticleSystem.BLENDMODE_MULTIPLYADD) {
      if (!this._getWrapper(this.blendMode).effect.isReady()) {
        return false;
      }
    } else {
      if (!this._getWrapper(BaseParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {
        return false;
      }
      if (!this._getWrapper(BaseParticleSystem.BLENDMODE_ADD).effect.isReady()) {
        return false;
      }
    }
    return true;
  }
  _render(blendMode) {
    var _a, _b, _c, _d, _e;
    const drawWrapper = this._getWrapper(blendMode);
    const effect = drawWrapper.effect;
    const engine = this._engine;
    engine.enableEffect(drawWrapper);
    const viewMatrix = this.defaultViewMatrix ?? this._scene.getViewMatrix();
    effect.setTexture("diffuseSampler", this.particleTexture);
    effect.setMatrix("view", viewMatrix);
    effect.setMatrix("projection", this.defaultProjectionMatrix ?? this._scene.getProjectionMatrix());
    if (this._isAnimationSheetEnabled && this.particleTexture) {
      const baseSize = this.particleTexture.getBaseSize();
      effect.setFloat3("particlesInfos", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);
    }
    effect.setVector2("translationPivot", this.translationPivot);
    effect.setFloat4("textureMask", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);
    if (this._isBillboardBased && this._scene) {
      const camera = this._scene.activeCamera;
      effect.setVector3("eyePosition", camera.globalPosition);
    }
    if (this._rampGradientsTexture) {
      if (!this._rampGradients || !this._rampGradients.length) {
        this._rampGradientsTexture.dispose();
        this._rampGradientsTexture = null;
      }
      effect.setTexture("rampSampler", this._rampGradientsTexture);
    }
    const defines = effect.defines;
    if (this._scene) {
      BindClipPlane(effect, this, this._scene);
      if (this.applyFog) {
        BindFogParameters(this._scene, void 0, effect);
      }
    }
    if (defines.indexOf("#define BILLBOARDMODE_ALL") >= 0) {
      viewMatrix.invertToRef(TmpVectors.Matrix[0]);
      effect.setMatrix("invView", TmpVectors.Matrix[0]);
    }
    if (this._vertexArrayObject !== void 0) {
      if ((_a = this._scene) == null ? void 0 : _a.forceWireframe) {
        engine.bindBuffers(this._vertexBuffers, this._linesIndexBufferUseInstancing, effect);
      } else {
        if (!this._vertexArrayObject) {
          this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);
        }
        this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);
      }
    } else {
      if (!this._indexBuffer) {
        engine.bindBuffers(this._vertexBuffers, ((_b = this._scene) == null ? void 0 : _b.forceWireframe) ? this._linesIndexBufferUseInstancing : null, effect);
      } else {
        engine.bindBuffers(this._vertexBuffers, ((_c = this._scene) == null ? void 0 : _c.forceWireframe) ? this._linesIndexBuffer : this._indexBuffer, effect);
      }
    }
    if (this.useLogarithmicDepth && this._scene) {
      BindLogDepth(defines, effect, this._scene);
    }
    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
      this._imageProcessingConfiguration.bind(effect);
    }
    this._setEngineBasedOnBlendMode(blendMode);
    if (this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable.notifyObservers(effect);
    }
    if (this._useInstancing) {
      if ((_d = this._scene) == null ? void 0 : _d.forceWireframe) {
        engine.drawElementsType(6, 0, 10, this._particles.length);
      } else {
        engine.drawArraysType(7, 0, 4, this._particles.length);
      }
    } else {
      if ((_e = this._scene) == null ? void 0 : _e.forceWireframe) {
        engine.drawElementsType(1, 0, this._particles.length * 10);
      } else {
        engine.drawElementsType(0, 0, this._particles.length * 6);
      }
    }
    return this._particles.length;
  }
  /**
   * Renders the particle system in its current state.
   * @returns the current number of particles
   */
  render() {
    if (!this.isReady() || !this._particles.length) {
      return 0;
    }
    const engine = this._engine;
    if (engine.setState) {
      engine.setState(false);
      if (this.forceDepthWrite) {
        engine.setDepthWrite(true);
      }
    }
    let outparticles = 0;
    if (this.blendMode === BaseParticleSystem.BLENDMODE_MULTIPLYADD) {
      outparticles = this._render(BaseParticleSystem.BLENDMODE_MULTIPLY) + this._render(BaseParticleSystem.BLENDMODE_ADD);
    } else {
      outparticles = this._render(this.blendMode);
    }
    this._engine.unbindInstanceAttributes();
    this._engine.setAlphaMode(0);
    return outparticles;
  }
  /** @internal */
  _onDispose(_disposeAttachedSubEmitters = false, _disposeEndSubEmitters = false) {
  }
  /**
   * Disposes the particle system and free the associated resources
   * @param disposeTexture defines if the particle texture must be disposed as well (true by default)
   * @param disposeAttachedSubEmitters defines if the attached sub-emitters must be disposed as well (false by default)
   * @param disposeEndSubEmitters defines if the end type sub-emitters must be disposed as well (false by default)
   */
  dispose(disposeTexture = true, disposeAttachedSubEmitters = false, disposeEndSubEmitters = false) {
    this.resetDrawCache();
    if (this._vertexBuffer) {
      this._vertexBuffer.dispose();
      this._vertexBuffer = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    if (this._linesIndexBuffer) {
      this._engine._releaseBuffer(this._linesIndexBuffer);
      this._linesIndexBuffer = null;
    }
    if (this._linesIndexBufferUseInstancing) {
      this._engine._releaseBuffer(this._linesIndexBufferUseInstancing);
      this._linesIndexBufferUseInstancing = null;
    }
    if (this._vertexArrayObject) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObject);
      this._vertexArrayObject = null;
    }
    if (disposeTexture && this.particleTexture) {
      this.particleTexture.dispose();
      this.particleTexture = null;
    }
    if (disposeTexture && this.noiseTexture) {
      this.noiseTexture.dispose();
      this.noiseTexture = null;
    }
    if (this._rampGradientsTexture) {
      this._rampGradientsTexture.dispose();
      this._rampGradientsTexture = null;
    }
    this._onDispose(disposeAttachedSubEmitters, disposeEndSubEmitters);
    if (this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable.clear();
    }
    if (this._scene) {
      const index = this._scene.particleSystems.indexOf(this);
      if (index > -1) {
        this._scene.particleSystems.splice(index, 1);
      }
      this._scene._activeParticleSystems.dispose();
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onStoppedObservable.clear();
    this.onStartedObservable.clear();
    this.reset();
    this._isDisposed = true;
  }
};
ThinParticleSystem.ForceGLSL = false;

// node_modules/@babylonjs/core/Particles/subEmitter.js
var SubEmitterType;
(function(SubEmitterType2) {
  SubEmitterType2[SubEmitterType2["ATTACHED"] = 0] = "ATTACHED";
  SubEmitterType2[SubEmitterType2["END"] = 1] = "END";
})(SubEmitterType || (SubEmitterType = {}));
var SubEmitter = class _SubEmitter {
  /**
   * Creates a sub emitter
   * @param particleSystem the particle system to be used by the sub emitter
   */
  constructor(particleSystem) {
    this.particleSystem = particleSystem;
    this.type = 1;
    this.inheritDirection = false;
    this.inheritedVelocityAmount = 0;
    if (!particleSystem.emitter || !particleSystem.emitter.dispose) {
      const internalClass = GetClass("BABYLON.AbstractMesh");
      particleSystem.emitter = new internalClass("SubemitterSystemEmitter", particleSystem.getScene());
      particleSystem._disposeEmitterOnDispose = true;
    }
  }
  /**
   * Clones the sub emitter
   * @returns the cloned sub emitter
   */
  clone() {
    let emitter = this.particleSystem.emitter;
    if (!emitter) {
      emitter = new Vector3();
    } else if (emitter instanceof Vector3) {
      emitter = emitter.clone();
    } else if (emitter.getClassName().indexOf("Mesh") !== -1) {
      const internalClass = GetClass("BABYLON.Mesh");
      emitter = new internalClass("", emitter.getScene());
      emitter.isVisible = false;
    }
    const clone = new _SubEmitter(this.particleSystem.clone(this.particleSystem.name, emitter));
    clone.particleSystem.name += "Clone";
    clone.type = this.type;
    clone.inheritDirection = this.inheritDirection;
    clone.inheritedVelocityAmount = this.inheritedVelocityAmount;
    clone.particleSystem._disposeEmitterOnDispose = true;
    clone.particleSystem.disposeOnStop = true;
    return clone;
  }
  /**
   * Serialize current object to a JSON object
   * @param serializeTexture defines if the texture must be serialized as well
   * @returns the serialized object
   */
  serialize(serializeTexture = false) {
    const serializationObject = {};
    serializationObject.type = this.type;
    serializationObject.inheritDirection = this.inheritDirection;
    serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;
    serializationObject.particleSystem = this.particleSystem.serialize(serializeTexture);
    return serializationObject;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static _ParseParticleSystem(system, sceneOrEngine, rootUrl, doNotStart = false) {
    throw _WarnImport("ParseParticle");
  }
  /**
   * Creates a new SubEmitter from a serialized JSON version
   * @param serializationObject defines the JSON object to read from
   * @param sceneOrEngine defines the hosting scene or the hosting engine
   * @param rootUrl defines the rootUrl for data loading
   * @returns a new SubEmitter
   */
  static Parse(serializationObject, sceneOrEngine, rootUrl) {
    const system = serializationObject.particleSystem;
    const subEmitter = new _SubEmitter(_SubEmitter._ParseParticleSystem(system, sceneOrEngine, rootUrl, true));
    subEmitter.type = serializationObject.type;
    subEmitter.inheritDirection = serializationObject.inheritDirection;
    subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;
    subEmitter.particleSystem._isSubEmitter = true;
    return subEmitter;
  }
  /** Release associated resources */
  dispose() {
    this.particleSystem.dispose();
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/meshParticleEmitter.js
var MeshParticleEmitter = class _MeshParticleEmitter {
  /** Defines the mesh to use as source */
  get mesh() {
    return this._mesh;
  }
  set mesh(value) {
    if (this._mesh === value) {
      return;
    }
    this._mesh = value;
    if (value) {
      this._indices = value.getIndices();
      this._positions = value.getVerticesData(VertexBuffer.PositionKind);
      this._normals = value.getVerticesData(VertexBuffer.NormalKind);
    } else {
      this._indices = null;
      this._positions = null;
      this._normals = null;
    }
  }
  /**
   * Creates a new instance MeshParticleEmitter
   * @param mesh defines the mesh to use as source
   */
  constructor(mesh = null) {
    this._indices = null;
    this._positions = null;
    this._normals = null;
    this._storedNormal = Vector3.Zero();
    this._mesh = null;
    this.direction1 = new Vector3(0, 1, 0);
    this.direction2 = new Vector3(0, 1, 0);
    this.useMeshNormalsForDirection = true;
    this.mesh = mesh;
  }
  /**
   * Called by the particle System when the direction is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param directionToUpdate is the direction vector to update with the result
   * @param particle is the particle we are computed the direction for
   * @param isLocal defines if the direction should be set in local space
   */
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    if (this.useMeshNormalsForDirection && this._normals) {
      Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);
      return;
    }
    const randX = RandomRange(this.direction1.x, this.direction2.x);
    const randY = RandomRange(this.direction1.y, this.direction2.y);
    const randZ = RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  }
  /**
   * Called by the particle System when the position is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param positionToUpdate is the position vector to update with the result
   * @param particle is the particle we are computed the position for
   * @param isLocal defines if the position should be set in local space
   */
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    if (!this._indices || !this._positions) {
      return;
    }
    const randomFaceIndex = 3 * (Math.random() * (this._indices.length / 3) | 0);
    const bu = Math.random();
    const bv = Math.random() * (1 - bu);
    const bw = 1 - bu - bv;
    const faceIndexA = this._indices[randomFaceIndex];
    const faceIndexB = this._indices[randomFaceIndex + 1];
    const faceIndexC = this._indices[randomFaceIndex + 2];
    const vertexA = TmpVectors.Vector3[0];
    const vertexB = TmpVectors.Vector3[1];
    const vertexC = TmpVectors.Vector3[2];
    const randomVertex = TmpVectors.Vector3[3];
    Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);
    Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);
    Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);
    randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;
    randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;
    randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;
    if (isLocal) {
      positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);
    } else {
      Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);
    }
    if (this.useMeshNormalsForDirection && this._normals) {
      Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);
      Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);
      Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);
      this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;
      this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;
      this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;
    }
  }
  /**
   * Clones the current emitter and returns a copy of it
   * @returns the new emitter
   */
  clone() {
    const newOne = new _MeshParticleEmitter(this.mesh);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  /**
   * Called by the GPUParticleSystem to setup the update shader
   * @param uboOrEffect defines the update shader
   */
  applyToShader(uboOrEffect) {
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  }
  /**
   * Creates the structure of the ubo for this particle emitter
   * @param ubo ubo to create the structure for
   */
  buildUniformLayout(ubo) {
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  }
  /**
   * Returns a string to use to update the GPU particles update shader
   * @returns a string containing the defines string
   */
  getEffectDefines() {
    return "";
  }
  /**
   * Returns the string "BoxParticleEmitter"
   * @returns a string containing the class name
   */
  getClassName() {
    return "MeshParticleEmitter";
  }
  /**
   * Serializes the particle system to a JSON object.
   * @returns the JSON object
   */
  serialize() {
    var _a;
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    serializationObject.meshId = (_a = this.mesh) == null ? void 0 : _a.id;
    serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;
    return serializationObject;
  }
  /**
   * Parse properties from a JSON object
   * @param serializationObject defines the JSON object
   * @param scene defines the hosting scene
   */
  parse(serializationObject, scene) {
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
    if (serializationObject.meshId && scene) {
      this.mesh = scene.getLastMeshById(serializationObject.meshId);
    }
    this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/pointParticleEmitter.js
var PointParticleEmitter = class _PointParticleEmitter {
  /**
   * Creates a new instance PointParticleEmitter
   */
  constructor() {
    this.direction1 = new Vector3(0, 1, 0);
    this.direction2 = new Vector3(0, 1, 0);
  }
  /**
   * Called by the particle System when the direction is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param directionToUpdate is the direction vector to update with the result
   * @param particle is the particle we are computed the direction for
   * @param isLocal defines if the direction should be set in local space
   */
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    const randX = RandomRange(this.direction1.x, this.direction2.x);
    const randY = RandomRange(this.direction1.y, this.direction2.y);
    const randZ = RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  }
  /**
   * Called by the particle System when the position is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param positionToUpdate is the position vector to update with the result
   * @param particle is the particle we are computed the position for
   * @param isLocal defines if the position should be set in local space
   */
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    if (isLocal) {
      positionToUpdate.copyFromFloats(0, 0, 0);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);
  }
  /**
   * Clones the current emitter and returns a copy of it
   * @returns the new emitter
   */
  clone() {
    const newOne = new _PointParticleEmitter();
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  /**
   * Called by the GPUParticleSystem to setup the update shader
   * @param uboOrEffect defines the update shader
   */
  applyToShader(uboOrEffect) {
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  }
  /**
   * Creates the structure of the ubo for this particle emitter
   * @param ubo ubo to create the structure for
   */
  buildUniformLayout(ubo) {
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  }
  /**
   * Returns a string to use to update the GPU particles update shader
   * @returns a string containing the defines string
   */
  getEffectDefines() {
    return "#define POINTEMITTER";
  }
  /**
   * Returns the string "PointParticleEmitter"
   * @returns a string containing the class name
   */
  getClassName() {
    return "PointParticleEmitter";
  }
  /**
   * Serializes the particle system to a JSON object.
   * @returns the JSON object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  }
  /**
   * Parse properties from a JSON object
   * @param serializationObject defines the JSON object
   */
  parse(serializationObject) {
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/hemisphericParticleEmitter.js
var HemisphericParticleEmitter = class _HemisphericParticleEmitter {
  /**
   * Creates a new instance HemisphericParticleEmitter
   * @param radius the radius of the emission hemisphere (1 by default)
   * @param radiusRange the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)
   * @param directionRandomizer defines how much to randomize the particle direction [0-1]
   */
  constructor(radius = 1, radiusRange = 1, directionRandomizer = 0) {
    this.radius = radius;
    this.radiusRange = radiusRange;
    this.directionRandomizer = directionRandomizer;
  }
  /**
   * Called by the particle System when the direction is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param directionToUpdate is the direction vector to update with the result
   * @param particle is the particle we are computed the direction for
   * @param isLocal defines if the direction should be set in local space
   */
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
    const randX = RandomRange(0, this.directionRandomizer);
    const randY = RandomRange(0, this.directionRandomizer);
    const randZ = RandomRange(0, this.directionRandomizer);
    direction.x += randX;
    direction.y += randY;
    direction.z += randZ;
    direction.normalize();
    if (isLocal) {
      directionToUpdate.copyFrom(direction);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
  }
  /**
   * Called by the particle System when the position is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param positionToUpdate is the position vector to update with the result
   * @param particle is the particle we are computed the position for
   * @param isLocal defines if the position should be set in local space
   */
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    const randRadius = this.radius - RandomRange(0, this.radius * this.radiusRange);
    const v = RandomRange(0, 1);
    const phi = RandomRange(0, 2 * Math.PI);
    const theta = Math.acos(2 * v - 1);
    const randX = randRadius * Math.cos(phi) * Math.sin(theta);
    const randY = randRadius * Math.cos(theta);
    const randZ = randRadius * Math.sin(phi) * Math.sin(theta);
    if (isLocal) {
      positionToUpdate.copyFromFloats(randX, Math.abs(randY), randZ);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);
  }
  /**
   * Clones the current emitter and returns a copy of it
   * @returns the new emitter
   */
  clone() {
    const newOne = new _HemisphericParticleEmitter(this.radius, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  /**
   * Called by the GPUParticleSystem to setup the update shader
   * @param uboOrEffect defines the update shader
   */
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
  }
  /**
   * Creates the structure of the ubo for this particle emitter
   * @param ubo ubo to create the structure for
   */
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("directionRandomizer", 1);
  }
  /**
   * Returns a string to use to update the GPU particles update shader
   * @returns a string containing the defines string
   */
  getEffectDefines() {
    return "#define HEMISPHERICEMITTER";
  }
  /**
   * Returns the string "HemisphericParticleEmitter"
   * @returns a string containing the class name
   */
  getClassName() {
    return "HemisphericParticleEmitter";
  }
  /**
   * Serializes the particle system to a JSON object.
   * @returns the JSON object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this.radius;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.directionRandomizer = this.directionRandomizer;
    return serializationObject;
  }
  /**
   * Parse properties from a JSON object
   * @param serializationObject defines the JSON object
   */
  parse(serializationObject) {
    this.radius = serializationObject.radius;
    this.radiusRange = serializationObject.radiusRange;
    this.directionRandomizer = serializationObject.directionRandomizer;
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/sphereParticleEmitter.js
var SphereParticleEmitter = class _SphereParticleEmitter {
  /**
   * Creates a new instance SphereParticleEmitter
   * @param radius the radius of the emission sphere (1 by default)
   * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)
   * @param directionRandomizer defines how much to randomize the particle direction [0-1]
   */
  constructor(radius = 1, radiusRange = 1, directionRandomizer = 0) {
    this.radius = radius;
    this.radiusRange = radiusRange;
    this.directionRandomizer = directionRandomizer;
  }
  /**
   * Called by the particle System when the direction is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param directionToUpdate is the direction vector to update with the result
   * @param particle is the particle we are computed the direction for
   * @param isLocal defines if the direction should be set in local space
   */
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
    const randX = RandomRange(0, this.directionRandomizer);
    const randY = RandomRange(0, this.directionRandomizer);
    const randZ = RandomRange(0, this.directionRandomizer);
    direction.x += randX;
    direction.y += randY;
    direction.z += randZ;
    direction.normalize();
    if (isLocal) {
      directionToUpdate.copyFrom(direction);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
  }
  /**
   * Called by the particle System when the position is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param positionToUpdate is the position vector to update with the result
   * @param particle is the particle we are computed the position for
   * @param isLocal defines if the position should be set in local space
   */
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    const randRadius = this.radius - RandomRange(0, this.radius * this.radiusRange);
    const v = RandomRange(0, 1);
    const phi = RandomRange(0, 2 * Math.PI);
    const theta = Math.acos(2 * v - 1);
    const randX = randRadius * Math.cos(phi) * Math.sin(theta);
    const randY = randRadius * Math.cos(theta);
    const randZ = randRadius * Math.sin(phi) * Math.sin(theta);
    if (isLocal) {
      positionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
  }
  /**
   * Clones the current emitter and returns a copy of it
   * @returns the new emitter
   */
  clone() {
    const newOne = new _SphereParticleEmitter(this.radius, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  /**
   * Called by the GPUParticleSystem to setup the update shader
   * @param uboOrEffect defines the update shader
   */
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
  }
  /**
   * Creates the structure of the ubo for this particle emitter
   * @param ubo ubo to create the structure for
   */
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("directionRandomizer", 1);
  }
  /**
   * Returns a string to use to update the GPU particles update shader
   * @returns a string containing the defines string
   */
  getEffectDefines() {
    return "#define SPHEREEMITTER";
  }
  /**
   * Returns the string "SphereParticleEmitter"
   * @returns a string containing the class name
   */
  getClassName() {
    return "SphereParticleEmitter";
  }
  /**
   * Serializes the particle system to a JSON object.
   * @returns the JSON object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this.radius;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.directionRandomizer = this.directionRandomizer;
    return serializationObject;
  }
  /**
   * Parse properties from a JSON object
   * @param serializationObject defines the JSON object
   */
  parse(serializationObject) {
    this.radius = serializationObject.radius;
    this.radiusRange = serializationObject.radiusRange;
    this.directionRandomizer = serializationObject.directionRandomizer;
  }
};
var SphereDirectedParticleEmitter = class _SphereDirectedParticleEmitter extends SphereParticleEmitter {
  /**
   * Creates a new instance SphereDirectedParticleEmitter
   * @param radius the radius of the emission sphere (1 by default)
   * @param direction1 the min limit of the emission direction (up vector by default)
   * @param direction2 the max limit of the emission direction (up vector by default)
   */
  constructor(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    super(radius);
    this.direction1 = direction1;
    this.direction2 = direction2;
  }
  /**
   * Called by the particle System when the direction is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param directionToUpdate is the direction vector to update with the result
   */
  startDirectionFunction(worldMatrix, directionToUpdate) {
    const randX = RandomRange(this.direction1.x, this.direction2.x);
    const randY = RandomRange(this.direction1.y, this.direction2.y);
    const randZ = RandomRange(this.direction1.z, this.direction2.z);
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  }
  /**
   * Clones the current emitter and returns a copy of it
   * @returns the new emitter
   */
  clone() {
    const newOne = new _SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  /**
   * Called by the GPUParticleSystem to setup the update shader
   * @param uboOrEffect defines the update shader
   */
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  }
  /**
   * Creates the structure of the ubo for this particle emitter
   * @param ubo ubo to create the structure for
   */
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  }
  /**
   * Returns a string to use to update the GPU particles update shader
   * @returns a string containing the defines string
   */
  getEffectDefines() {
    return "#define SPHEREEMITTER\n#define DIRECTEDSPHEREEMITTER";
  }
  /**
   * Returns the string "SphereDirectedParticleEmitter"
   * @returns a string containing the class name
   */
  getClassName() {
    return "SphereDirectedParticleEmitter";
  }
  /**
   * Serializes the particle system to a JSON object.
   * @returns the JSON object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  }
  /**
   * Parse properties from a JSON object
   * @param serializationObject defines the JSON object
   */
  parse(serializationObject) {
    super.parse(serializationObject);
    this.direction1.copyFrom(serializationObject.direction1);
    this.direction2.copyFrom(serializationObject.direction2);
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/cylinderParticleEmitter.js
var CylinderParticleEmitter = class _CylinderParticleEmitter {
  /**
   * Creates a new instance CylinderParticleEmitter
   * @param radius the radius of the emission cylinder (1 by default)
   * @param height the height of the emission cylinder (1 by default)
   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
   * @param directionRandomizer defines how much to randomize the particle direction [0-1]
   */
  constructor(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
    this.radius = radius;
    this.height = height;
    this.radiusRange = radiusRange;
    this.directionRandomizer = directionRandomizer;
    this._tempVector = Vector3.Zero();
  }
  /**
   * Called by the particle System when the direction is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param directionToUpdate is the direction vector to update with the result
   * @param particle is the particle we are computed the direction for
   * @param isLocal defines if the direction should be set in local space
   * @param inverseWorldMatrix defines the inverted world matrix to use if isLocal is false
   */
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal, inverseWorldMatrix) {
    particle.position.subtractToRef(worldMatrix.getTranslation(), this._tempVector);
    this._tempVector.normalize();
    Vector3.TransformNormalToRef(this._tempVector, inverseWorldMatrix, this._tempVector);
    const randY = RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);
    let angle = Math.atan2(this._tempVector.x, this._tempVector.z);
    angle += RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;
    this._tempVector.y = randY;
    this._tempVector.x = Math.sin(angle);
    this._tempVector.z = Math.cos(angle);
    this._tempVector.normalize();
    if (isLocal) {
      directionToUpdate.copyFrom(this._tempVector);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, worldMatrix, directionToUpdate);
  }
  /**
   * Called by the particle System when the position is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param positionToUpdate is the position vector to update with the result
   * @param particle is the particle we are computed the position for
   * @param isLocal defines if the position should be set in local space
   */
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    const yPos = RandomRange(-this.height / 2, this.height / 2);
    const angle = RandomRange(0, 2 * Math.PI);
    const radiusDistribution = RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);
    const positionRadius = Math.sqrt(radiusDistribution) * this.radius;
    const xPos = positionRadius * Math.cos(angle);
    const zPos = positionRadius * Math.sin(angle);
    if (isLocal) {
      positionToUpdate.copyFromFloats(xPos, yPos, zPos);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);
  }
  /**
   * Clones the current emitter and returns a copy of it
   * @returns the new emitter
   */
  clone() {
    const newOne = new _CylinderParticleEmitter(this.radius, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  /**
   * Called by the GPUParticleSystem to setup the update shader
   * @param uboOrEffect defines the update shader
   */
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("height", this.height);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
  }
  /**
   * Creates the structure of the ubo for this particle emitter
   * @param ubo ubo to create the structure for
   */
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("height", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("directionRandomizer", 1);
  }
  /**
   * Returns a string to use to update the GPU particles update shader
   * @returns a string containing the defines string
   */
  getEffectDefines() {
    return "#define CYLINDEREMITTER";
  }
  /**
   * Returns the string "CylinderParticleEmitter"
   * @returns a string containing the class name
   */
  getClassName() {
    return "CylinderParticleEmitter";
  }
  /**
   * Serializes the particle system to a JSON object.
   * @returns the JSON object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this.radius;
    serializationObject.height = this.height;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.directionRandomizer = this.directionRandomizer;
    return serializationObject;
  }
  /**
   * Parse properties from a JSON object
   * @param serializationObject defines the JSON object
   */
  parse(serializationObject) {
    this.radius = serializationObject.radius;
    this.height = serializationObject.height;
    this.radiusRange = serializationObject.radiusRange;
    this.directionRandomizer = serializationObject.directionRandomizer;
  }
};
var CylinderDirectedParticleEmitter = class _CylinderDirectedParticleEmitter extends CylinderParticleEmitter {
  /**
   * Creates a new instance CylinderDirectedParticleEmitter
   * @param radius the radius of the emission cylinder (1 by default)
   * @param height the height of the emission cylinder (1 by default)
   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
   * @param direction1 the min limit of the emission direction (up vector by default)
   * @param direction2 the max limit of the emission direction (up vector by default)
   */
  constructor(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    super(radius, height, radiusRange);
    this.direction1 = direction1;
    this.direction2 = direction2;
  }
  /**
   * Called by the particle System when the direction is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param directionToUpdate is the direction vector to update with the result
   * @param _particle is the particle we are computed the direction for
   * @param isLocal defines if the direction should be set in local space
   */
  startDirectionFunction(worldMatrix, directionToUpdate, _particle, isLocal) {
    const randX = RandomRange(this.direction1.x, this.direction2.x);
    const randY = RandomRange(this.direction1.y, this.direction2.y);
    const randZ = RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  }
  /**
   * Clones the current emitter and returns a copy of it
   * @returns the new emitter
   */
  clone() {
    const newOne = new _CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  /**
   * Called by the GPUParticleSystem to setup the update shader
   * @param uboOrEffect defines the update shader
   */
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("height", this.height);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  }
  /**
   * Creates the structure of the ubo for this particle emitter
   * @param ubo ubo to create the structure for
   */
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("height", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  }
  /**
   * Returns a string to use to update the GPU particles update shader
   * @returns a string containing the defines string
   */
  getEffectDefines() {
    return "#define CYLINDEREMITTER\n#define DIRECTEDCYLINDEREMITTER";
  }
  /**
   * Returns the string "CylinderDirectedParticleEmitter"
   * @returns a string containing the class name
   */
  getClassName() {
    return "CylinderDirectedParticleEmitter";
  }
  /**
   * Serializes the particle system to a JSON object.
   * @returns the JSON object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  }
  /**
   * Parse properties from a JSON object
   * @param serializationObject defines the JSON object
   */
  parse(serializationObject) {
    super.parse(serializationObject);
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/coneParticleEmitter.js
var ConeParticleEmitter = class _ConeParticleEmitter {
  /**
   * Gets or sets the radius of the emission cone
   */
  get radius() {
    return this._radius;
  }
  set radius(value) {
    this._radius = value;
    this._buildHeight();
  }
  /**
   * Gets or sets the angle of the emission cone
   */
  get angle() {
    return this._angle;
  }
  set angle(value) {
    this._angle = value;
    this._buildHeight();
  }
  _buildHeight() {
    if (this._angle !== 0) {
      this._height = this._radius / Math.tan(this._angle / 2);
    } else {
      this._height = 1;
    }
  }
  /**
   * Creates a new instance ConeParticleEmitter
   * @param radius the radius of the emission cone (1 by default)
   * @param angle the cone base angle (PI by default)
   * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)
   */
  constructor(radius = 1, angle = Math.PI, directionRandomizer = 0) {
    this.directionRandomizer = directionRandomizer;
    this.radiusRange = 1;
    this.heightRange = 1;
    this.emitFromSpawnPointOnly = false;
    this.angle = angle;
    this.radius = radius;
  }
  /**
   * Called by the particle System when the direction is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param directionToUpdate is the direction vector to update with the result
   * @param particle is the particle we are computed the direction for
   * @param isLocal defines if the direction should be set in local space
   */
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    if (isLocal) {
      TmpVectors.Vector3[0].copyFrom(particle._localPosition).normalize();
    } else {
      particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();
    }
    const randX = RandomRange(0, this.directionRandomizer);
    const randY = RandomRange(0, this.directionRandomizer);
    const randZ = RandomRange(0, this.directionRandomizer);
    directionToUpdate.x = TmpVectors.Vector3[0].x + randX;
    directionToUpdate.y = TmpVectors.Vector3[0].y + randY;
    directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;
    directionToUpdate.normalize();
  }
  /**
   * Called by the particle System when the position is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param positionToUpdate is the position vector to update with the result
   * @param particle is the particle we are computed the position for
   * @param isLocal defines if the position should be set in local space
   */
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    const s = RandomRange(0, Math.PI * 2);
    let h;
    if (!this.emitFromSpawnPointOnly) {
      h = RandomRange(0, this.heightRange);
      h = 1 - h * h;
    } else {
      h = 1e-4;
    }
    let radius = this._radius - RandomRange(0, this._radius * this.radiusRange);
    radius = radius * h;
    const randX = radius * Math.sin(s);
    const randZ = radius * Math.cos(s);
    const randY = h * this._height;
    if (isLocal) {
      positionToUpdate.x = randX;
      positionToUpdate.y = randY;
      positionToUpdate.z = randZ;
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
  }
  /**
   * Clones the current emitter and returns a copy of it
   * @returns the new emitter
   */
  clone() {
    const newOne = new _ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  /**
   * Called by the GPUParticleSystem to setup the update shader
   * @param uboOrEffect defines the update shader
   */
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat2("radius", this._radius, this.radiusRange);
    uboOrEffect.setFloat("coneAngle", this._angle);
    uboOrEffect.setFloat2("height", this._height, this.heightRange);
    uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
  }
  /**
   * Creates the structure of the ubo for this particle emitter
   * @param ubo ubo to create the structure for
   */
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 2);
    ubo.addUniform("coneAngle", 1);
    ubo.addUniform("height", 2);
    ubo.addUniform("directionRandomizer", 1);
  }
  /**
   * Returns a string to use to update the GPU particles update shader
   * @returns a string containing the defines string
   */
  getEffectDefines() {
    let defines = "#define CONEEMITTER";
    if (this.emitFromSpawnPointOnly) {
      defines += "\n#define CONEEMITTERSPAWNPOINT";
    }
    return defines;
  }
  /**
   * Returns the string "ConeParticleEmitter"
   * @returns a string containing the class name
   */
  getClassName() {
    return "ConeParticleEmitter";
  }
  /**
   * Serializes the particle system to a JSON object.
   * @returns the JSON object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this._radius;
    serializationObject.angle = this._angle;
    serializationObject.directionRandomizer = this.directionRandomizer;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.heightRange = this.heightRange;
    serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;
    return serializationObject;
  }
  /**
   * Parse properties from a JSON object
   * @param serializationObject defines the JSON object
   */
  parse(serializationObject) {
    this.radius = serializationObject.radius;
    this.angle = serializationObject.angle;
    this.directionRandomizer = serializationObject.directionRandomizer;
    this.radiusRange = serializationObject.radiusRange !== void 0 ? serializationObject.radiusRange : 1;
    this.heightRange = serializationObject.radiusRange !== void 0 ? serializationObject.heightRange : 1;
    this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== void 0 ? serializationObject.emitFromSpawnPointOnly : false;
  }
};
var ConeDirectedParticleEmitter = class _ConeDirectedParticleEmitter extends ConeParticleEmitter {
  constructor(radius = 1, angle = Math.PI, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    super(radius, angle);
    this.direction1 = direction1;
    this.direction2 = direction2;
  }
  /**
   * Called by the particle System when the direction is computed for the created particle.
   * @param worldMatrix is the world matrix of the particle system
   * @param directionToUpdate is the direction vector to update with the result
   */
  startDirectionFunction(worldMatrix, directionToUpdate) {
    const randX = RandomRange(this.direction1.x, this.direction2.x);
    const randY = RandomRange(this.direction1.y, this.direction2.y);
    const randZ = RandomRange(this.direction1.z, this.direction2.z);
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  }
  /**
   * Clones the current emitter and returns a copy of it
   * @returns the new emitter
   */
  clone() {
    const newOne = new _ConeDirectedParticleEmitter(this.radius, this.angle, this.direction1, this.direction2);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  /**
   * Called by the GPUParticleSystem to setup the update shader
   * @param uboOrEffect defines the update shader
   */
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  }
  /**
   * Creates the structure of the ubo for this particle emitter
   * @param ubo ubo to create the structure for
   */
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  }
  /**
   * Returns a string to use to update the GPU particles update shader
   * @returns a string containing the defines string
   */
  getEffectDefines() {
    return "#define CONEEMITTER\n#define DIRECTEDCONEEMITTER";
  }
  /**
   * Returns the string "ConeDirectedParticleEmitter"
   * @returns a string containing the class name
   */
  getClassName() {
    return "ConeDirectedParticleEmitter";
  }
  /**
   * Serializes the particle system to a JSON object.
   * @returns the JSON object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  }
  /**
   * Parse properties from a JSON object
   * @param serializationObject defines the JSON object
   */
  parse(serializationObject) {
    super.parse(serializationObject);
    this.direction1.copyFrom(serializationObject.direction1);
    this.direction2.copyFrom(serializationObject.direction2);
  }
};

// node_modules/@babylonjs/core/Particles/particleSystem.functions.js
function CreatePointEmitter(direction1, direction2) {
  const particleEmitter = new PointParticleEmitter();
  particleEmitter.direction1 = direction1;
  particleEmitter.direction2 = direction2;
  return particleEmitter;
}
function CreateHemisphericEmitter(radius = 1, radiusRange = 1) {
  return new HemisphericParticleEmitter(radius, radiusRange);
}
function CreateSphereEmitter(radius = 1, radiusRange = 1) {
  return new SphereParticleEmitter(radius, radiusRange);
}
function CreateDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
  return new SphereDirectedParticleEmitter(radius, direction1, direction2);
}
function CreateCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
  return new CylinderParticleEmitter(radius, height, radiusRange, directionRandomizer);
}
function CreateDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
  return new CylinderDirectedParticleEmitter(radius, height, radiusRange, direction1, direction2);
}
function CreateConeEmitter(radius = 1, angle = Math.PI / 4) {
  return new ConeParticleEmitter(radius, angle);
}
function CreateDirectedConeEmitter(radius = 1, angle = Math.PI / 4, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
  return new ConeDirectedParticleEmitter(radius, angle, direction1, direction2);
}

// node_modules/@babylonjs/core/Particles/attractor.js
var ToAttractor = Vector3.Zero();
var Force = Vector3.Zero();
var ScaledForce = Vector3.Zero();
var Attractor = class {
  constructor() {
    this.strength = 0;
    this.position = Vector3.Zero();
  }
  /** @internal */
  _processParticle(particle, system) {
    this.position.subtractToRef(particle.position, ToAttractor);
    const distanceSquared = ToAttractor.lengthSquared() + 1;
    ToAttractor.normalize().scaleToRef(this.strength / distanceSquared, Force);
    Force.scaleToRef(system._tempScaledUpdateSpeed, ScaledForce);
    particle.direction.addInPlace(ScaledForce);
  }
  /**
   * Serializes the attractor to a JSON object.
   * @returns The serialized JSON object.
   */
  serialize() {
    return {
      position: this.position.asArray(),
      strength: this.strength
    };
  }
};

// node_modules/@babylonjs/core/Particles/particleSystem.js
var ParticleSystem = class _ParticleSystem extends ThinParticleSystem {
  constructor() {
    super(...arguments);
    this._disposeEmitterOnDispose = false;
    this.canStart = () => {
      return true;
    };
    this._flowMap = null;
    this._flowMapUpdate = null;
    this._source = null;
    this._blockReference = 0;
    this.flowMapStrength = 1;
    this._attractors = [];
    this._attractorUpdate = null;
    this.metadata = null;
    this._emitFromParticle = (particle) => {
      if (!this._subEmitters || this._subEmitters.length === 0) {
        return;
      }
      const templateIndex = Math.floor(Math.random() * this._subEmitters.length);
      for (const subEmitter of this._subEmitters[templateIndex]) {
        if (subEmitter.type === 1) {
          const subSystem = subEmitter.clone();
          particle._inheritParticleInfoToSubEmitter(subSystem);
          subSystem.particleSystem._rootParticleSystem = this;
          this.activeSubSystems.push(subSystem.particleSystem);
          subSystem.particleSystem.start();
        }
      }
    };
  }
  /**
   * Creates a Point Emitter for the particle system (emits directly from the emitter position)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
   * @returns the emitter
   */
  createPointEmitter(direction1, direction2) {
    const particleEmitter = CreatePointEmitter(direction1, direction2);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  /**
   * Gets the NodeParticleSystemSet that this particle system belongs to.
   */
  get source() {
    return this._source;
  }
  /**
   * Returns true if the particle system was generated by a node particle system set
   */
  get isNodeGenerated() {
    return this._source !== null;
  }
  /** Gets or sets the current flow map */
  get flowMap() {
    return this._flowMap;
  }
  set flowMap(value) {
    if (this._flowMap === value) {
      return;
    }
    this._flowMap = value;
    if (this._flowMapUpdate) {
      _RemoveFromQueue(this._flowMapUpdate);
      this._flowMapUpdate = null;
    }
    if (value) {
      this._flowMapUpdate = {
        process: (particle) => {
          var _a;
          const matrix = (_a = this.getScene()) == null ? void 0 : _a.getTransformMatrix();
          this._flowMap._processParticle(particle, this.flowMapStrength * this._tempScaledUpdateSpeed, matrix);
        },
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._flowMapUpdate, this._directionProcessing);
    }
  }
  /**
   * The list of attractors used to change the direction of the particles in the system.
   * Please note that this is a copy of the internal array. If you want to modify it, please use the addAttractor and removeAttractor methods.
   */
  get attractors() {
    return this._attractors.slice(0);
  }
  /**
   * Add an attractor to the particle system. Attractors are used to change the direction of the particles in the system.
   * @param attractor The attractor to add to the particle system
   */
  addAttractor(attractor) {
    this._attractors.push(attractor);
    if (this._attractors.length === 1) {
      this._attractorUpdate = {
        process: (particle) => {
          for (const attractor2 of this._attractors) {
            attractor2._processParticle(particle, this);
          }
        },
        previousItem: null,
        nextItem: null
      };
      _ConnectAfter(this._attractorUpdate, this._directionProcessing);
    }
  }
  /**
   * Removes an attractor from the particle system. Attractors are used to change the direction of the particles in the system.
   * @param attractor The attractor to remove from the particle system
   */
  removeAttractor(attractor) {
    const index = this._attractors.indexOf(attractor);
    if (index !== -1) {
      this._attractors.splice(index, 1);
    }
    if (this._attractors.length === 0) {
      _RemoveFromQueue(this._attractorUpdate);
    }
  }
  start(delay = this.startDelay) {
    if (!this.canStart()) {
      return;
    }
    super.start(delay);
  }
  /**
   * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
   * @param radius The radius of the hemisphere to emit from
   * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
   * @returns the emitter
   */
  createHemisphericEmitter(radius = 1, radiusRange = 1) {
    const particleEmitter = CreateHemisphericEmitter(radius, radiusRange);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  /**
   * Creates a Sphere Emitter for the particle system (emits along the sphere radius)
   * @param radius The radius of the sphere to emit from
   * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
   * @returns the emitter
   */
  createSphereEmitter(radius = 1, radiusRange = 1) {
    const particleEmitter = CreateSphereEmitter(radius, radiusRange);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  /**
   * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
   * @param radius The radius of the sphere to emit from
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
   * @returns the emitter
   */
  createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    const particleEmitter = CreateDirectedSphereEmitter(radius, direction1, direction2);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  /**
   * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
   * @param radius The radius of the emission cylinder
   * @param height The height of the emission cylinder
   * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
   * @param directionRandomizer How much to randomize the particle direction [0-1]
   * @returns the emitter
   */
  createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
    const particleEmitter = CreateCylinderEmitter(radius, height, radiusRange, directionRandomizer);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  /**
   * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
   * @param radius The radius of the cylinder to emit from
   * @param height The height of the emission cylinder
   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
   * @returns the emitter
   */
  createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    const particleEmitter = CreateDirectedCylinderEmitter(radius, height, radiusRange, direction1, direction2);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  /**
   * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
   * @param radius The radius of the cone to emit from
   * @param angle The base angle of the cone
   * @returns the emitter
   */
  createConeEmitter(radius = 1, angle = Math.PI / 4) {
    const particleEmitter = CreateConeEmitter(radius, angle);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  createDirectedConeEmitter(radius = 1, angle = Math.PI / 4, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    const particleEmitter = CreateDirectedConeEmitter(radius, angle, direction1, direction2);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  /**
   * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
   * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
   * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
   * @returns the emitter
   */
  createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {
    const particleEmitter = new BoxParticleEmitter();
    this.particleEmitterType = particleEmitter;
    this.direction1 = direction1;
    this.direction2 = direction2;
    this.minEmitBox = minEmitBox;
    this.maxEmitBox = maxEmitBox;
    return particleEmitter;
  }
  _prepareSubEmitterInternalArray() {
    this._subEmitters = new Array();
    if (this.subEmitters) {
      for (const subEmitter of this.subEmitters) {
        if (subEmitter instanceof _ParticleSystem) {
          this._subEmitters.push([new SubEmitter(subEmitter)]);
        } else if (subEmitter instanceof SubEmitter) {
          this._subEmitters.push([subEmitter]);
        } else if (subEmitter instanceof Array) {
          this._subEmitters.push(subEmitter);
        }
      }
    }
  }
  _stopSubEmitters() {
    if (!this.activeSubSystems) {
      return;
    }
    for (const subSystem of this.activeSubSystems) {
      subSystem.stop(true);
    }
    this.activeSubSystems = [];
  }
  _removeFromRoot() {
    if (!this._rootParticleSystem) {
      return;
    }
    const index = this._rootParticleSystem.activeSubSystems.indexOf(this);
    if (index !== -1) {
      this._rootParticleSystem.activeSubSystems.splice(index, 1);
    }
    this._rootParticleSystem = null;
  }
  /** @internal */
  _preStart() {
    this._prepareSubEmitterInternalArray();
    if (this._subEmitters && this._subEmitters.length != 0) {
      this.activeSubSystems = [];
    }
  }
  /** @internal */
  _postStop(stopSubEmitters) {
    if (stopSubEmitters) {
      this._stopSubEmitters();
    }
  }
  /** @internal */
  _prepareParticle(particle) {
    if (this._subEmitters && this._subEmitters.length > 0) {
      const subEmitters = this._subEmitters[Math.floor(Math.random() * this._subEmitters.length)];
      particle._attachedSubEmitters = [];
      for (const subEmitter of subEmitters) {
        if (subEmitter.type === 0) {
          const newEmitter = subEmitter.clone();
          particle._attachedSubEmitters.push(newEmitter);
          newEmitter.particleSystem.start();
        }
      }
    }
  }
  /** @internal */
  _onDispose(disposeAttachedSubEmitters = false, disposeEndSubEmitters = false) {
    this._removeFromRoot();
    if (this.subEmitters && !this._subEmitters) {
      this._prepareSubEmitterInternalArray();
    }
    if (disposeAttachedSubEmitters) {
      if (this.particles) {
        for (const particle of this.particles) {
          if (particle._attachedSubEmitters) {
            for (let i = particle._attachedSubEmitters.length - 1; i >= 0; i -= 1) {
              particle._attachedSubEmitters[i].dispose();
            }
          }
        }
      }
    }
    if (disposeEndSubEmitters) {
      if (this.activeSubSystems) {
        for (let i = this.activeSubSystems.length - 1; i >= 0; i -= 1) {
          this.activeSubSystems[i].dispose();
        }
      }
    }
    if (this._subEmitters && this._subEmitters.length) {
      for (let index = 0; index < this._subEmitters.length; index++) {
        for (const subEmitter of this._subEmitters[index]) {
          subEmitter.dispose();
        }
      }
      this._subEmitters = [];
      this.subEmitters = [];
    }
    if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {
      this.emitter.dispose(true);
    }
  }
  /**
   * @internal
   */
  static _Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl) {
    let scene;
    if (sceneOrEngine instanceof AbstractEngine) {
      scene = null;
    } else {
      scene = sceneOrEngine;
    }
    const internalClass = GetClass("BABYLON.Texture");
    if (internalClass && scene) {
      if (parsedParticleSystem.texture) {
        particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl);
      } else if (parsedParticleSystem.textureName) {
        particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== void 0 ? parsedParticleSystem.invertY : true);
        particleSystem.particleTexture.name = parsedParticleSystem.textureName;
      }
    }
    if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === void 0) {
      particleSystem.emitter = Vector3.Zero();
    } else if (parsedParticleSystem.emitterId && scene) {
      particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);
    } else {
      particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);
    }
    particleSystem.isLocal = !!parsedParticleSystem.isLocal;
    if (parsedParticleSystem.renderingGroupId !== void 0) {
      particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;
    }
    if (parsedParticleSystem.isBillboardBased !== void 0) {
      particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;
    }
    if (parsedParticleSystem.billboardMode !== void 0) {
      particleSystem.billboardMode = parsedParticleSystem.billboardMode;
    }
    if (parsedParticleSystem.useLogarithmicDepth !== void 0) {
      particleSystem.useLogarithmicDepth = parsedParticleSystem.useLogarithmicDepth;
    }
    if (parsedParticleSystem.animations) {
      for (let animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {
        const parsedAnimation = parsedParticleSystem.animations[animationIndex];
        const internalClass2 = GetClass("BABYLON.Animation");
        if (internalClass2) {
          particleSystem.animations.push(internalClass2.Parse(parsedAnimation));
        }
      }
      particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;
      particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;
      particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;
      particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;
    }
    if (parsedParticleSystem.autoAnimate && scene) {
      scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1);
    }
    particleSystem.startDelay = parsedParticleSystem.startDelay | 0;
    particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;
    particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;
    particleSystem.minSize = parsedParticleSystem.minSize;
    particleSystem.maxSize = parsedParticleSystem.maxSize;
    if (parsedParticleSystem.minScaleX) {
      particleSystem.minScaleX = parsedParticleSystem.minScaleX;
      particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;
      particleSystem.minScaleY = parsedParticleSystem.minScaleY;
      particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;
    }
    if (parsedParticleSystem.preWarmCycles !== void 0) {
      particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;
      particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;
    }
    if (parsedParticleSystem.minInitialRotation !== void 0) {
      particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;
      particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;
    }
    particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;
    particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;
    particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;
    particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;
    particleSystem.emitRate = parsedParticleSystem.emitRate;
    particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);
    if (parsedParticleSystem.noiseStrength) {
      particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);
    }
    particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);
    particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);
    particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);
    particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;
    particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;
    particleSystem.blendMode = parsedParticleSystem.blendMode;
    if (parsedParticleSystem.colorGradients) {
      for (const colorGradient of parsedParticleSystem.colorGradients) {
        particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : void 0);
      }
    }
    if (parsedParticleSystem.rampGradients) {
      for (const rampGradient of parsedParticleSystem.rampGradients) {
        particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));
      }
      particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;
    }
    if (parsedParticleSystem.colorRemapGradients) {
      for (const colorRemapGradient of parsedParticleSystem.colorRemapGradients) {
        particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== void 0 ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);
      }
    }
    if (parsedParticleSystem.alphaRemapGradients) {
      for (const alphaRemapGradient of parsedParticleSystem.alphaRemapGradients) {
        particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== void 0 ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);
      }
    }
    if (parsedParticleSystem.sizeGradients) {
      for (const sizeGradient of parsedParticleSystem.sizeGradients) {
        particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== void 0 ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);
      }
    }
    if (parsedParticleSystem.angularSpeedGradients) {
      for (const angularSpeedGradient of parsedParticleSystem.angularSpeedGradients) {
        particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== void 0 ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);
      }
    }
    if (parsedParticleSystem.velocityGradients) {
      for (const velocityGradient of parsedParticleSystem.velocityGradients) {
        particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== void 0 ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);
      }
    }
    if (parsedParticleSystem.dragGradients) {
      for (const dragGradient of parsedParticleSystem.dragGradients) {
        particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== void 0 ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);
      }
    }
    if (parsedParticleSystem.emitRateGradients) {
      for (const emitRateGradient of parsedParticleSystem.emitRateGradients) {
        particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== void 0 ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);
      }
    }
    if (parsedParticleSystem.startSizeGradients) {
      for (const startSizeGradient of parsedParticleSystem.startSizeGradients) {
        particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== void 0 ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);
      }
    }
    if (parsedParticleSystem.lifeTimeGradients) {
      for (const lifeTimeGradient of parsedParticleSystem.lifeTimeGradients) {
        particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== void 0 ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);
      }
    }
    if (parsedParticleSystem.limitVelocityGradients) {
      for (const limitVelocityGradient of parsedParticleSystem.limitVelocityGradients) {
        particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== void 0 ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);
      }
      particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;
    }
    if (parsedParticleSystem.noiseTexture && scene) {
      const internalClass2 = GetClass("BABYLON.ProceduralTexture");
      particleSystem.noiseTexture = internalClass2.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);
    }
    let emitterType;
    if (parsedParticleSystem.particleEmitterType) {
      switch (parsedParticleSystem.particleEmitterType.type) {
        case "SphereParticleEmitter":
          emitterType = new SphereParticleEmitter();
          break;
        case "SphereDirectedParticleEmitter":
          emitterType = new SphereDirectedParticleEmitter();
          break;
        case "ConeEmitter":
        case "ConeParticleEmitter":
          emitterType = new ConeParticleEmitter();
          break;
        case "ConeDirectedParticleEmitter":
          emitterType = new ConeDirectedParticleEmitter();
          break;
        case "CylinderParticleEmitter":
          emitterType = new CylinderParticleEmitter();
          break;
        case "CylinderDirectedParticleEmitter":
          emitterType = new CylinderDirectedParticleEmitter();
          break;
        case "HemisphericParticleEmitter":
          emitterType = new HemisphericParticleEmitter();
          break;
        case "PointParticleEmitter":
          emitterType = new PointParticleEmitter();
          break;
        case "MeshParticleEmitter":
          emitterType = new MeshParticleEmitter();
          break;
        case "CustomParticleEmitter":
          emitterType = new CustomParticleEmitter();
          break;
        case "BoxEmitter":
        case "BoxParticleEmitter":
        default:
          emitterType = new BoxParticleEmitter();
          break;
      }
      emitterType.parse(parsedParticleSystem.particleEmitterType, scene);
    } else {
      emitterType = new BoxParticleEmitter();
      emitterType.parse(parsedParticleSystem, scene);
    }
    particleSystem.particleEmitterType = emitterType;
    particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;
    particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;
    particleSystem.spriteCellLoop = parsedParticleSystem.spriteCellLoop ?? true;
    particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;
    particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;
    particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;
    particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;
    particleSystem.disposeOnStop = parsedParticleSystem.disposeOnStop ?? false;
    particleSystem.manualEmitCount = parsedParticleSystem.manualEmitCount ?? -1;
  }
  /**
   * Parses a JSON object to create a particle system.
   * @param parsedParticleSystem The JSON object to parse
   * @param sceneOrEngine The scene or the engine to create the particle system in
   * @param rootUrl The root url to use to load external dependencies like texture
   * @param doNotStart Ignore the preventAutoStart attribute and does not start
   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)
   * @returns the Parsed particle system
   */
  static Parse(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart = false, capacity) {
    const name = parsedParticleSystem.name;
    let custom = null;
    let program = null;
    let engine;
    let scene;
    if (sceneOrEngine instanceof AbstractEngine) {
      engine = sceneOrEngine;
    } else {
      scene = sceneOrEngine;
      engine = scene.getEngine();
    }
    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {
      program = parsedParticleSystem.customShader;
      const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
      custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);
    }
    const particleSystem = new _ParticleSystem(name, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);
    particleSystem.customShader = program;
    particleSystem._rootUrl = rootUrl;
    if (parsedParticleSystem.id) {
      particleSystem.id = parsedParticleSystem.id;
    }
    if (parsedParticleSystem.subEmitters) {
      particleSystem.subEmitters = [];
      for (const cell of parsedParticleSystem.subEmitters) {
        const cellArray = [];
        for (const sub of cell) {
          cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));
        }
        particleSystem.subEmitters.push(cellArray);
      }
    }
    if (parsedParticleSystem.attractors) {
      for (const attractor of parsedParticleSystem.attractors) {
        const newAttractor = new Attractor();
        newAttractor.position = Vector3.FromArray(attractor.position);
        newAttractor.strength = attractor.strength;
        particleSystem.addAttractor(newAttractor);
      }
    }
    _ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);
    if (parsedParticleSystem.textureMask) {
      particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);
    }
    if (parsedParticleSystem.worldOffset) {
      particleSystem.worldOffset = Vector3.FromArray(parsedParticleSystem.worldOffset);
    }
    if (parsedParticleSystem.preventAutoStart) {
      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;
    }
    if (parsedParticleSystem.metadata) {
      particleSystem.metadata = parsedParticleSystem.metadata;
    }
    if (!doNotStart && !particleSystem.preventAutoStart) {
      particleSystem.start();
    }
    return particleSystem;
  }
  /**
   * Serializes the particle system to a JSON object
   * @param serializeTexture defines if the texture must be serialized as well
   * @returns the JSON object
   */
  serialize(serializeTexture = false) {
    const serializationObject = {};
    _ParticleSystem._Serialize(serializationObject, this, serializeTexture);
    serializationObject.textureMask = this.textureMask.asArray();
    serializationObject.customShader = this.customShader;
    serializationObject.preventAutoStart = this.preventAutoStart;
    serializationObject.worldOffset = this.worldOffset.asArray();
    if (this.metadata) {
      serializationObject.metadata = this.metadata;
    }
    if (this.subEmitters) {
      serializationObject.subEmitters = [];
      if (!this._subEmitters) {
        this._prepareSubEmitterInternalArray();
      }
      for (const subs of this._subEmitters) {
        const cell = [];
        for (const sub of subs) {
          cell.push(sub.serialize(serializeTexture));
        }
        serializationObject.subEmitters.push(cell);
      }
    }
    if (this._attractors && this._attractors.length) {
      serializationObject.attractors = [];
      for (const attractor of this._attractors) {
        serializationObject.attractors.push(attractor.serialize());
      }
    }
    return serializationObject;
  }
  /**
   * @internal
   */
  static _Serialize(serializationObject, particleSystem, serializeTexture) {
    serializationObject.name = particleSystem.name;
    serializationObject.id = particleSystem.id;
    serializationObject.capacity = particleSystem.getCapacity();
    serializationObject.disposeOnStop = particleSystem.disposeOnStop;
    serializationObject.manualEmitCount = particleSystem.manualEmitCount;
    if (particleSystem.emitter.position) {
      const emitterMesh = particleSystem.emitter;
      serializationObject.emitterId = emitterMesh.id;
    } else {
      const emitterPosition = particleSystem.emitter;
      serializationObject.emitter = emitterPosition.asArray();
    }
    if (particleSystem.particleEmitterType) {
      serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();
    }
    if (particleSystem.particleTexture) {
      if (serializeTexture) {
        serializationObject.texture = particleSystem.particleTexture.serialize();
      } else {
        serializationObject.textureName = particleSystem.particleTexture.name;
        serializationObject.invertY = !!particleSystem.particleTexture._invertY;
      }
    }
    serializationObject.isLocal = particleSystem.isLocal;
    SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);
    serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;
    serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;
    serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;
    serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;
    serializationObject.startDelay = particleSystem.startDelay;
    serializationObject.renderingGroupId = particleSystem.renderingGroupId;
    serializationObject.isBillboardBased = particleSystem.isBillboardBased;
    serializationObject.billboardMode = particleSystem.billboardMode;
    serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;
    serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;
    serializationObject.minSize = particleSystem.minSize;
    serializationObject.maxSize = particleSystem.maxSize;
    serializationObject.minScaleX = particleSystem.minScaleX;
    serializationObject.maxScaleX = particleSystem.maxScaleX;
    serializationObject.minScaleY = particleSystem.minScaleY;
    serializationObject.maxScaleY = particleSystem.maxScaleY;
    serializationObject.minEmitPower = particleSystem.minEmitPower;
    serializationObject.maxEmitPower = particleSystem.maxEmitPower;
    serializationObject.minLifeTime = particleSystem.minLifeTime;
    serializationObject.maxLifeTime = particleSystem.maxLifeTime;
    serializationObject.emitRate = particleSystem.emitRate;
    serializationObject.gravity = particleSystem.gravity.asArray();
    serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();
    serializationObject.color1 = particleSystem.color1.asArray();
    serializationObject.color2 = particleSystem.color2.asArray();
    serializationObject.colorDead = particleSystem.colorDead.asArray();
    serializationObject.updateSpeed = particleSystem.updateSpeed;
    serializationObject.targetStopDuration = particleSystem.targetStopDuration;
    serializationObject.blendMode = particleSystem.blendMode;
    serializationObject.preWarmCycles = particleSystem.preWarmCycles;
    serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;
    serializationObject.minInitialRotation = particleSystem.minInitialRotation;
    serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;
    serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;
    serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;
    serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;
    serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;
    serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;
    serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;
    serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;
    serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;
    serializationObject.useLogarithmicDepth = particleSystem.useLogarithmicDepth;
    const colorGradients = particleSystem.getColorGradients();
    if (colorGradients) {
      serializationObject.colorGradients = [];
      for (const colorGradient of colorGradients) {
        const serializedGradient = {
          gradient: colorGradient.gradient,
          color1: colorGradient.color1.asArray()
        };
        if (colorGradient.color2) {
          serializedGradient.color2 = colorGradient.color2.asArray();
        } else {
          serializedGradient.color2 = colorGradient.color1.asArray();
        }
        serializationObject.colorGradients.push(serializedGradient);
      }
    }
    const rampGradients = particleSystem.getRampGradients();
    if (rampGradients) {
      serializationObject.rampGradients = [];
      for (const rampGradient of rampGradients) {
        const serializedGradient = {
          gradient: rampGradient.gradient,
          color: rampGradient.color.asArray()
        };
        serializationObject.rampGradients.push(serializedGradient);
      }
      serializationObject.useRampGradients = particleSystem.useRampGradients;
    }
    const colorRemapGradients = particleSystem.getColorRemapGradients();
    if (colorRemapGradients) {
      serializationObject.colorRemapGradients = [];
      for (const colorRemapGradient of colorRemapGradients) {
        const serializedGradient = {
          gradient: colorRemapGradient.gradient,
          factor1: colorRemapGradient.factor1
        };
        if (colorRemapGradient.factor2 !== void 0) {
          serializedGradient.factor2 = colorRemapGradient.factor2;
        } else {
          serializedGradient.factor2 = colorRemapGradient.factor1;
        }
        serializationObject.colorRemapGradients.push(serializedGradient);
      }
    }
    const alphaRemapGradients = particleSystem.getAlphaRemapGradients();
    if (alphaRemapGradients) {
      serializationObject.alphaRemapGradients = [];
      for (const alphaRemapGradient of alphaRemapGradients) {
        const serializedGradient = {
          gradient: alphaRemapGradient.gradient,
          factor1: alphaRemapGradient.factor1
        };
        if (alphaRemapGradient.factor2 !== void 0) {
          serializedGradient.factor2 = alphaRemapGradient.factor2;
        } else {
          serializedGradient.factor2 = alphaRemapGradient.factor1;
        }
        serializationObject.alphaRemapGradients.push(serializedGradient);
      }
    }
    const sizeGradients = particleSystem.getSizeGradients();
    if (sizeGradients) {
      serializationObject.sizeGradients = [];
      for (const sizeGradient of sizeGradients) {
        const serializedGradient = {
          gradient: sizeGradient.gradient,
          factor1: sizeGradient.factor1
        };
        if (sizeGradient.factor2 !== void 0) {
          serializedGradient.factor2 = sizeGradient.factor2;
        } else {
          serializedGradient.factor2 = sizeGradient.factor1;
        }
        serializationObject.sizeGradients.push(serializedGradient);
      }
    }
    const angularSpeedGradients = particleSystem.getAngularSpeedGradients();
    if (angularSpeedGradients) {
      serializationObject.angularSpeedGradients = [];
      for (const angularSpeedGradient of angularSpeedGradients) {
        const serializedGradient = {
          gradient: angularSpeedGradient.gradient,
          factor1: angularSpeedGradient.factor1
        };
        if (angularSpeedGradient.factor2 !== void 0) {
          serializedGradient.factor2 = angularSpeedGradient.factor2;
        } else {
          serializedGradient.factor2 = angularSpeedGradient.factor1;
        }
        serializationObject.angularSpeedGradients.push(serializedGradient);
      }
    }
    const velocityGradients = particleSystem.getVelocityGradients();
    if (velocityGradients) {
      serializationObject.velocityGradients = [];
      for (const velocityGradient of velocityGradients) {
        const serializedGradient = {
          gradient: velocityGradient.gradient,
          factor1: velocityGradient.factor1
        };
        if (velocityGradient.factor2 !== void 0) {
          serializedGradient.factor2 = velocityGradient.factor2;
        } else {
          serializedGradient.factor2 = velocityGradient.factor1;
        }
        serializationObject.velocityGradients.push(serializedGradient);
      }
    }
    const dragGradients = particleSystem.getDragGradients();
    if (dragGradients) {
      serializationObject.dragGradients = [];
      for (const dragGradient of dragGradients) {
        const serializedGradient = {
          gradient: dragGradient.gradient,
          factor1: dragGradient.factor1
        };
        if (dragGradient.factor2 !== void 0) {
          serializedGradient.factor2 = dragGradient.factor2;
        } else {
          serializedGradient.factor2 = dragGradient.factor1;
        }
        serializationObject.dragGradients.push(serializedGradient);
      }
    }
    const emitRateGradients = particleSystem.getEmitRateGradients();
    if (emitRateGradients) {
      serializationObject.emitRateGradients = [];
      for (const emitRateGradient of emitRateGradients) {
        const serializedGradient = {
          gradient: emitRateGradient.gradient,
          factor1: emitRateGradient.factor1
        };
        if (emitRateGradient.factor2 !== void 0) {
          serializedGradient.factor2 = emitRateGradient.factor2;
        } else {
          serializedGradient.factor2 = emitRateGradient.factor1;
        }
        serializationObject.emitRateGradients.push(serializedGradient);
      }
    }
    const startSizeGradients = particleSystem.getStartSizeGradients();
    if (startSizeGradients) {
      serializationObject.startSizeGradients = [];
      for (const startSizeGradient of startSizeGradients) {
        const serializedGradient = {
          gradient: startSizeGradient.gradient,
          factor1: startSizeGradient.factor1
        };
        if (startSizeGradient.factor2 !== void 0) {
          serializedGradient.factor2 = startSizeGradient.factor2;
        } else {
          serializedGradient.factor2 = startSizeGradient.factor1;
        }
        serializationObject.startSizeGradients.push(serializedGradient);
      }
    }
    const lifeTimeGradients = particleSystem.getLifeTimeGradients();
    if (lifeTimeGradients) {
      serializationObject.lifeTimeGradients = [];
      for (const lifeTimeGradient of lifeTimeGradients) {
        const serializedGradient = {
          gradient: lifeTimeGradient.gradient,
          factor1: lifeTimeGradient.factor1
        };
        if (lifeTimeGradient.factor2 !== void 0) {
          serializedGradient.factor2 = lifeTimeGradient.factor2;
        } else {
          serializedGradient.factor2 = lifeTimeGradient.factor1;
        }
        serializationObject.lifeTimeGradients.push(serializedGradient);
      }
    }
    const limitVelocityGradients = particleSystem.getLimitVelocityGradients();
    if (limitVelocityGradients) {
      serializationObject.limitVelocityGradients = [];
      for (const limitVelocityGradient of limitVelocityGradients) {
        const serializedGradient = {
          gradient: limitVelocityGradient.gradient,
          factor1: limitVelocityGradient.factor1
        };
        if (limitVelocityGradient.factor2 !== void 0) {
          serializedGradient.factor2 = limitVelocityGradient.factor2;
        } else {
          serializedGradient.factor2 = limitVelocityGradient.factor1;
        }
        serializationObject.limitVelocityGradients.push(serializedGradient);
      }
      serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;
    }
    if (particleSystem.noiseTexture) {
      serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();
    }
  }
  // Clone
  /**
   * Clones the particle system.
   * @param name The name of the cloned object
   * @param newEmitter The new emitter to use
   * @param cloneTexture Also clone the textures if true
   * @returns the cloned particle system
   */
  clone(name, newEmitter, cloneTexture = false) {
    const custom = { ...this._customWrappers };
    let program = null;
    const engine = this._engine;
    if (engine.createEffectForParticles) {
      if (this.customShader != null) {
        program = this.customShader;
        const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
        const effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);
        if (!custom[0]) {
          this.setCustomEffect(effect, 0);
        } else {
          custom[0].effect = effect;
        }
      }
    }
    const serialization = this.serialize(cloneTexture);
    const result = _ParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);
    result.name = name;
    result.customShader = program;
    result._customWrappers = custom;
    if (newEmitter === void 0) {
      newEmitter = this.emitter;
    }
    if (this.noiseTexture) {
      result.noiseTexture = this.noiseTexture.clone();
    }
    result.emitter = newEmitter;
    if (!this.preventAutoStart) {
      result.start();
    }
    return result;
  }
};
ParticleSystem.BILLBOARDMODE_Y = 2;
ParticleSystem.BILLBOARDMODE_ALL = 7;
ParticleSystem.BILLBOARDMODE_STRETCHED = 8;
ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL = 9;
SubEmitter._ParseParticleSystem = ParticleSystem.Parse;

export {
  RawTexture,
  BaseParticleSystem,
  ColorGradient,
  Color3Gradient,
  FactorGradient,
  GradientHelper,
  Particle,
  BoxParticleEmitter,
  _ConnectAtTheEnd,
  SubEmitterType,
  SubEmitter,
  MeshParticleEmitter,
  PointParticleEmitter,
  HemisphericParticleEmitter,
  SphereParticleEmitter,
  SphereDirectedParticleEmitter,
  CylinderParticleEmitter,
  CylinderDirectedParticleEmitter,
  ConeParticleEmitter,
  ConeDirectedParticleEmitter,
  CreatePointEmitter,
  CreateHemisphericEmitter,
  CreateSphereEmitter,
  CreateDirectedSphereEmitter,
  CreateCylinderEmitter,
  CreateDirectedCylinderEmitter,
  CreateConeEmitter,
  CreateDirectedConeEmitter,
  Attractor,
  ParticleSystem
};
//# sourceMappingURL=chunk-R2MWZDKJ.js.map
